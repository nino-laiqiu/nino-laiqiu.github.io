<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>linux常用命令</title>
    <url>/2020/10/12/Common-Commands-In-Linux/</url>
    <content><![CDATA[<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>rm filename:删除文件</p>
<p>rm -r :询问删除目录内容或者文件</p>
<p>rm -rf   删除当前目录下的所有文件及目录，并且是直接删除</p>
<p>rm  -r  *  删除当前目录下的所有内容</p>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>cat -n filename:给文件内容添加行号,空行也添加</p>
<p>cat -b filename:给文件内容添加行号,空行跳过</p>
<p><strong>cat /dev/null &gt; /pathname:删除文件的内容</strong></p>
<h4 id="mv-options安全参数"><a href="#mv-options安全参数" class="headerlink" title="mv(options安全参数)"></a>mv(options安全参数)</h4><p>mv /root/a.txt /root/b.txt :目标目录与原目录一致，指定了新文件名，效果就是仅仅重命名</p>
<p>mv /root/a.txt /root/catalogue/ :目标目录与原目录不一致，没有指定新文件名，效果就是仅仅移动</p>
<p>mv /root/a.txt /root/aa/b.txt :目标目录与原目录一致, 指定了新文件名，效果就是：移动 + 重命名</p>
<p>mv /root/* .  :把root目录的所有内容移动到当前目录;需要先执行显示隐藏文件命令，否则隐藏文件以及隐藏文件夹不会被移动到新目录</p>
<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>cp a.txt  /catalogue 复制文件到目录</p>
<p>cp a.txt /b.txt 复制文件到文件,文件存在则是覆盖,不存在则是重命名</p>
<p>cp -r  :递归处理 复制目录</p>
<p>cp-p :保留文件属性(原文件事件不变)</p>
<h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>touch file :创建一个名为“file”的新的空白文件 </p>
<p>touch testfile  :修改文件testfile的时间属性</p>
<h4 id="chgrp、chmod、chown"><a href="#chgrp、chmod、chown" class="headerlink" title="chgrp、chmod、chown"></a>chgrp、chmod、chown</h4><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find / -name “*.txt” :将目前目录及其子目录下所有延伸档名是txt 的文件列出来。</p>
<p>find / -type f :将目前目录其其下子目录中所有一般文件列出</p>
<p>find / ctime -20 :查找最近20天修改过的文件</p>
<h4 id="less-more"><a href="#less-more" class="headerlink" title="less more"></a>less more</h4><h4 id="head-tail"><a href="#head-tail" class="headerlink" title="head tail"></a>head tail</h4><p>head -n 5 ls-output.txt  :查看开头五行内容 </p>
<p>tail -n 5 ls-output.txt :查看结尾五行内容</p>
<h4 id="awk-未完"><a href="#awk-未完" class="headerlink" title="awk(未完)"></a>awk(未完)</h4><p>awk ‘{print $1,$4}’ b.txt :取文件每一行的第一和第四项打印</p>
<h2 id="文档编辑"><a href="#文档编辑" class="headerlink" title="文档编辑"></a>文档编辑</h2><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep  characters  *txt :查找文件名后缀带有txt内容有characters,并打印该行</p>
<p>grep  -r words  /root :递归查找路径下内容有words的文件名</p>
<p>grep -v test  *txt :反向查找</p>
<p>文件传输</p>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>mkdir -p /filepath :递归创建目录</p>
<h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>ls -A  :显示所有文件和目录,包括隐藏文件</p>
<p>ls -ltr s*:列出目前工作目录下所有名称是 s 开头的文件，越新的排越后面 </p>
<h2 id="磁盘维护"><a href="#磁盘维护" class="headerlink" title="磁盘维护"></a>磁盘维护</h2><h2 id="网络通讯"><a href="#网络通讯" class="headerlink" title="网络通讯"></a>网络通讯</h2><h4 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h4><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>kill -9 123456:彻底杀死123456进程</p>
<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>ps -A:显示进程信息</p>
<p>ps -u root:显示root进程用户信息</p>
<p>ps -ef:显示所有命令，连带命令行</p>
<p>ps aux: 查看系统内存中的正在运行的进程</p>
<p>ps -ef|grep ssh :与管道命令组合使用查出特定进程</p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top -n 2:设置信息更新次数</p>
<p>top -p 139:显示指定的进程信息</p>
<h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>sudo -l :显示出自己（执行 sudo 的使用者）的权限</p>
<p>sudo -u user ls :指定用户执行命令</p>
<h4 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h4><p>pstree -apnh:显示进程间的关系</p>
<p>pstree -u:显示用户名称</p>
<h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><h4 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h4><h4 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h4><p>yum repolist 软件名称 :列出设定yum源信息</p>
<p>yum remove 软件名称 :卸载</p>
<p>yum list installed :查看已经安装的软件</p>
<p>yum search 软件信息 :根据软件信息搜索软件名字</p>
]]></content>
      <categories>
        <category>Computer engineering</category>
      </categories>
      <tags>
        <tag>basis of computer engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络摘要</title>
    <url>/2020/07/25/Computer-network-interview-questions/</url>
    <content><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h3 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h3><p><strong>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol</strong></p>
<ul>
<li><p>HTTP 是一个用在计算机世界里的协议  . 它使用计算机能够理解的语言确立了一种计算机之间交流通信 的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）</p>
</li>
<li><p>HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。(允许中间有中转或接力)</p>
</li>
<li><p>HTTP 传输的内容是「超文本」.「超文本」是超越了普通文本的文本，它是文字、图片、视频等的混合体，关键有超 链接，能从一个超文本跳转到另外一个超文本</p>
</li>
</ul>
<p><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据 的「约定和规范」</strong></p>
<hr>
<h1 id="全家桶"><a href="#全家桶" class="headerlink" title="全家桶"></a>全家桶</h1><h3 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h3><p>IP（网络层） 和 MAC （数据链路层）之间的区别和关系?</p>
<p>IP 的作用是主机之间通信用的，而 MAC 的作用则是实现「直连」 的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输</p>
<h3 id="IP地址的基础知识"><a href="#IP地址的基础知识" class="headerlink" title="IP地址的基础知识"></a>IP地址的基础知识</h3><h3 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h3>]]></content>
      <categories>
        <category>Computer engineering</category>
      </categories>
      <tags>
        <tag>basis of computer engineering</tag>
        <tag>Reading Books</tag>
      </tags>
  </entry>
  <entry>
    <title>数据驱动摘要(神策)</title>
    <url>/2020/12/27/Data-Driven-Computation/</url>
    <content><![CDATA[<h1 id="数据思维与数据驱动"><a href="#数据思维与数据驱动" class="headerlink" title="数据思维与数据驱动"></a>数据思维与数据驱动</h1><p>1.大数据的概念<br>大:不是数据量的”大”,而是宏观的,覆盖面广<br>全:强调多种数据源<br>细:细节精准,多维度数据<br>时:实时采集实时分析<br>不是截面的静态的,而是时间序列多维度的</p>
<p><strong>信息的四个层次</strong><br>经验——&gt;新事物<br>过去——&gt;未来<br>数据—-离散元素<br>信息—-连接元素<br>知识—-组织信息<br>智慧—-应用知识</p>
<p>2.大数据的本质<br>作者提出了 <strong>数据驱动理念 大数据的本质是消除不确定性</strong></p>
<p>3.数据驱动的价值<br>驱动决策<br>驱动产品智能</p>
<p>4.企业内部数据驱动现状<br>1.时间效率低下<br>2.数据可视化问题,仪表盘只能看到宏观数据<br>3.无法跨越数据孤岛藩篱<br>4.理想中数据驱动———&gt;<strong>流的观念</strong></p>
<p>5.大数据时代到来的条件<br>1.数据采集能力增强<br>2.数据处理能力增强<br>3.数据意识的提升</p>
<h1 id="数据驱动的环节"><a href="#数据驱动的环节" class="headerlink" title="数据驱动的环节"></a>数据驱动的环节</h1><h3 id="1-数据的采集与埋点"><a href="#1-数据的采集与埋点" class="headerlink" title="1.数据的采集与埋点"></a>1.数据的采集与<strong>埋点</strong></h3><p>困惑:如何采 采哪些 用什么手段<br>传统的三个途径:第三方统计工具 通过业务数据库做统计分析 web日志统计分析<br>数据采集的现状:</p>
<p>科学的数据采集和埋点方式<br>可视化/全埋点 代码埋点 导入第三方辅助工具<br>数据的准确性:</p>
<h3 id="2-数据建模"><a href="#2-数据建模" class="headerlink" title="2.数据建模"></a>2.数据建模</h3><p>传统的数据模型<br>多维数据模型——-&gt;数据分层的金字塔模型<br><strong>多维事件模型</strong>:<br>Event实体 :描述了一个用户在某一个时间点及某个地方以某种方式完成了某个具体事情<br>User实体<br>多维事件模型的探索<br>用户行为查询平台 logdata平台 用户行为数据</p>
<h3 id="3-数据分析方法"><a href="#3-数据分析方法" class="headerlink" title="3.数据分析方法"></a>3.数据分析方法</h3><p>行为事件分析<br>漏斗分析:——&gt;<strong>属性关联</strong><br>用户从起点到终点各个阶段用户转化率<br>留存分析:<br>对产品上线及新功能上线时,用户留存率的分析<br>分布分析<br>点击分析<br>用户路径<br>用户分群(用户信息标签化)<br>属性分析</p>
<h3 id="4-指标体系的构建"><a href="#4-指标体系的构建" class="headerlink" title="4.指标体系的构建"></a>4.指标体系的构建</h3><p>第一关键指标法<br>第一个阶段:MVP阶段—-确定用户需求<br>第二个阶段:增长阶段—-关注留存指标和引荐指标<br>第三个阶段:营收阶段—-如何规模化及实现快速盈利</p>
<p>海盗指标法<br>acquisition(获取) activation(激活) retention(留存) revenue(营收) referral(引荐)</p>
<h1 id="数据驱动产品智能"><a href="#数据驱动产品智能" class="headerlink" title="数据驱动产品智能"></a>数据驱动产品智能</h1><p>1.基于机器学习的用户智能<br>回归算法<br>分类算法:离散<br>聚类算法:聚类的标准<br>关联算法:连续的关联规则挖掘</p>
<p>2.<strong>用户画像</strong><br>user persona:主要来源于产品和运营对客户的理解调研与认知<br>user profile:基于真实积累的用户行为 结合具体业务场景产生的一系列标签</p>
<p>3.个性化推荐</p>
]]></content>
      <categories>
        <category>The Hadoop Ecosystem</category>
      </categories>
      <tags>
        <tag>Reading Books</tag>
      </tags>
  </entry>
  <entry>
    <title>Queue</title>
    <url>/2020/08/17/Data-structure-Queue/</url>
    <content><![CDATA[<h4 id="队列实现scala版"><a href="#队列实现scala版" class="headerlink" title="队列实现scala版"></a>队列实现scala版</h4><p>队列是一种特殊的线性表，单向队列只能在一端插入数据（后），另一端删除数据（前）；它和栈一样，队列是一种操作受限制的线性表；进行插入操作的称为队尾，进行删除操作的称为队头；队列中的数据被称为元素；没有元素的队列称为空队列。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="type">Arithmetic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.io.<span class="type">StdIn</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> queue = <span class="keyword">new</span> <span class="type">ArrayQueue</span>(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//初始化一个队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;请输入命令 \n\t&quot;</span> +</span><br><span class="line">        <span class="string">&quot;1.判断是否为空 \n\t&quot;</span> +</span><br><span class="line">        <span class="string">&quot;2.判断是否已满 \n\t &quot;</span> +</span><br><span class="line">        <span class="string">&quot;3.添加数据\n\t&quot;</span> +</span><br><span class="line">        <span class="string">&quot;4.展示内容\n\t&quot;</span> +</span><br><span class="line">        <span class="string">&quot;5.获取数据 \n\t&quot;</span> +</span><br><span class="line">        <span class="string">&quot;6.获取头节点\t\n&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> str = <span class="type">StdIn</span>.readLine()</span><br><span class="line">      str <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;1&quot;</span> =&gt; queue.isNull()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;2&quot;</span> =&gt; queue.isFull()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;3&quot;</span> =&gt; addData()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;4&quot;</span> =&gt; queue.show()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;5&quot;</span> =&gt;</span><br><span class="line">          <span class="keyword">val</span> value = queue.getData()</span><br><span class="line">          <span class="keyword">if</span> (!value.isInstanceOf[<span class="type">Exception</span>]) &#123;</span><br><span class="line">            println(value)</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;6&quot;</span> =&gt;</span><br><span class="line">          <span class="keyword">val</span> value = queue.peek()</span><br><span class="line">          <span class="keyword">if</span> (!value.isInstanceOf[<span class="type">Exception</span>]) &#123;</span><br><span class="line">            println(value)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addData</span></span>() = &#123;</span><br><span class="line">    println(<span class="string">&quot;请输入数字&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> i = <span class="type">StdIn</span>.readInt()</span><br><span class="line">    queue.addData(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用数组来模拟队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>(<span class="params">maxCapacity: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//初始化一个数组</span></span><br><span class="line">  <span class="keyword">val</span> queue = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](maxCapacity<span class="number">-1</span>)</span><br><span class="line">  <span class="comment">//-1是不包含数组数据的(队列的头)</span></span><br><span class="line">  <span class="keyword">var</span> first: <span class="type">Int</span> = <span class="number">-1</span></span><br><span class="line">  <span class="comment">//表示队列添加到哪的索引</span></span><br><span class="line">  <span class="keyword">var</span> rear: <span class="type">Int</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否满了</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isFull</span></span>(): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (first == maxCapacity) &#123;</span><br><span class="line">      println(<span class="string">&quot;已经满了&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      println(<span class="string">&quot;队列没有满可以添加元素&quot;</span>)</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断队列是否为空</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isNull</span></span>(): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (first == rear) &#123;</span><br><span class="line">      println(<span class="string">&quot;队列是空的&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      println(<span class="string">&quot;可添加元素&quot;</span>)</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加到队列</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addData</span></span>(number: <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="comment">//首先rear要后移一个单位</span></span><br><span class="line">    rear += <span class="number">1</span></span><br><span class="line">    <span class="comment">//往数组添加数据</span></span><br><span class="line">    queue(rear) = number</span><br><span class="line">    <span class="comment">//返回值</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取队列的元素,是first加1 但是原来的数据还是存在的,只是访问不到了,需要判断是否有异常</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getData</span></span>(): <span class="type">Any</span> = &#123;</span><br><span class="line">    <span class="comment">//首先判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (isNull()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span>  <span class="type">Exception</span>(<span class="string">&quot;空&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      first += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> queue(first)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//peek方法获取头节点,但是不改变first的值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">peek</span></span>(): <span class="type">Any</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (isNull()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">&quot;空&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> queue(first + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//展示队列的内容</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span></span>() = &#123;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- first + <span class="number">1</span> to rear) &#123;</span><br><span class="line">      printf(<span class="string">&quot;队列%s 内容%d \t\n&quot;</span>, i, queue(i))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="type">Arithmetic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.io.<span class="type">StdIn</span></span><br><span class="line"><span class="comment">//核心思想: 用%来模拟循环(rear +1) /maxsize = first 时为满</span></span><br><span class="line"><span class="comment">//核心思想2:遍历元素时,假设rear节点在first节点之前采用(rear- first)就无法获取数据,</span></span><br><span class="line"><span class="comment">//采用取模的方法来获取队列到底用多少数据 (rear - first + maxCapacity) % maxCapacity</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CircleQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> queue = <span class="keyword">new</span> <span class="type">ArrayCircleQueue</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;请输入命令 \n\t&quot;</span> +</span><br><span class="line">        <span class="string">&quot;1.判断是否为空 \n\t&quot;</span> +</span><br><span class="line">        <span class="string">&quot;2.判断是否已满 \n\t &quot;</span> +</span><br><span class="line">        <span class="string">&quot;3.添加数据\n\t&quot;</span> +</span><br><span class="line">        <span class="string">&quot;4.展示内容\n\t&quot;</span> +</span><br><span class="line">        <span class="string">&quot;5.获取数据 \n\t&quot;</span> +</span><br><span class="line">        <span class="string">&quot;6.获取头节点\t\n&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> str = <span class="type">StdIn</span>.readLine()</span><br><span class="line">      str <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;1&quot;</span> =&gt; queue.isNull()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;2&quot;</span> =&gt; queue.isFull()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;3&quot;</span> =&gt; addData()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;4&quot;</span> =&gt; queue.show()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;5&quot;</span> =&gt;</span><br><span class="line">          <span class="keyword">val</span> value = queue.getData()</span><br><span class="line">          <span class="keyword">if</span> (!value.isInstanceOf[<span class="type">Exception</span>]) &#123;</span><br><span class="line">            println(value)</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;6&quot;</span> =&gt;</span><br><span class="line">          <span class="keyword">val</span> value = queue.peek()</span><br><span class="line">          <span class="keyword">if</span> (!value.isInstanceOf[<span class="type">Exception</span>]) &#123;</span><br><span class="line">            println(value)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addData</span></span>() = &#123;</span><br><span class="line">    println(<span class="string">&quot;请输入数字&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> i = <span class="type">StdIn</span>.readInt()</span><br><span class="line">    queue.addData(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayCircleQueue</span>(<span class="params">maxCapacity: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//数组模拟队列</span></span><br><span class="line">  <span class="keyword">val</span> queue = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](maxCapacity)</span><br><span class="line">  <span class="comment">//两个指针分别代表存取,初始化为0</span></span><br><span class="line">  <span class="keyword">var</span> first: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> rear: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否为空</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isNull</span></span>(): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    first == rear</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否已满</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isFull</span></span>(): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    <span class="comment">//最后一个节点不存储数据,%取余与first比较</span></span><br><span class="line">    (rear + <span class="number">1</span>) % maxCapacity == first</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加元素</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addData</span></span>(number: <span class="type">Int</span>): <span class="type">Any</span> = &#123;</span><br><span class="line">    <span class="comment">//首尔判断是否为满</span></span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">      println(<span class="string">&quot;队列已经满了&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue(rear) = number</span><br><span class="line">    <span class="comment">//rear指针后移</span></span><br><span class="line">    rear = (rear + <span class="number">1</span>) % maxCapacity</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取元素</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getData</span></span>(): <span class="type">Any</span> = &#123;</span><br><span class="line">    <span class="comment">//首先判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (isNull()) &#123;</span><br><span class="line">      println(<span class="string">&quot;该队列为空请添加元素&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用临时节点存储要返回的数据</span></span><br><span class="line">    <span class="keyword">var</span> result = queue(first)</span><br><span class="line">    <span class="comment">//后移first节点</span></span><br><span class="line">    first = (first + <span class="number">1</span>) % maxCapacity</span><br><span class="line">    <span class="comment">//返回要get的队列数据</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取头节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">peek</span></span>(): <span class="type">Any</span> = &#123;</span><br><span class="line">    <span class="comment">//和非循环的写法一致</span></span><br><span class="line">    <span class="keyword">return</span> queue(first)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历队列</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span></span>(): <span class="type">Any</span> = &#123;</span><br><span class="line">    <span class="comment">//这是一个难点,我要保证我能获取之后添加的数据</span></span><br><span class="line">    <span class="keyword">if</span> (isNull()) &#123;</span><br><span class="line">      println(<span class="string">&quot;队列为空&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历队列</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- first until first + size) &#123;</span><br><span class="line">      printf(<span class="string">&quot;array(%d)=%s \t\n&quot;</span>, i % maxCapacity, queue(i % maxCapacity))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取队列的长度</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">    (rear - first + maxCapacity) % maxCapacity</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Computer engineering</category>
        <category>Arithmetic</category>
      </categories>
      <tags>
        <tag>Reading Books</tag>
        <tag>Sorting and Searching Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>维度建模</title>
    <url>/2020/12/12/Dimensional-modeling/</url>
    <content><![CDATA[<p>Data仓库中的Data是细节的、集成的、面向主题的,以OLAPSystam的分析需求为目的</p>
<p>阅读《数据仓库工具箱》并作记录,争取在半年内完成…….</p>
<h2 id="构建Data仓库五步法"><a href="#构建Data仓库五步法" class="headerlink" title="构建Data仓库五步法"></a>构建Data仓库五步法</h2><p>确定主题</p>
<p>例如：我们希望分析某年某月某一地区的啤酒销售情况,这就是一个主题.主题要体现出某一方面的各分析角度(维度)和统计数value型</p>
<p>Data(量度)之间的关系</p>
<p>确定量度</p>
<p>我们将考虑要分析的技术指标,诸如年销售额之类.它们一般为数value型Data.我们或者将该Data汇总,或者将该Data取次数、独立次数或取</p>
<p>最大最小value等,这样的Data称为量度</p>
<p>确定粒度</p>
<p>在确定了量度之后,我们要考虑到该量度的汇总情况和不同维度下量度的聚合情况.考虑到量度的聚合程度不同,我们将采用“最小粒度原则”,即将量度的粒度设置到最小</p>
<p>确定维度</p>
<p>维度是指分析的各个角度.例如我们希望按照时间,或者按照地区,或者按照产品进行分析,那么这里的时间、地区、产品就是相应的维度.基于不同的维度,我们可以看到各量度的汇总情况,也可以基于所有的维度进行交叉分析</p>
<p>确定事实</p>
<p>数据聚合后依据某个维度生成的结果表</p>
<h4 id="缓慢变化维度的三种处理方法"><a href="#缓慢变化维度的三种处理方法" class="headerlink" title="缓慢变化维度的三种处理方法"></a>缓慢变化维度的三种处理方法</h4><p>历史Data需要修改.这种情况下,我们使用UPDATE method来修改维度表中的Data.例如：产品的ID号码为123,后来发现ID号码错了,需</p>
<p>要改写成456,那么,我们就在ETL处理时,直接修改维度表中原来的ID号码为456</p>
<p>历史Data保留,新增Data也要保留.这时,要将原Data更新,将新Data插入,我们使用UPDATE / INSERT.比如:某一员工2005年在A部门,2006</p>
<p>年时他调到了B部门.那么在统计2005年的Data时就应该将该员工定位到A部门;而在统计2006年Data时就应该定位到B部门,然后再有新的</p>
<p>Data插入时,将按照新部门(B部门)进行处理,这样我们的做法是将该维度成员列表加入标识列,将历史的Data标识为“过期”,将目前的Data标</p>
<p>识为“当前的”.另一种method是将该维度打上时间戳,即将历史Data生效的时间段作为它的一个属性,在与原始表匹配生成事实表时将按照</p>
<p>时间段进行关联,这种method的好处是该维度成员生效时间明确</p>
<p>新增Data维度成员改变了属性.例如:某一维度成员新加入了一列,该列在历史Data中不能基于它浏览,而在目前Data和将来Data中可</p>
<p>以按照它浏览,那么此时我们需要改变维度表属性,即加入新的字段列,那么,我们将使用存储过程或程式生成新的维度属性,在后续的</p>
<p>Data中将基于新的属性进行查看</p>
]]></content>
      <categories>
        <category>Project practice results</category>
        <category>Data Warehouse System</category>
      </categories>
      <tags>
        <tag>Work Systematically</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式理论</title>
    <url>/2020/09/16/Distributed-Theory/</url>
    <content><![CDATA[<h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><p>//失效转移的解决方案</p>
<p>//CAP定理</p>
<p>//BASE定理</p>
<p>//分布式一致性协议</p>
<p>//难度过高,改日再写</p>
]]></content>
      <categories>
        <category>Computer engineering</category>
      </categories>
      <tags>
        <tag>Work Systematically</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Flink 架构</title>
    <url>/2020/10/24/Framework-of-ApacheFlink/</url>
    <content><![CDATA[<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><h3 id="搭建Flink所需组件"><a href="#搭建Flink所需组件" class="headerlink" title="搭建Flink所需组件"></a>搭建Flink所需组件</h3>]]></content>
      <categories>
        <category>The Hadoop Ecosystem</category>
        <category>Learning Flink</category>
      </categories>
      <tags>
        <tag>Reading Books</tag>
      </tags>
  </entry>
  <entry>
    <title>流处理基础</title>
    <url>/2020/10/23/Flowprocessing-foundation/</url>
    <content><![CDATA[<blockquote>
<p>摘自: 基于Apache Flink的流处理</p>
</blockquote>
<h1 id="1-dataflow编程概述"><a href="#1-dataflow编程概述" class="headerlink" title="1.dataflow编程概述"></a>1.dataflow编程概述</h1><ol>
<li><p>dataflow图(算子 数据源 数据汇)</p>
</li>
<li><p>数据并行和任务并行</p>
</li>
<li><p>数据交换策略:</p>
<p>转发策略(发送端任务和接收端任务之间一一对应进行传输)<br>广播策略()<br>基于键值的策略(根据某一键值属性对数据分区)<br>随机策略</p>
</li>
</ol>
<h1 id="2-并行流处理"><a href="#2-并行流处理" class="headerlink" title="2.并行流处理"></a>2.并行流处理</h1><p><strong>延迟:表示处理一个事件所需要的的时间<br>吞吐:用来衡量系统处理能力(处理速率)的指标</strong></p>
<p>处理速率取决于数据到来速率,因此吞吐低不意味着性能差<br>通过并行处理多条数据流,可以在处理更多事件的同时降低延迟</p>
<p><strong>无状态:处理事件时无需依赖已经处理过的事件<br>有状态:维持内部状态</strong></p>
<p>数据接入与输出<br>转换操作<br>滚动聚合(例如求和 最小值 最大值)<br>窗口操作(“桶”的有限事件集合):滚动窗口 滑动窗口 会话窗口</p>
<h1 id="3-时间语义"><a href="#3-时间语义" class="headerlink" title="3.时间语义"></a>3.时间语义</h1><p><strong>处理时间:当前流处理算子所在机子的本地时钟时间<br>事件时间:数据流实际发生时间(将处理速度和内容结果彻底解耦)</strong></p>
<p>问题:如何处理延迟事件</p>
<p><strong>水位线:一个全局进度指标,表示我们确信不会再有延迟事件到来的某个时间点</strong></p>
<p>虽然处理时间提供了很低的延迟,但是结果依赖于处理速度,具有不确定性<br>事件时间能保证结果的准确性.并且允许处理延迟甚至无序的事件</p>
<h1 id="4-状态与一致性模型"><a href="#4-状态与一致性模型" class="headerlink" title="4.状态与一致性模型"></a>4.状态与一致性模型</h1><p>传统的处理无限数据的通常方法:将到来的事件分成小批次,不停地在批处理系统上调度并运行作业,其结果都会写入持久化储存中,同时所有算子的状态都将不复存在</p>
<h3 id="流式算子处理面临的挑战"><a href="#流式算子处理面临的挑战" class="headerlink" title="流式算子处理面临的挑战:"></a>流式算子处理面临的挑战:</h3><p>状态管理<br>状态划分<br>状态恢复</p>
<h3 id="任务故障"><a href="#任务故障" class="headerlink" title="任务故障"></a>任务故障</h3><p>任务的执行步骤<br>接收事件并将它们缓存在本地缓冲区<br>选择性地更新内部状态<br>产生输出记录</p>
<h3 id="结果保障"><a href="#结果保障" class="headerlink" title="结果保障"></a>结果保障</h3><ol>
<li><p>关注:流处理引擎内部状态的一致性</p>
</li>
<li><p>至多一次:每个事件至多被处理一次</p>
</li>
<li><p>至少一次:不丢事件<br>持久化事件日志将所有事件写入永久存储,这样任务故障时就可以重放它们<br>记录确认,将所有事件存在缓冲区中,直到处理管道中的所有任务都确认某个事件已经处理完毕才会将时间内丢弃</p>
</li>
<li><p>精确一次:不但没有事件丢失,而且每个事件对于内部状态的更新都只有一个</p>
</li>
<li><p>端到端的精确一次:整个数据处理管道上的结果都是正确的,可以通过弱保障来实现强语义</p>
</li>
</ol>
]]></content>
      <categories>
        <category>The Hadoop Ecosystem</category>
        <category>Learning Flink</category>
      </categories>
      <tags>
        <tag>Reading Books</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式</title>
    <url>/2020/12/02/Java-DesignMode/</url>
    <content><![CDATA[<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><h5 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h5><p>不要存在多于一个导致类变更的原因</p>
<h5 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h5><p>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上</p>
<h5 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h5><p>抽象不应该依赖于细节，细节应当依赖于抽象</p>
<h5 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h5><p>所有引用基类（父类）的地方必须能透明地使用其子类的对象</p>
<h5 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h5><p>一个软件实体应当对扩展开放，对修改关闭</p>
<h5 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h5><p>一个软件实体应当尽可能少地与其他实体发生相互作用</p>
<h5 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h5><p>要尽量使用合成和聚合，尽量不要使用继承</p>
<h3 id="类图六大关系"><a href="#类图六大关系" class="headerlink" title="类图六大关系"></a>类图六大关系</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">-- dependency(依赖关系)</span><br><span class="line">用到了其他类,表现为局部变量</span><br><span class="line">-- association(关联关系)</span><br><span class="line">表现与全局变量</span><br><span class="line">导航性多重性(一对一 一对多 多对一)</span><br><span class="line">是依赖关系的特例</span><br><span class="line">-- generalization(泛化关系)</span><br><span class="line">-- implementation(实现关系)</span><br><span class="line">-- aggregation(聚合关系) 整体和部分可以分开,是关联关系的特例</span><br><span class="line">-- composite(组合关系)(合成) 整体和部分不可分割,是关联关系的特例</span><br></pre></td></tr></table></figure>



<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例类的职责过重，在一定程度上违背了“单一职责原则<br>不适用于变化的对象,如果同一类型的对象总是要在不同的用例场景发生变化,单例就会引起数据的错误,不能保存彼此的状态<br>单利模式中没有抽象层，因此单例类的扩展有很大的困难。</p>
<p>双重检验:第一次加载时反应不快，由于java内存模型一些原因偶尔失败<br>一般采用饿汉式，若对资源十分在意可以采用静态内部类，不建议采用懒汉式及双重检测</p>
<p>单例模式的经典使用场景：</p>
<ol>
<li><p>资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。</p>
</li>
<li><p>控制资源的情况下，方便资源之间的互相通信。如线程池等。</p>
</li>
</ol>
<h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><p>饿汉式(静态常量):在类加载的时候就完成实例化,没有达到懒加载的效果,如果自始至终没有用到这个实例,则会造成内存的浪费<br>饿汉单例模式一定要加final？<br>防止反射</p>
<p>必须加static,不能new</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加final防止反射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span>  Singleson INSTANCE = <span class="keyword">new</span> Singleson();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleson <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleson INSTANCE ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleson();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleson <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><p>//final关键字:其初始化可以在两个地方，一是其定义处，也就是说在final变量定义时直接给其赋值，二是在构造函数中。这两个地方只能选其一，要么在定义时给值，要么在构造函数中给值，不能同时既在定义时给了值</p>
<p>(线程不安全)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleson INSTANCE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleson <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleson();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(线程安全效率低)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleson INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleson <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleson();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(错误的写法,多线程时,另一个线程已经进入了if-null的判断了,一个线程执行完,另一个线程也要再一次地创建对象把锁加载if那同加载方法那效果一直)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleson INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleson <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleson.class) &#123;</span><br><span class="line">                INSTANCE = <span class="keyword">new</span> Singleson();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="双重检验"><a href="#双重检验" class="headerlink" title="双重检验"></a>双重检验</h5><p>(懒加载)</p>
<p>(volatile关键字的作用防止指令重排)<br>(解释双重检验:多线程的情形下,两个线程都进入到第一个if判断中了,一个线程进入到锁中,然后创建完对象,释放锁,另一个线程进入到第二个判断,但是已经new了一个对象了,所以不为null 直接出去,对于性能,因为对象已经存在所以第一个判断if都不会进入,并不会影响性能)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleson INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleson <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleson.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleson();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>特性:内部静态类不会自动初始化，只有调用静态内部类的方法，静态域，或者构造方法的时候才会加载静态内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglesonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleson INSTANCE = <span class="keyword">new</span> Singleson();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleson <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SinglesonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleson instance = Singleson.INSTANCE;</span><br><span class="line">        Singleson instance1 = Singleson.INSTANCE;</span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(instance1.hashCode());</span><br><span class="line">        instance.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleson</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Product a = Factory.newProduct(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        Product b = Factory.newProduct(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.show();</span><br><span class="line">            b.show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A产品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B产品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Product <span class="title">newProduct</span><span class="params">(String product)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (product) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;没有该产品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产</p>
<p>品，简单工厂模式实现了对象创建和使用的分离。</p>
<p>会导致系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和</p>
<p>维护，且违背开闭原则</p>
<p>适用的场合:工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂</p>
<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory jFactory = <span class="keyword">new</span> JFactory();</span><br><span class="line">        jFactory.operation();</span><br><span class="line">        Factory xFactory = <span class="keyword">new</span> XFactory();</span><br><span class="line">        xFactory.operation();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Factory</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span>  <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">JFactory</span> <span class="keyword">implements</span>  <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">XFactory</span> <span class="keyword">implements</span>  <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CFactory</span> <span class="keyword">implements</span>  <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类</p>
<p>工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，违背了“开放 - 关闭原则,工厂方法新增一种产品时，只需要增加相应的具体产品</p>
<p>类和相应的工厂子类即可,</p>
<p>工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了</p>
<p>多态性的体现</p>
<p>每次我们为工厂方法添加新的产品时就要编写一个新的产品类，同时还要引入抽象层，当产品种类非常多时，会出现大量的与之对应的工</p>
<p>厂对象，这必然会导致类结构的复杂化</p>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        XMProductFactory xmProductFactory = <span class="keyword">new</span> XMProductFactory();</span><br><span class="line">        xmProductFactory.phoneProduct().open();</span><br><span class="line">        xmProductFactory.routerProduct().open();</span><br><span class="line">        PGProductFactory pgProductFactory = <span class="keyword">new</span> PGProductFactory();</span><br><span class="line">        pgProductFactory.phoneProduct().open();</span><br><span class="line">        pgProductFactory.routerProduct().open();</span><br><span class="line">        <span class="comment">//如果往产品中添加功能要修改代码复杂,如果要,如果要添加产品则要修改工厂方法复杂不适用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PouterProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小米和苹果实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XMPhoneProduct</span> <span class="keyword">implements</span> <span class="title">PhoneProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开小米手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭小米手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PGPhoneProduct</span> <span class="keyword">implements</span> <span class="title">PhoneProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开苹果手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭苹果手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XMPouterProduct</span> <span class="keyword">implements</span> <span class="title">PouterProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开小米路由器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭小米路由器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PGPouterProduct</span> <span class="keyword">implements</span> <span class="title">PouterProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开苹果路由器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开苹果路由器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生产手机</span></span><br><span class="line">    <span class="function">PhoneProduct <span class="title">phoneProduct</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成路由器</span></span><br><span class="line">    <span class="function">PouterProduct <span class="title">routerProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小米工厂和苹果工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XMProductFactory</span> <span class="keyword">implements</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PhoneProduct <span class="title">phoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMPhoneProduct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PouterProduct <span class="title">routerProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMPouterProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PGProductFactory</span> <span class="keyword">implements</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PhoneProduct <span class="title">phoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PGPhoneProduct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PouterProduct <span class="title">routerProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PGPouterProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 抽象工厂模式是所有工厂模式的一般形式,当抽象工厂模式退化到只有一个产品登级结构时,就变成了工厂方法模式。当工厂方法模式的工</p>
<p>厂类只有一个时,且工厂方法为静态方法时,则又变成了简单工厂模式。与工厂方法模式相似,抽象工厂模式隔离了具体类的生成,让客户端不</p>
<p>清楚具体什么样的对象被创建</p>
<p>但是产品族扩展非常困难，要增加一个系列的某一产品，既要修改工厂抽象类里加代码，又修改具体的实现类里面加代码</p>
<p>增加了系统的抽象性和理解难度</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>浅拷贝和深拷贝</p>
]]></content>
      <categories>
        <category>Programming Language</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Summary of knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda 架构</title>
    <url>/2020/09/29/Lambda-System-Construction/</url>
    <content><![CDATA[<h2 id="一-新范式"><a href="#一-新范式" class="headerlink" title="(一).新范式"></a>(一).新范式</h2><h3 id="传统数据库的不足"><a href="#传统数据库的不足" class="headerlink" title="传统数据库的不足"></a>传统数据库的不足</h3><ul>
<li><p>数据库更不上负载:解决方法-用队列扩展</p>
</li>
<li><p>数据库再次超载:解决方法-通过数据库进行分片扩展</p>
</li>
<li><p>处理容错问题</p>
</li>
<li><p>损坏问题</p>
<p><strong>系统必须是可以容忍人为错误的</strong></p>
</li>
</ul>
<h3 id="大数据系统应有的属性"><a href="#大数据系统应有的属性" class="headerlink" title="大数据系统应有的属性"></a>大数据系统应有的属性</h3><ul>
<li><p>鲁棒性和容错性</p>
</li>
<li><p>低延迟读取和更新</p>
</li>
<li><p>可扩展性</p>
</li>
<li><p>通用性</p>
</li>
<li><p>延展性(目标实现大规模迁移)</p>
</li>
<li><p>及席查询</p>
</li>
<li><p>最少维护</p>
</li>
<li><p>可调式性</p>
</li>
</ul>
<h3 id="Lambda架构模型"><a href="#Lambda架构模型" class="headerlink" title="Lambda架构模型"></a>Lambda架构模型</h3><h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p><strong>数据系统不只是记录和重现信息 你掌握的信息是真实的,只是因为它存在<br>数据系统的通用表达式:</strong><br><strong>query = function(all data)</strong></p>
<h5 id="Lambda架构总体的函数"><a href="#Lambda架构总体的函数" class="headerlink" title="Lambda架构总体的函数"></a>Lambda架构总体的函数</h5><p><strong>系统抽象函数:</strong></p>
<p><strong>batch view = function (all data)</strong><br><strong>realtime view = function (realtime view(实时视图) ,new data)</strong><br><strong>query = function (batch view ,realtime view )</strong></p>
<h5 id="Lambda架构模型的说明"><a href="#Lambda架构模型的说明" class="headerlink" title="Lambda架构模型的说明"></a>Lambda架构模型的说明</h5><ul>
<li>批处理层:先查询预先计算查询函数(批处理视图)</li>
<li>速度层:速度层只查看最近的数据,而批处理层要立即查看所有数据,速度层做增量查询.而不是像批处理层那样重写计算</li>
<li>服务层:一个专门的分布式数据库,用于加载批处理视图,并且可以对它进行随机读取</li>
</ul>
<h5 id="示例应用-SuperWebAnalytics-com"><a href="#示例应用-SuperWebAnalytics-com" class="headerlink" title="示例应用:SuperWebAnalytics.com"></a>示例应用:SuperWebAnalytics.com</h5><h2 id="二-批处理层"><a href="#二-批处理层" class="headerlink" title="(二).批处理层"></a>(二).批处理层</h2><h3 id="数据的属性"><a href="#数据的属性" class="headerlink" title="数据的属性"></a>数据的属性</h3><h5 id="数据是原始的"><a href="#数据是原始的" class="headerlink" title="数据是原始的"></a>数据是原始的</h5><ul>
<li>非结构化的数据比规范化的数据更原始,更多的信息并不意味更原始的数据</li>
</ul>
<h5 id="数据是不可变的"><a href="#数据是不可变的" class="headerlink" title="数据是不可变的"></a>数据是不可变的</h5><ul>
<li>容忍人为错误是数据系统的基本属性,对于可变的数据模型,一个错误会导致数据的丢失.在数据库中值会被覆盖掉;而对于不可变的数据模式,如果人为的写入了坏数据,更早一些的数据单元仍然存在.修复数据系统知识删除损坏的数据单元</li>
<li>可变数据模式数据必须以某种方式被索引,相反,不可变数据模式不需要,这是巨大的简化</li>
</ul>
<h5 id="数据是永远真实的"><a href="#数据是永远真实的" class="headerlink" title="数据是永远真实的"></a>数据是永远真实的</h5><ul>
<li>删除数据不是对数据真实性的声明,相反,它是对数据价值的声明</li>
</ul>
<h3 id="基于事实的数据表示模型"><a href="#基于事实的数据表示模型" class="headerlink" title="基于事实的数据表示模型"></a>基于事实的数据表示模型</h3><h5 id="事实模型的特点"><a href="#事实模型的特点" class="headerlink" title="事实模型的特点"></a>事实模型的特点</h5><ul>
<li>将原始数据储存为原子事实-原子性(不能再细化成有意义的组件)</li>
<li>通过时间戳保证事实的不变性和永远正确性</li>
<li>确保每个事实是可区分的,这样查询过程可以区分重复</li>
</ul>
<h5 id="基于事实的模型的优势"><a href="#基于事实的模型的优势" class="headerlink" title="基于事实的模型的优势"></a>基于事实的模型的优势</h5><ul>
<li><p>任何时刻的历史消息都是可查询的</p>
</li>
<li><p>容忍人为错误(删除事实)</p>
</li>
<li><p>只需要处理部分信息</p>
</li>
<li><p>拥有规范和非规范形式的优点</p>
<p><strong>规范化-以结构化的方式存储数据-查询效率</strong></p>
<p><strong>非规范化-保证数据一致性</strong></p>
</li>
</ul>
<h3 id="批处理层的数据存储"><a href="#批处理层的数据存储" class="headerlink" title="批处理层的数据存储"></a>批处理层的数据存储</h3><h5 id="主数据集的存储需求"><a href="#主数据集的存储需求" class="headerlink" title="主数据集的存储需求"></a>主数据集的存储需求</h5><ul>
<li>写:<ul>
<li>高效追加数据:简单高效</li>
<li>可扩展的存储:TB或PB级别的数据,必须很容易扩展存储</li>
</ul>
</li>
<li>读:<ul>
<li>支持并行处理</li>
</ul>
</li>
<li>读写:<ul>
<li>可调优存储和处理成本</li>
<li>强制不变性</li>
</ul>
</li>
</ul>
<h5 id="分布式文件系统的存储需求"><a href="#分布式文件系统的存储需求" class="headerlink" title="分布式文件系统的存储需求"></a>分布式文件系统的存储需求</h5><p>主要矛盾:处理成本和存储成本</p>
<p>解决方案:分布式文件系统</p>
<h5 id="垂直分区-这种存储标准适用全架构的哪一部分的数据集"><a href="#垂直分区-这种存储标准适用全架构的哪一部分的数据集" class="headerlink" title="垂直分区(这种存储标准适用全架构的哪一部分的数据集)"></a>垂直分区(这种存储标准适用全架构的哪一部分的数据集)</h5><p>次要矛盾:查询效率和存储成本</p>
<p>解决什么问题:提高批处理查询效率</p>
<p>怎么实现:例如静态分区,动态分区</p>
<h3 id="批处理层"><a href="#批处理层" class="headerlink" title="批处理层"></a>批处理层</h3><h5 id="视图的标准"><a href="#视图的标准" class="headerlink" title="视图的标准"></a>视图的标准</h5><ul>
<li>批处理层上计算的一个简单策略;预先计算所以可能的查询,并将结果缓存在服务层中,但这种预先计算不能穷尽所有业务的可能性,对于给定的查询业务,要预先计算的是每一个单元</li>
</ul>
<h5 id="重新计算算法"><a href="#重新计算算法" class="headerlink" title="重新计算算法"></a>重新计算算法</h5><ol>
<li>性能:需要处理整个数据集的计算工作量</li>
<li>容忍人的错误:批处理视图不断被重建</li>
<li>通用性:在预先处理阶段解决了算法的复杂性,由此生成了简单的批处理视图和低延迟动态处理</li>
<li>总结:对于支持鲁棒性的数据处理系统是必不可少的</li>
</ol>
<h5 id="增量算法-适用什么场合或者要满足什么要求"><a href="#增量算法-适用什么场合或者要满足什么要求" class="headerlink" title="增量算法(适用什么场合或者要满足什么要求)"></a>增量算法(适用什么场合或者要满足什么要求)</h5><ol>
<li><p>性能:需要更少的计算资源但可能产生大得多的批处理视图</p>
</li>
<li><p>容忍人的错误:不容易修复批处理视图中的错误,修复是暂时的,可能要估算</p>
</li>
<li><p>通用性:需要特殊定制.可能将复杂性转移到动态查询的处理中</p>
</li>
<li><p>总结:提高系统效率,但只是重新计算算法的补充</p>
</li>
</ol>
<h5 id="一种大数据计算的范式-MapReduce"><a href="#一种大数据计算的范式-MapReduce" class="headerlink" title="一种大数据计算的范式:MapReduce"></a>一种大数据计算的范式:MapReduce</h5><ul>
<li>优:可扩展性 容错性 通用性</li>
<li>缺:多步计算 join连接要手动 逻辑和物理执行耦合</li>
</ul>
<h5 id="一种关于批处理计算的高级思维方式-管道图"><a href="#一种关于批处理计算的高级思维方式-管道图" class="headerlink" title="一种关于批处理计算的高级思维方式:管道图"></a>一种关于批处理计算的高级思维方式:管道图</h5><h3 id="批处理层示例与实现-业务处理"><a href="#批处理层示例与实现-业务处理" class="headerlink" title="批处理层示例与实现(业务处理)"></a>批处理层示例与实现(业务处理)</h3><h5 id="URL规范化"><a href="#URL规范化" class="headerlink" title="URL规范化"></a>URL规范化</h5><h5 id="用户标识符规范化-迭代图算法"><a href="#用户标识符规范化-迭代图算法" class="headerlink" title="用户标识符规范化(迭代图算法)"></a>用户标识符规范化(迭代图算法)</h5><ul>
<li>等效边的处理</li>
</ul>
<h5 id="页面浏览去重"><a href="#页面浏览去重" class="headerlink" title="页面浏览去重"></a>页面浏览去重</h5><p>改日再写…………</p>
<h2 id="三-服务层"><a href="#三-服务层" class="headerlink" title="(三).服务层"></a>(三).服务层</h2><h3 id="服务层概述"><a href="#服务层概述" class="headerlink" title="服务层概述"></a>服务层概述</h3><h5 id="服务层的性能指标"><a href="#服务层的性能指标" class="headerlink" title="服务层的性能指标"></a>服务层的性能指标</h5><p>起源:</p>
<ul>
<li>层的索引以完全分布式的方式被创建、加载和 服务</li>
</ul>
<p>指标:</p>
<ul>
<li>延迟:响应单个查询所需 的时间</li>
<li>吞吐量:给定时间内可以服务的查询数量</li>
</ul>
<p>性能的优化:</p>
<ul>
<li>的索引促进扫描并限制磁盘寻道,从而改善了延迟和吞吐量</li>
</ul>
<h5 id="一致性问题的描述"><a href="#一致性问题的描述" class="headerlink" title="一致性问题的描述"></a>一致性问题的描述</h5><p>解决方案:lambda架构中主数据集和服务层之间是分离的,解决”一个字段的不同副本数据不一致问题”等,重新开始计算服务层</p>
<h5 id="服务层数据库的需求"><a href="#服务层数据库的需求" class="headerlink" title="服务层数据库的需求"></a>服务层数据库的需求</h5><ul>
<li><p>写-服务层所用的批处理视图是从头开始产生的,当视图的一个新的版本可以用时,旧版本的视图必须能够完全用新的视图替换</p>
</li>
<li><p>展性-服务层数据库必须能够处理任意大小的视图</p>
</li>
<li><p>读取-尤对小部分视图的随机读取</p>
</li>
<li><p>性-分布式架构必须要容忍机器的故障</p>
</li>
</ul>
<h5 id="设计SuperWebAnalytics-com的服务层"><a href="#设计SuperWebAnalytics-com的服务层" class="headerlink" title="设计SuperWebAnalytics.com的服务层"></a>设计SuperWebAnalytics.com的服务层</h5><p>ElephantDB数据库</p>
<h5 id="LAMBDA架构服务层的基本概念"><a href="#LAMBDA架构服务层的基本概念" class="headerlink" title="LAMBDA架构服务层的基本概念"></a>LAMBDA架构服务层的基本概念</h5><ul>
<li><p>视图来优化延迟和吞吐量的能力</p>
</li>
<li><p>持随机写的简单形式</p>
</li>
<li><p>处理层储存规范化数据并在服务层储存非规范化数据的能力</p>
</li>
<li><p>层固有的容错和纠错性.因为可以从主数据集重新计算</p>
</li>
</ul>
<h2 id="四-速度层"><a href="#四-速度层" class="headerlink" title="(四).速度层"></a>(四).速度层</h2><h3 id="实时视图"><a href="#实时视图" class="headerlink" title="实时视图"></a>实时视图</h3><h5 id="存储实时视图"><a href="#存储实时视图" class="headerlink" title="存储实时视图"></a>存储实时视图</h5><ul>
<li>随机读:实时视图应该支持快速回应查询,这意味着它所包含的数据必须被索引</li>
<li>随机写:为了支持增量算法,必须低延迟地修改实时视图</li>
<li>可扩展性</li>
<li>容错性</li>
</ul>
<h5 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h5><ul>
<li>所有的数据最终都将表示在批处理层和服务层视图中,任何在速度层得到的近似值会被不断修正,这意味着任何近似值知识暂时的,即查询最终展示了准确性</li>
</ul>
<h5 id="增量算法的挑战"><a href="#增量算法的挑战" class="headerlink" title="增量算法的挑战"></a>增量算法的挑战</h5><ul>
<li><p><strong>CAP定理的正确表述:当分布式数据系统被分区时,它可以是一致性的或者可用性的,但不能两者兼而有之.也就是说,如果选择了一致性,那么查询就会收到错误结果而不是正确答案:如果选择可用性,那么在网络分区间,读操作可能返回过时的数据,在高可用性系统中,最好的一致性属性是最终一致性</strong></p>
</li>
<li><p><strong>CAP定理</strong></p>
</li>
</ul>
<h3 id="队列和流"><a href="#队列和流" class="headerlink" title="队列和流"></a>队列和流</h3><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><ul>
<li><p>单消费者队列</p>
<ul>
<li><strong>设计思想:从队列中读取一个事件时,该事件不会立即被删除,相反,get方法返回的记录包括一个标识符,稍后用它来确认处理事件成功还是失败.只有一个事件被确认成功删除,它才会被从队列中删除,如果事件处理失败或者超时,队列服务器将允许另一个服务器通过一个单独的get方法调用相同的事件.因此使用该方法,一个事件可能被处理多次,但是每个事件至少被处理一次是毋庸置疑的</strong></li>
<li><strong>缺陷:消除了独立应用程序之间的任何隔离性</strong></li>
<li><strong>完善:为每个消费者应用程序维护一个单独的队列,但是这种方法的实现大大增加服务器上的负载</strong></li>
<li><strong>启发:队列系统所需的属性</strong></li>
</ul>
</li>
<li><p>多消费者队列</p>
<ul>
<li>Apache Kafka</li>
</ul>
</li>
</ul>
<h5 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h5><ul>
<li><p>storm</p>
</li>
<li><p>spark</p>
</li>
<li><p>flink</p>
</li>
</ul>
<h3 id="微批量处理"><a href="#微批量处理" class="headerlink" title="微批量处理"></a>微批量处理</h3><h5 id="实现有且仅有一次的语义"><a href="#实现有且仅有一次的语义" class="headerlink" title="实现有且仅有一次的语义"></a>实现有且仅有一次的语义</h5><h5 id="微批量流处理"><a href="#微批量流处理" class="headerlink" title="微批量流处理"></a>微批量流处理</h5><p>每个批次被有序处理,并且每个批次都有唯一的ID,该ID每次回放总是一样的</p>
<h5 id="微批量流处理的核心概念"><a href="#微批量流处理的核心概念" class="headerlink" title="微批量流处理的核心概念"></a>微批量流处理的核心概念</h5><ul>
<li>本地批量计算</li>
<li>有状态的计算</li>
</ul>
<h2 id="五-深入lambda架构"><a href="#五-深入lambda架构" class="headerlink" title="(五).深入lambda架构"></a>(五).深入lambda架构</h2><h3 id="定义数据系统"><a href="#定义数据系统" class="headerlink" title="定义数据系统"></a>定义数据系统</h3><p><strong>查询要关注的属性</strong></p>
<ul>
<li><p>延迟:运行一个查询的书剑</p>
</li>
<li><p>时效性:最新的查询如何</p>
</li>
<li><p>准确性:在许多情况下,为了使查询更具有较好的性能和可扩展性,必须在查询的实现中采用近似值</p>
</li>
</ul>
<p><strong>延迟性和及时性的描述</strong></p>
<ul>
<li><p>CAP定理表明:在网络分区的情况下,一个系统要么是一致性(查询考虑到所有以前写入的数据),要么是可用的(目前查询可以被回应)</p>
</li>
<li><p>一致性只是及时性的一种形式,可用性只意味查询的延迟是有界的.最终一致性的系统选择延迟而不是及时性(查询总是被回应,但可能不会考虑所有先前失败的情况下的数据)</p>
</li>
</ul>
<p><strong>数据系统的基本模型</strong></p>
<p>为什么如此以及怎样:允许人为错误 易变性   唯一的办法是让核心数据保持不变</p>
<ul>
<li><p>包含不断增长 的数据集合的主数据集</p>
</li>
<li><p>作为函数的查询将整个主数据集作为输入</p>
</li>
</ul>
<h3 id="批处理层和服务层"><a href="#批处理层和服务层" class="headerlink" title="批处理层和服务层"></a>批处理层和服务层</h3><p><strong>增量的批处理</strong></p>
<p>局限性:原始数据可能是混乱的</p>
<p>解决的方案:<strong>部分重新计算</strong>:</p>
<ul>
<li>部分重新计算花费时间比基于完全重新计算的方法快</li>
<li>给予一定的能力来纠正人为错误</li>
</ul>
<h3 id="速度层"><a href="#速度层" class="headerlink" title="速度层"></a>速度层</h3><p>设计的主旨:倾向于性能使用增量算法而不是重新计算方法</p>
<h3 id="查询层"><a href="#查询层" class="headerlink" title="查询层"></a>查询层</h3><p>目的:负责利用批处理层和实时视图来响应查询</p>
<h2 id="六-重要的问题"><a href="#六-重要的问题" class="headerlink" title="(六)重要的问题"></a>(六)重要的问题</h2><p>1.等效边怎么处理(用户标识符规范化)</p>
<p>2.垂直分区:假设按照星期来分区?但是我要查询男女???或者其他的需求,我要访问多余的数据,</p>
<p>3.怎么理解批处理层的数据规划化?是否有索引</p>
<p>4.假设多个人同时修改处理一块数据,怎么保证正确性,如果加锁,影响性能怎么解决?</p>
<p>5.hbase是怎么删除数据的?打标签,怎么打?</p>
<p>6.hdfs上的数据怎么实现修改的???</p>
<p>7.hbase是按照rowkey来存储的,我的问题是我要查询最近两个星期的数据,hbase的存储方式是不满足我的要求的,问题是,我怎么间接地访问到两个星期的数据???—-查了一下hbase能查,这不是浪费资源吗</p>
<p>8.hdfs的重名问题</p>
<p>9.视图和展示数据以及最终的查询结果之间的标准是什么,换句话说怎么理解视图9</p>
<p>10.批处理层 服务层 速度层 各自处理什么样的数据,生成什么样的数据,之间是如何沟通的,它们的界限???</p>
<p>11.主数据集是如何更新数据的???</p>
]]></content>
      <categories>
        <category>The Hadoop Ecosystem</category>
      </categories>
      <tags>
        <tag>Reading Books</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统摘要</title>
    <url>/2020/05/12/Operating-System/</url>
    <content><![CDATA[<h2 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h2><h4 id="1-什么是操作系统"><a href="#1-什么是操作系统" class="headerlink" title="1.什么是操作系统"></a>1.什么是操作系统</h4><ul>
<li><p>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石</p>
</li>
<li><p>操作系统屏蔽了软件层的复杂性</p>
</li>
<li><p>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理,内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性</p>
</li>
</ul>
<h4 id="2-系统调用"><a href="#2-系统调用" class="headerlink" title="2.系统调用"></a>2.系统调用</h4><h6 id="根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别："><a href="#根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：" class="headerlink" title="根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别："></a>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</h6><ol>
<li>用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。</li>
<li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<h6 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h6><ul>
<li>我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</li>
</ul>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h4 id="线程间的同步的方式有哪些呢"><a href="#线程间的同步的方式有哪些呢" class="headerlink" title="线程间的同步的方式有哪些呢?"></a>线程间的同步的方式有哪些呢?</h4><ol>
<li><p><strong>互斥量</strong>(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</p>
</li>
<li><p><strong>信号量</strong>(Semphares) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</p>
</li>
<li><p><strong>事件</strong>(Event) :Wait/Notify通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>
</li>
</ol>
<h4 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h4><h4 id="操作系统中进程的调度算法"><a href="#操作系统中进程的调度算法" class="headerlink" title="操作系统中进程的调度算法"></a>操作系统中进程的调度算法</h4><ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h2 id="操作系统内存管理系统"><a href="#操作系统内存管理系统" class="headerlink" title="操作系统内存管理系统"></a>操作系统内存管理系统</h2><h4 id="CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="CPU 寻址了解吗?为什么需要虚拟地址空间?"></a>CPU 寻址了解吗?为什么需要虚拟地址空间?</h4><ul>
<li>现代处理器使用的是一种称为 虚拟寻址(Virtual Addressing)*的寻址方式。使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 内存管理单元</li>
<li>如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难</li>
</ul>
<h4 id="缓存-内存-虚拟内存"><a href="#缓存-内存-虚拟内存" class="headerlink" title="缓存 内存 虚拟内存"></a>缓存 内存 虚拟内存</h4><ul>
<li> 缓存是为了解决CPU速度和内存速度的速度差异问题 内存中被CPU访问最频繁的数据和指令被复制入CPU中的缓存</li>
<li> 虚拟内存是WINDOWS操作系统用来管理内存的一种方法 虚拟内存说穿了就是把内存中的信息分出去一部分存在硬盘上 这样从表面上看就扩大了内存容量</li>
<li> 缓存是一种硬件，是CPU的一部分；而虚拟内存并不是一种硬件，而是存在于硬盘上的一个文件，是根据WINDOWS的要求生成的（二者中的信息都是随时变化的） </li>
<li> 缓存的目的是加快系统的速度，而虚拟内存技术是为了使更多的程序能够在有限的内存中运行</li>
</ul>
<p>未完成</p>
]]></content>
      <categories>
        <category>Computer engineering</category>
      </categories>
      <tags>
        <tag>Reading Books</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala容器操作</title>
    <url>/2020/08/26/Scala-ContainerOperation/</url>
    <content><![CDATA[<h1 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h1><h2 id="必要的知识"><a href="#必要的知识" class="headerlink" title="必要的知识"></a>必要的知识</h2><p><strong>函数的类型与类型推断</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//1.反思为什么可以这样写</span></span><br><span class="line">   <span class="keyword">val</span> f : (<span class="type">Int</span>,<span class="type">Double</span>)=&gt;<span class="type">Double</span> =(x:<span class="type">Int</span>,y:<span class="type">Double</span>)=&gt;x+y</span><br><span class="line">   <span class="comment">//2.实际上发生了什么:省略了Function2,一共有22个</span></span><br><span class="line">   <span class="keyword">val</span> f1 :<span class="type">Function2</span>[<span class="type">Int</span>,<span class="type">Double</span>,<span class="type">Double</span>]=(x:<span class="type">Int</span>,y:<span class="type">Double</span>)=&gt;x+y</span><br><span class="line">   <span class="comment">//3.进一步思考为什么能这样写:实际上(x:Int,y:Double)=&gt;x+y 是调用了apply方法 new了一个特质,调用函数实际上是调用了apply方法</span></span><br><span class="line">   <span class="keyword">val</span> f2 :<span class="type">Function2</span>[<span class="type">Int</span>,<span class="type">Double</span>,<span class="type">Double</span>]=<span class="keyword">new</span> <span class="type">Function2</span>[<span class="type">Int</span>,<span class="type">Double</span>,<span class="type">Double</span>] &#123;</span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(v1: <span class="type">Int</span>, v2: <span class="type">Double</span>): <span class="type">Double</span> =  v1+v2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4.我们可以进一步的简化</span></span><br><span class="line">   <span class="keyword">val</span> f4 =(x:<span class="type">Int</span>,y:<span class="type">Double</span>)=&gt;x+y</span><br><span class="line">   <span class="comment">//5.怎么表示元组</span></span><br><span class="line">   <span class="keyword">val</span> tuple :<span class="type">Function2</span>[<span class="type">Int</span>,<span class="type">Double</span>,<span class="type">Tuple2</span>[<span class="type">Double</span>,<span class="type">Int</span>]]=<span class="keyword">new</span> <span class="type">Function2</span>[<span class="type">Int</span>,<span class="type">Double</span>,<span class="type">Tuple2</span>[<span class="type">Double</span>,<span class="type">Int</span>]] &#123;</span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(v1: <span class="type">Int</span>, v2: <span class="type">Double</span>): (<span class="type">Double</span>, <span class="type">Int</span>) = (v2,v1)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//定长数组的初始化</span></span><br><span class="line">    <span class="keyword">val</span> ints = <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">10</span>)</span><br><span class="line">    println(ints.mkString(<span class="string">&quot;,&quot;</span>))<span class="comment">//10</span></span><br><span class="line">    <span class="keyword">val</span> ints1 = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">10</span>)</span><br><span class="line">    println(ints1.mkString(<span class="string">&quot;,&quot;</span>))<span class="comment">//0,0,0,0,0,0,0,0,0,0</span></span><br><span class="line">    <span class="comment">//使用()来访问数组的元素</span></span><br><span class="line">    <span class="comment">//变长数组(缓冲数组)</span></span><br><span class="line">    <span class="keyword">val</span> value = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line">    <span class="comment">//增操作1</span></span><br><span class="line">    <span class="comment">//在末端添加</span></span><br><span class="line">    println(value.hashCode())</span><br><span class="line">    println(<span class="type">System</span>.identityHashCode(value))</span><br><span class="line">    value += <span class="number">1</span></span><br><span class="line">    <span class="comment">//比较var val 地址值是否发生了变化</span></span><br><span class="line">    println(value.hashCode())</span><br><span class="line">    println(<span class="type">System</span>.identityHashCode(value))</span><br><span class="line">    <span class="comment">//增操作2</span></span><br><span class="line">    value += (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    value ++= <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">6</span>)</span><br><span class="line">    value.appendAll( <span class="type">ArrayBuffer</span>[<span class="type">Int</span>](<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">    println(value)</span><br><span class="line">    <span class="comment">//删操作</span></span><br><span class="line">    value.remove(<span class="number">0</span>)<span class="comment">//索引</span></span><br><span class="line">    value.remove(<span class="number">0</span>,<span class="number">2</span>)<span class="comment">//从索引0处删除2个元素</span></span><br><span class="line">    value.trimEnd(<span class="number">3</span>)<span class="comment">//删除后三个元素</span></span><br><span class="line">    <span class="comment">//改操作</span></span><br><span class="line">    value(<span class="number">0</span>) = <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="keyword">val</span> array = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">array(<span class="number">0</span>)(<span class="number">0</span>) =<span class="number">4</span></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (index &lt;- array)&#123;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- index)&#123;</span><br><span class="line">        println(i+<span class="string">&quot;\t&quot;</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//Trait Iterable</span></span><br><span class="line">    <span class="keyword">val</span> value = <span class="type">List</span>[<span class="type">String</span>](<span class="string">&quot;hbase&quot;</span>, <span class="string">&quot;hive&quot;</span>, <span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;clickhouse&quot;</span>, <span class="string">&quot;kylin&quot;</span>)</span><br><span class="line">    <span class="comment">//xs.iterator返回一个迭代器</span></span><br><span class="line">    value.iterator.reduce(_+_).foreach(println)</span><br><span class="line">    <span class="comment">//返回一个固定大小的迭代器</span></span><br><span class="line">    value grouped <span class="number">2</span> foreach(println)</span><br><span class="line">    <span class="comment">//返回一个固定大小的滑动窗口</span></span><br><span class="line">    value sliding <span class="number">2</span> foreach(println)</span><br><span class="line">    <span class="comment">//返回最后N元素</span></span><br><span class="line">    value.takeRight(<span class="number">2</span>).foreach(println)</span><br><span class="line">    <span class="comment">//返回除了最后N个元素的元素</span></span><br><span class="line">    value.dropRight(<span class="number">2</span>).foreach(println)</span><br><span class="line">    <span class="comment">//zip操作</span></span><br><span class="line">    <span class="keyword">val</span> value1 = <span class="type">List</span>[<span class="type">String</span>](<span class="string">&quot;mapreduce&quot;</span>,<span class="string">&quot;spark&quot;</span>,<span class="string">&quot;strom&quot;</span>)</span><br><span class="line">    println(value.zip(value1))</span><br><span class="line">    <span class="comment">//返回元组对应其索引的集合</span></span><br><span class="line">    println(value1.zipWithIndex)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//列表常用方法</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//构建list</span></span><br><span class="line">    <span class="keyword">val</span> list1 = <span class="string">&quot;MapReduce&quot;</span> :: <span class="string">&quot;spark&quot;</span> :: <span class="string">&quot;strom&quot;</span> :: <span class="type">Nil</span></span><br><span class="line">    <span class="keyword">val</span> list2 = <span class="string">&quot;hive&quot;</span> :: list1 :: <span class="type">Nil</span></span><br><span class="line">    <span class="comment">//(::: 左右两边都要为集合)</span></span><br><span class="line">    <span class="keyword">val</span> list3 = <span class="string">&quot;flink&quot;</span> :: list1 ::: <span class="type">Nil</span></span><br><span class="line">    println(list1) <span class="comment">//List(MapReduce, spark, strom)</span></span><br><span class="line">    println(list2) <span class="comment">//List(hive, List(MapReduce, spark, strom))</span></span><br><span class="line">    println(list3) <span class="comment">//List(flink, MapReduce, spark, strom)</span></span><br><span class="line">    <span class="comment">//list的底层是链表,是不可变的如下操作</span></span><br><span class="line">    <span class="keyword">val</span> value = <span class="type">List</span>[<span class="type">Int</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">    <span class="comment">//1.判断是否为空</span></span><br><span class="line">    println(value.isEmpty)</span><br><span class="line">    <span class="comment">//2.取值操作</span></span><br><span class="line">    println(value.head) <span class="comment">//头一个</span></span><br><span class="line">    println(value.tail) <span class="comment">//除了第一个外所有元素</span></span><br><span class="line">    println(value.init) <span class="comment">//返回最后一个元素</span></span><br><span class="line">    println(value.last) <span class="comment">//返回最后一个元素之外的其他元素</span></span><br><span class="line">    println(value.tail.head) <span class="comment">//返回第二个元素</span></span><br><span class="line">    <span class="comment">//使用下标访问,反转操作,返回所有下标</span></span><br><span class="line">    println(value(<span class="number">0</span>))</span><br><span class="line">    println(value.reverse)</span><br><span class="line">    value.indices.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//列表</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> value = <span class="type">List</span>[<span class="type">Int</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">    println(value.take(<span class="number">3</span>)) <span class="comment">//获取前三个元素</span></span><br><span class="line">    println(value.drop(<span class="number">3</span>)) <span class="comment">//删除前三个元素</span></span><br><span class="line">    <span class="keyword">val</span> tuple: (<span class="type">List</span>[<span class="type">Int</span>], <span class="type">List</span>[<span class="type">Int</span>]) = value splitAt <span class="number">2</span> <span class="comment">//从第N个拆分</span></span><br><span class="line">    println(tuple)</span><br><span class="line">    <span class="comment">//扁平化操作</span></span><br><span class="line">    println(<span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>), <span class="type">List</span>(<span class="number">5</span>, <span class="number">6</span>)).flatten)</span><br><span class="line">    <span class="comment">//连接操作</span></span><br><span class="line">    <span class="keyword">val</span> x1 = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> x2 = <span class="type">List</span>(<span class="string">&quot;spark&quot;</span>, <span class="string">&quot;strom&quot;</span>, <span class="string">&quot;mapreduce&quot;</span>)</span><br><span class="line">    println(x1.zip(x2).unzip)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//列表转换</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="type">List</span>(<span class="type">List</span>(<span class="string">&quot;sprak&quot;</span>, <span class="string">&quot;strom&quot;</span>), <span class="type">List</span>(<span class="string">&quot;mapreduce&quot;</span>, <span class="string">&quot;hive&quot;</span>))</span><br><span class="line">    <span class="comment">//map操作,对list集合的每个元素的操作</span></span><br><span class="line">    <span class="keyword">val</span> value: <span class="type">List</span>[<span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]]] = list.map(data =&gt; data.map(data =&gt; data.split(<span class="string">&quot;,&quot;</span>).toList))</span><br><span class="line">    value.foreach(println) <span class="comment">//List(List(sprak), List(strom)) List(List(mapreduce), List(hive))</span></span><br><span class="line">    <span class="comment">//flatten扁平化,扁平一次</span></span><br><span class="line">    <span class="keyword">val</span> flatten: <span class="type">List</span>[<span class="type">List</span>[<span class="type">String</span>]] = value.flatten</span><br><span class="line">    <span class="keyword">val</span> flatten1: <span class="type">List</span>[<span class="type">String</span>] = flatten.flatten</span><br><span class="line">    println(flatten1) <span class="comment">//List(sprak, strom, mapreduce, hive)</span></span><br><span class="line">    <span class="comment">//flatmap,结合map和flatten的功能</span></span><br><span class="line">    <span class="keyword">val</span> value1: <span class="type">List</span>[<span class="type">String</span>] = list.flatMap(data =&gt; data.flatMap(data =&gt; data.split(<span class="string">&quot;,&quot;</span>).toList))</span><br><span class="line">    println(value1)<span class="comment">//List(sprak, strom, mapreduce, hive)</span></span><br><span class="line">    <span class="comment">//foreach,返回值类型为unit</span></span><br><span class="line">    <span class="keyword">val</span> unit: <span class="type">Unit</span> = list.foreach(data =&gt; println(data.toString().split(<span class="string">&quot;,&quot;</span>).toList))</span><br><span class="line">    <span class="comment">//List(List(sprak,  strom))    List(List(mapreduce,  hive))</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//列表过滤</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="comment">//filter用于过滤元素,返回满足条件的元素的新集合</span></span><br><span class="line">    println(list.filter(_ &gt; <span class="number">6</span>))<span class="comment">//List(7, 8, 9, 10)</span></span><br><span class="line">    <span class="comment">//partition按照筛选条件对元素进行分组,返回类型的元组类型</span></span><br><span class="line">    println(list.partition(_ % <span class="number">2</span> == <span class="number">0</span>))<span class="comment">//(List(2, 4, 6, 8, 10),List(1, 3, 5, 7, 9))</span></span><br><span class="line">    <span class="comment">//find,查找第一个满足条件的值,可能不存在,使用getorelse来避免空指针</span></span><br><span class="line">    <span class="keyword">val</span> finddata: <span class="type">Option</span>[<span class="type">Int</span>] = list.find(_ &gt; <span class="number">9</span>)</span><br><span class="line">    <span class="keyword">val</span> i = finddata.getOrElse(<span class="number">9</span>)</span><br><span class="line">    println(i)<span class="comment">//10</span></span><br><span class="line">    <span class="comment">//takewhile,按照筛选条件遍历直到第一个不满足的值,返回已经遍历过的值</span></span><br><span class="line">    <span class="keyword">val</span> value: <span class="type">List</span>[<span class="type">Int</span>] = list.takeWhile(_ &lt; <span class="number">6</span>)</span><br><span class="line">    println(value)<span class="comment">//List(1, 2, 3, 4, 5)</span></span><br><span class="line">    <span class="comment">//dropwhile,按照筛选条件,直到遍历到第一个不满足条件的元素,返回尚未遍历过的元素</span></span><br><span class="line">    println(list.dropWhile(_ &lt; <span class="number">6</span>))<span class="comment">//List(6, 7, 8, 9, 10)</span></span><br><span class="line">    <span class="comment">//span,结合了takewhile和dropwhile,把满足和不满足的值分别放到不同的元组中</span></span><br><span class="line">    <span class="keyword">val</span> tuple: (<span class="type">List</span>[<span class="type">Int</span>], <span class="type">List</span>[<span class="type">Int</span>]) = list.span(_ &lt; <span class="number">6</span>)</span><br><span class="line">    println(tuple)<span class="comment">//(List(1, 2, 3, 4, 5),List(6, 7, 8, 9, 10))</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//构建map</span></span><br><span class="line">    <span class="keyword">val</span> map1 = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">val</span> map2 = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>](<span class="string">&quot;1&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;2&quot;</span> -&gt; <span class="number">2</span>, <span class="string">&quot;3&quot;</span> -&gt; <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> map3 = <span class="type">Map</span>[<span class="type">Seq</span>[<span class="type">String</span>], <span class="type">List</span>[<span class="type">String</span>]]((<span class="type">Seq</span>(<span class="string">&quot;小明&quot;</span>), <span class="type">List</span>(<span class="string">&quot;中华&quot;</span>)), (<span class="literal">null</span>, <span class="literal">null</span>))</span><br><span class="line">    <span class="comment">//获取值</span></span><br><span class="line">    println(map2(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">    println(map1.getOrElse(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>))</span><br><span class="line">    <span class="comment">//增删改,不可变映射不能增加元素</span></span><br><span class="line">    <span class="keyword">val</span> map4 = mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Int</span>]()</span><br><span class="line">    <span class="comment">//存在则是修改,不存在则是增添</span></span><br><span class="line">    println(<span class="type">System</span>.identityHashCode()) <span class="comment">//1007251739</span></span><br><span class="line">    println(map4.hashCode()) <span class="comment">//-1609326920</span></span><br><span class="line">    map4(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">    map4 += (<span class="number">2</span> -&gt; <span class="number">2</span>, <span class="number">3</span> -&gt; <span class="number">3</span>)</span><br><span class="line">    println(map4) <span class="comment">//HashMap(1 -&gt; 1, 2 -&gt; 2, 3 -&gt; 3)</span></span><br><span class="line">    println(<span class="type">System</span>.identityHashCode()) <span class="comment">//1007251739</span></span><br><span class="line">    println(map4.hashCode()) <span class="comment">//-151370400</span></span><br><span class="line">    <span class="comment">//首先理解immutable和mutable，前者为不可变，后者为可变。</span></span><br><span class="line">    <span class="comment">// 这里面的可变性指的是在原List上是否可变，但是如果我改变了该List值，赋值给另外一个List，那是可以的。</span></span><br><span class="line">    <span class="comment">//接下来理解val，var，前者为不可变，后者为可变，</span></span><br><span class="line">    <span class="comment">// 这个指的的后面List的指向，val指向的地址值不可变，var指向的地址值可变。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如何用reduceLeft得到数组中的最大元素?</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">67</span>, <span class="number">45</span>, <span class="number">7889</span>)</span><br><span class="line">    println(array.reduceLeft(rmax))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//使用泛型增加复用性</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">rmax</span></span>[<span class="type">S</span>, <span class="type">T</span>](num: <span class="type">S</span>, num2: <span class="type">T</span>) = &#123;</span><br><span class="line">    <span class="keyword">if</span> (num.toString.toInt.isInstanceOf[<span class="type">Int</span>] &amp;&amp; num2.toString.toInt.isInstanceOf[<span class="type">Int</span>]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (num.toString.toInt &lt; num2.toString.toInt)  num2    <span class="keyword">else</span>  num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象控制的简单案例-实现if</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">           <span class="keyword">var</span> number = <span class="number">10</span></span><br><span class="line">           myif(number &gt; <span class="number">4</span>)&#123;</span><br><span class="line">                 number-= <span class="number">1</span></span><br><span class="line">                 println(number)</span><br><span class="line">           &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">myif</span></span>(f: =&gt; <span class="type">Boolean</span>)(f1: =&gt; <span class="type">Unit</span>):<span class="type">Unit</span>=&#123;</span><br><span class="line">          <span class="keyword">if</span>(f)&#123;</span><br><span class="line">              f1</span><br><span class="line">              myif(f)(f1)</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Wordcount案例(foldLeft方法)</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> words = <span class="string">&quot;AAAABDDDDBBBWWWJJCCCCJTTEEE&quot;</span></span><br><span class="line">    <span class="comment">//使用reducefold方法,分别使用不可变,可变集合</span></span><br><span class="line">    <span class="keyword">val</span> value = words.foldLeft(mutable.<span class="type">Map</span>[<span class="type">Char</span>, <span class="type">Int</span>]())(myreducefold)</span><br><span class="line">    <span class="keyword">val</span> value1 = words.foldLeft(<span class="type">Map</span>[<span class="type">Char</span>, <span class="type">Int</span>]())(myReducefold)</span><br><span class="line">    println(value)</span><br><span class="line">    println(value1)</span><br><span class="line">    <span class="comment">// println(mumap)</span></span><br><span class="line">    <span class="comment">//HashMap(A -&gt; 4, B -&gt; 4, C -&gt; 4, D -&gt; 4, T -&gt; 2, E -&gt; 3, W -&gt; 3, J -&gt; 3)</span></span><br><span class="line">    <span class="comment">//HashMap(E -&gt; 3, T -&gt; 2, J -&gt; 3, A -&gt; 4, B -&gt; 4, C -&gt; 4, W -&gt; 3, D -&gt; 4)</span></span><br><span class="line">    <span class="comment">//HashMap()</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法一</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">myreducefold</span></span>(map: mutable.<span class="type">Map</span>[<span class="type">Char</span>, <span class="type">Int</span>], char: <span class="type">Char</span>) = &#123;</span><br><span class="line">    map.get(char) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(value) =&gt; map + (char -&gt; (value.toInt + <span class="number">1</span>))</span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; map + (char -&gt; <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法二</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">myReducefold</span></span>(map: <span class="type">Map</span>[<span class="type">Char</span>, <span class="type">Int</span>], char: <span class="type">Char</span>) = &#123;</span><br><span class="line">    map + (char -&gt; (map.getOrElse(char, <span class="number">0</span>) + <span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Scala实现一个方法，使得返回数组中，分别等于num，大于num，小于num的元素的个数,getNum（Array（1,2,3,4,5,6），2）结果为（1,1,4）</span></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> array = <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="comment">//考虑模式匹配</span></span><br><span class="line">    array.groupBy &#123;</span><br><span class="line">      <span class="keyword">case</span> x <span class="keyword">if</span> x &lt; <span class="number">2</span> =&gt; <span class="string">&quot;&lt;2&quot;</span></span><br><span class="line">      <span class="keyword">case</span> y <span class="keyword">if</span> y == <span class="number">2</span> =&gt; <span class="string">&quot;=2&quot;</span></span><br><span class="line">      <span class="keyword">case</span> z <span class="keyword">if</span> z &gt; <span class="number">2</span> =&gt; <span class="string">&quot;&gt;2&quot;</span></span><br><span class="line">    &#125;.map(data =&gt; (data._1, data._2.size)).foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//考虑foldleft</span></span><br><span class="line">    <span class="keyword">val</span> a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> b = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> c = <span class="number">0</span></span><br><span class="line">    array.foldLeft(a, b, c)((x, y) =&gt; &#123;</span><br><span class="line">      (<span class="keyword">if</span> (y &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        (x._1 + <span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> x._1,</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">2</span>) &#123;</span><br><span class="line">          (x._2 + <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> x._2,</span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">2</span>) &#123;</span><br><span class="line">          (x._3 + <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> x._3)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//考虑aggregate聚合方法</span></span><br><span class="line">    <span class="keyword">var</span> result = array.aggregate(a, b, c)((x, y) =&gt; &#123;</span><br><span class="line">      (<span class="keyword">if</span> (y &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        x._1 + <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> x._1,</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">2</span>) &#123;</span><br><span class="line">          x._2 + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> x._2,</span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">2</span>) &#123;</span><br><span class="line">          x._3 + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> x._3)</span><br><span class="line">    &#125;, <span class="literal">null</span>)</span><br><span class="line">    println((result._1, result._2, result._3))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//考虑过滤</span></span><br><span class="line">    println((array.count(_ &gt; <span class="number">2</span>), array.count(_ &lt; <span class="number">2</span>), array.count(_ == <span class="number">2</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//偏函数实现过滤功能</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&quot;scala&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> ints: <span class="type">Array</span>[<span class="type">Int</span>] = array.collect(&#123;</span><br><span class="line">      <span class="keyword">case</span> x: <span class="type">Int</span> <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">1</span>) =&gt; x</span><br><span class="line">    &#125;)</span><br><span class="line">    println(ints.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ints1: <span class="type">Array</span>[<span class="type">Int</span>] = array.collect(myfilter)</span><br><span class="line">    println(ints1.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> myfilter: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> d: <span class="type">Int</span> <span class="keyword">if</span> (d % <span class="number">2</span> == <span class="number">0</span>) =&gt; d</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计字符串中的不同字母出现的位置并排序</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> st: <span class="type">String</span> = <span class="string">&quot;AANNCCCRRUUSSRT&quot;</span></span><br><span class="line">    <span class="keyword">var</span> map = mutable.<span class="type">Map</span>[<span class="type">Char</span>, <span class="type">ListBuffer</span>[<span class="type">Int</span>]]()</span><br><span class="line">    <span class="keyword">var</span> index: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    st.foreach(data =&gt; &#123;</span><br><span class="line">      map.get(data) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="comment">//case有值和null</span></span><br><span class="line">        <span class="comment">//往集合中添加索引</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(value) =&gt; map(data) = value :+ index</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt; map += (data -&gt; <span class="type">ListBuffer</span>[<span class="type">Int</span>] (</span><br><span class="line">          index)</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      index += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> value: <span class="type">Seq</span>[(<span class="type">Char</span>, <span class="type">ListBuffer</span>[<span class="type">Int</span>])] = map.toList.sortBy(_._1).reverse</span><br><span class="line">    println(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//unapplySeq提取器用法</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="string">&quot;小明,小华,小聚,小米&quot;</span></span><br><span class="line">    <span class="keyword">val</span> tuple: (<span class="type">String</span>, <span class="type">String</span>) = st <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Name</span>(a, b, c, d) =&gt; (c, d)</span><br><span class="line">    &#125;</span><br><span class="line">    println(tuple)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Name</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapplySeq</span></span>(arg: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">Array</span>[<span class="type">String</span>]] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (arg.length == <span class="number">0</span>) <span class="type">None</span> <span class="keyword">else</span> <span class="type">Some</span>(arg.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Programming Language</category>
      </categories>
      <tags>
        <tag>Summary of knowledge</tag>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark常用算子分析</title>
    <url>/2020/10/15/Spark-Common-Operators/</url>
    <content><![CDATA[<h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><h6 id="map-and-filter"><a href="#map-and-filter" class="headerlink" title="map and filter"></a>map and filter</h6><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MapAndFilterDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;mapfliter&quot;</span>).setMaster(<span class="string">&quot;local[*]&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>))</span><br><span class="line">    <span class="keyword">val</span> map: <span class="type">MapPartitionsRDD</span>[<span class="type">Double</span>, <span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>[<span class="type">Double</span>,<span class="type">Int</span>](rdd, (_, _, iter) =&gt; iter.map(data =&gt; &#123;</span><br><span class="line">      data.toString.toDouble * <span class="number">10</span></span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="keyword">val</span> filter = <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>[<span class="type">Double</span>, <span class="type">Double</span>](map, (_, _, iter) =&gt; iter.filter(data =&gt; data &gt; <span class="number">4</span>))</span><br><span class="line">    filter.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="map-and-mappartition"><a href="#map-and-mappartition" class="headerlink" title="map and mappartition"></a>map and mappartition</h6><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mappartition 从数据源拿的是一个迭代器</span></span><br><span class="line">  <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>(</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      (_: <span class="type">TaskContext</span>, _: <span class="type">Int</span>, iter: <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; cleanedF(iter)</span><br><span class="line"><span class="comment">//map拿取的是迭代器中的一个一个数据      </span></span><br><span class="line">  <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>[<span class="type">U</span>, <span class="type">T</span>](<span class="keyword">this</span>, (_, _, iter) =&gt; iter.map(cleanF))</span><br></pre></td></tr></table></figure>



<h6 id="repartitionAndSortWithinPartitions"><a href="#repartitionAndSortWithinPartitions" class="headerlink" title="repartitionAndSortWithinPartitions"></a>repartitionAndSortWithinPartitions</h6><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">repartitionAndSortWithinPartitionsDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span>.getClass.getSimpleName).setMaster(<span class="string">&quot;local[*]&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.textFile(args(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">val</span> maprdd: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = rdd.map(data =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> txt = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">      (txt(<span class="number">0</span>), txt(<span class="number">1</span>).toInt)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//TODO 获取分区的标准,例如按照姓名来分区,首先触发一次job获取有多少个人</span></span><br><span class="line">    <span class="keyword">val</span> groupcount: <span class="type">Array</span>[<span class="type">String</span>] = maprdd.map(_._1).collect()</span><br><span class="line">    <span class="keyword">val</span> partition = <span class="keyword">new</span> <span class="type">MyPartition</span>(groupcount)</span><br><span class="line">    <span class="comment">//val rerdd: RDD[(String, Int)] = maprdd.repartitionAndSortWithinPartitions(partition)</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">val</span> sort = <span class="type">Ordering</span>[<span class="type">String</span>].on[<span class="type">String</span>](t =&gt; t).reverse</span><br><span class="line">    <span class="keyword">val</span> shuffrdd = <span class="keyword">new</span> <span class="type">ShuffledRDD</span>[<span class="type">String</span>, <span class="type">Int</span>, <span class="type">Int</span>](maprdd, partition)</span><br><span class="line">    shuffrdd.setKeyOrdering(sort)</span><br><span class="line">    shuffrdd.saveAsTextFile(args(<span class="number">1</span>))</span><br><span class="line">    <span class="type">Thread</span>.sleep(<span class="type">Int</span>.<span class="type">MaxValue</span>)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPartition</span>(<span class="params">groupcount: <span class="type">Array</span>[<span class="type">String</span>]</span>) <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> map = mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]()</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (name &lt;- groupcount) &#123;</span><br><span class="line">    map(name) = index</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = groupcount.length</span><br><span class="line">  <span class="comment">//获取的是key</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> value = key.asInstanceOf[<span class="type">String</span>]</span><br><span class="line">    map(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="groupbykey-and-groupby"><a href="#groupbykey-and-groupby" class="headerlink" title="groupbykey and groupby"></a>groupbykey and groupby</h6><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">GroupByKeyDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;groupbykey&quot;</span>).setMaster(<span class="string">&quot;local[*]&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> maprdd = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;spark&quot;</span>, <span class="string">&quot;scala&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;js&quot;</span>, <span class="string">&quot;flink&quot;</span>,</span><br><span class="line">      <span class="string">&quot;spark&quot;</span>, <span class="string">&quot;scala&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;js&quot;</span>, <span class="string">&quot;flink&quot;</span>,</span><br><span class="line">      <span class="string">&quot;spark&quot;</span>, <span class="string">&quot;scala&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;js&quot;</span>, <span class="string">&quot;flink&quot;</span>)).map(data =&gt; (data, <span class="number">1</span>))</span><br><span class="line">    maprdd.groupByKey()</span><br><span class="line">    <span class="keyword">val</span> shufflerdd = <span class="keyword">new</span> <span class="type">ShuffledRDD</span>[<span class="type">String</span>, <span class="type">Int</span>, <span class="type">CompactBuffer</span>[<span class="type">Int</span>]](maprdd, <span class="keyword">new</span> <span class="type">HashPartitioner</span>(maprdd.partitions.length))</span><br><span class="line">    <span class="comment">//设置局部不聚合</span></span><br><span class="line">    shufflerdd.setMapSideCombine(<span class="literal">false</span>)</span><br><span class="line">    <span class="comment">//将每个组内的元素的value值放到集合中</span></span><br><span class="line">    <span class="keyword">val</span> createCombiner = (v: <span class="type">Int</span>) =&gt; <span class="type">CompactBuffer</span>(v)</span><br><span class="line">    <span class="comment">//把组内其他元素添加到集合中</span></span><br><span class="line">    <span class="keyword">val</span> mergeValue = (buf: <span class="type">CompactBuffer</span>[<span class="type">Int</span>], v: <span class="type">Int</span>) =&gt; buf += v</span><br><span class="line">    <span class="comment">//在下游进行合并</span></span><br><span class="line">    <span class="keyword">val</span> mergeCombiners = (c1: <span class="type">CompactBuffer</span>[<span class="type">Int</span>], c2: <span class="type">CompactBuffer</span>[<span class="type">Int</span>]) =&gt; c1 ++= c2</span><br><span class="line">    <span class="keyword">val</span> groupbukeyrdd = shufflerdd.setAggregator(<span class="keyword">new</span> <span class="type">Aggregator</span>[<span class="type">String</span>, <span class="type">Int</span>, <span class="type">CompactBuffer</span>[<span class="type">Int</span>]](</span><br><span class="line">      createCombiner, mergeValue, mergeCombiners</span><br><span class="line">    ))</span><br><span class="line">    groupbukeyrdd.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//源码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupBy</span></span>[<span class="type">K</span>](f: <span class="type">T</span> =&gt; <span class="type">K</span>, p: <span class="type">Partitioner</span>)(<span class="keyword">implicit</span> kt: <span class="type">ClassTag</span>[<span class="type">K</span>], ord: <span class="type">Ordering</span>[<span class="type">K</span>] = <span class="literal">null</span>)</span><br><span class="line">      : <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">Iterable</span>[<span class="type">T</span>])] = withScope &#123;</span><br><span class="line">    <span class="keyword">val</span> cleanF = sc.clean(f)</span><br><span class="line">    <span class="keyword">this</span>.map(t =&gt; (cleanF(t), t)).groupByKey(p)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h6 id="reducebykey"><a href="#reducebykey" class="headerlink" title="reducebykey"></a>reducebykey</h6><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ReducebukeyDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;groupbykey&quot;</span>).setMaster(<span class="string">&quot;local[*]&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> maprdd = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;spark&quot;</span>, <span class="string">&quot;scala&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;js&quot;</span>, <span class="string">&quot;flink&quot;</span>,</span><br><span class="line">      <span class="string">&quot;spark&quot;</span>, <span class="string">&quot;scala&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;js&quot;</span>, <span class="string">&quot;flink&quot;</span>,</span><br><span class="line">      <span class="string">&quot;spark&quot;</span>, <span class="string">&quot;scala&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;js&quot;</span>, <span class="string">&quot;flink&quot;</span>), <span class="number">2</span>).map(data =&gt; (data, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">val</span> createCombiner = (x: <span class="type">Int</span>) =&gt; x</span><br><span class="line">    <span class="keyword">val</span> mergeValue = (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y</span><br><span class="line">    <span class="keyword">val</span> mergeCombiners = (x1: <span class="type">Int</span>, x2: <span class="type">Int</span>) =&gt; x1 + x2</span><br><span class="line">    maprdd.combineByKey(</span><br><span class="line">      (x =&gt; x), (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y, (x1: <span class="type">Int</span>, x2: <span class="type">Int</span>) =&gt; x1 + x2</span><br><span class="line">    ).saveAsTextFile(<span class="string">&quot;combinebykey&quot;</span>)</span><br><span class="line">    <span class="comment">//使用shuffleRDD</span></span><br><span class="line">    <span class="keyword">val</span> shufflerdd = <span class="keyword">new</span> <span class="type">ShuffledRDD</span>[<span class="type">String</span>, <span class="type">Int</span>, <span class="type">Int</span>](maprdd, <span class="keyword">new</span> <span class="type">HashPartitioner</span>(maprdd.partitions.length))</span><br><span class="line">    <span class="comment">//是否局部聚合</span></span><br><span class="line">    shufflerdd.setMapSideCombine(<span class="literal">true</span>)</span><br><span class="line">    shufflerdd.setAggregator(<span class="keyword">new</span> <span class="type">Aggregator</span>[<span class="type">String</span>, <span class="type">Int</span>, <span class="type">Int</span>](</span><br><span class="line">      createCombiner, mergeValue, mergeCombiners</span><br><span class="line">    )).saveAsTextFile(<span class="string">&quot;shufflerdd&quot;</span>)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="join"><a href="#join" class="headerlink" title="join"></a>join</h6><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;groupbykey&quot;</span>).setMaster(<span class="string">&quot;local[*]&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>((<span class="string">&quot;spark&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;scala&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;kafka&quot;</span>, <span class="number">4</span>), (<span class="string">&quot;flink&quot;</span>, <span class="number">9</span>), (<span class="string">&quot;spark&quot;</span>, <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">val</span> rdd2 = sc.makeRDD(<span class="type">List</span>((<span class="string">&quot;spark&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;scala&quot;</span>, <span class="number">4</span>), (<span class="string">&quot;kafka&quot;</span>, <span class="number">5</span>), (<span class="string">&quot;strom&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;strom&quot;</span>, <span class="number">4</span>)))</span><br><span class="line">    <span class="comment">//cogroup的效果如:(spark,(CompactBuffer(1, 1),CompactBuffer(3))),考虑使用for循环,</span></span><br><span class="line">    <span class="keyword">val</span> cordd: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Iterable</span>[<span class="type">Int</span>], <span class="type">Iterable</span>[<span class="type">Int</span>]))] = rdd1.cogroup(rdd2)</span><br><span class="line">   <span class="comment">//flatMapValues把集合扁平化了,避免了空值的出现</span></span><br><span class="line">    <span class="keyword">val</span> joinrdd: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = cordd.flatMapValues(data =&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (it &lt;- data._1; it2 &lt;- data._2) <span class="keyword">yield</span> (it, it2)</span><br><span class="line">    &#125;)</span><br><span class="line">    joinrdd.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FullJoinDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;groupbykey&quot;</span>).setMaster(<span class="string">&quot;local[*]&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>((<span class="string">&quot;spark&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;scala&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;kafka&quot;</span>, <span class="number">4</span>), (<span class="string">&quot;flink&quot;</span>, <span class="number">9</span>), (<span class="string">&quot;spark&quot;</span>, <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">val</span> rdd2 = sc.makeRDD(<span class="type">List</span>((<span class="string">&quot;spark&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;scala&quot;</span>, <span class="number">4</span>), (<span class="string">&quot;kafka&quot;</span>, <span class="number">5</span>), (<span class="string">&quot;strom&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;strom&quot;</span>, <span class="number">4</span>)))</span><br><span class="line">    <span class="keyword">val</span> cordd = rdd1.cogroup(rdd2)</span><br><span class="line">    cprdd.flatMapValues &#123;</span><br><span class="line">      <span class="keyword">case</span> (vs, <span class="type">Seq</span>()) =&gt; vs.iterator.map((_,<span class="type">None</span>))</span><br><span class="line">      <span class="keyword">case</span> (<span class="type">Seq</span>(), ws) =&gt; ws.iterator.map((<span class="type">None</span>,_))</span><br><span class="line">      <span class="keyword">case</span> (vs, ws) =&gt; <span class="keyword">for</span> (it &lt;- vs.iterator; it2 &lt;- ws.iterator) <span class="keyword">yield</span> (<span class="type">Some</span>(it), <span class="type">Some</span>(it2))</span><br><span class="line">    &#125;.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2>]]></content>
      <categories>
        <category>The Hadoop Ecosystem</category>
        <category>Learning Spark</category>
      </categories>
      <tags>
        <tag>Work Systematically</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark执行流程简单分析</title>
    <url>/2020/11/24/Spark-Perform-Process-Analysis/</url>
    <content><![CDATA[<h2 id="spark-on-yarn"><a href="#spark-on-yarn" class="headerlink" title="spark on yarn"></a>spark on yarn</h2><h4 id="Yarn-Cluster"><a href="#Yarn-Cluster" class="headerlink" title="Yarn-Cluster"></a>Yarn-Cluster</h4><h2 id="Spark-Standalone"><a href="#Spark-Standalone" class="headerlink" title="Spark-Standalone"></a>Spark-Standalone</h2><ol>
<li>spark-submit执行脚本在client模式下，脚本通过反射调用程序的业务逻辑 </li>
<li>sparksubmit将任务的信息发送给master</li>
<li>master向worker通信,需要的资源信息,application,driver信息发送给worker</li>
<li>worker启动executor</li>
<li>executor跟driver反向注册</li>
<li>driver创建RDD Action算子会调用runjob触发执行</li>
<li>根据最后一个RDD往前推,根据依赖关系stage,RDD递归类似于类似于栈的结构,递归的出口是没有父RDD</li>
<li>先提交前面的stage,再提交后面的stage,一个stage对应一个stageset,一个stageset有多个task(shuffleMaptask Resulttask),然后把taskset传递给tasksecheduler</li>
<li>asksecheduler将taskset中的task进行序列化,然后根据executor的资源情况,将序列化的task发送给executor</li>
<li>将taskdesccription反序列化用taskrunner包装放在线程池中</li>
<li>调用task的run方法,传入到taskcontext中,然后根据具体的task类型,如果是shufflemaptask,就调用其runtask</li>
<li>将数据先应用分区器返回ID,然后写入到APPendonlymap的内存中,默认达到5M溢写到磁盘,生成两个文件一个索引文件和数据文件</li>
<li>mappartitionRDD向shuffledRDD要数据,shuffleRDD获取shuffledReader,从上游拉取属于自己分区的数据,然后进行全局的聚合,最后将聚合的结果写入到hdfs中</li>
</ol>
<h2 id="Spark通信分析"><a href="#Spark通信分析" class="headerlink" title="Spark通信分析"></a>Spark通信分析</h2><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>作为一个JVM进程,Executor的内存管理建立在JVM的内存管理之上,</p>
<p>Spark对JVM的堆内（On-heap）空间进行了更为详细的分配,以充分利用内存.</p>
<p>同时,Spark引入了堆外（Off-heap）内存,</p>
<p>使之可以直接在工作节点的系统内存中开辟空间,进一步优化了内存的使用.</p>
<h4 id="堆内内存-On-heap-Memory"><a href="#堆内内存-On-heap-Memory" class="headerlink" title="堆内内存(On-heap Memory)"></a>堆内内存(On-heap Memory)</h4><p>堆内内存的大小,由Spark应用程序启动时的<strong>–executor-memory或spark.executor.memory</strong>参数配置.</p>
<p>Executor内运行的并发任务共享JVM堆内内存,这些任务在缓存RDD和广播（Broadcast）</p>
<p>数据时占用的内存被规划为<strong>存储（Storage）</strong>内存,而这些任务在执行Shuffle时占用的内存</p>
<p>被规划为<strong>执行（Execution）</strong>内存,剩余的部分不做特殊规划,那些Spark内部的对象实例,</p>
<p>或者用户定义的Spark应用程序中的对象实例,均占用剩余的空间.</p>
<p>不同的管理模式下,这三部分占用的空间大小各不相同 </p>
<h4 id="堆内内存分析"><a href="#堆内内存分析" class="headerlink" title="堆内内存分析"></a>堆内内存分析</h4><p>我们知道,堆内内存采用JVM来进行管理.而JVM的对象可以以<strong>序列化</strong>的方式存储,</p>
<p><strong>序列化的过程是将对象转换为二进制字节流,本质上可以理解为将非连续空间的链式存储转</strong></p>
<p><strong>化为连续空间或块存储</strong>,在访问时则需要进行序列化的逆过程——反序列化,</p>
<p>将字节流转化为对象,序列化的方式可以节省存储空间,但增加了存储和读取时候的计算开销.</p>
<p>对于Spark中序列化的对象,由于是字节流的形式,其占用的内存大小可直接计算.</p>
<p>对于Spark中非序列化的对象,其占用的内存是通过周期性地采样<strong>近似估算</strong>而得,</p>
<p>即并不是每次新增的数据项都会计算一次占用的内存大小.但是这种方法</p>
<p>降低了时间开销但是有可能误差较大,<strong>导致某一时刻的实际内存有可能远远超出预期</strong></p>
<p>此外,在被Spark标记为释放的对象实例,很有可能在实际上并没有被JVM回收,</p>
<p>导致实际可用的内存小于Spark记录的可用内存.所以Spark并不能准确记录实际</p>
<p>可用的堆内内存,从而也就无法完全避免内存溢出（OOM, Out of Memory）的异常.</p>
<p>虽然不能精准控制堆内内存的申请和释放,但Spark通过对存储内存和执行内存各</p>
<p>自独立的<strong>规划管理</strong>,可以决定是否要在存储内存里缓存新的RDD,以及是否为新的</p>
<p>任务分配执行内存,在一定程度上可以提升内存的利用率,减少异常的出现. </p>
<h4 id="堆外内存-Off-heap-Memory"><a href="#堆外内存-Off-heap-Memory" class="headerlink" title="堆外内存(Off-heap Memory)"></a>堆外内存(Off-heap Memory)</h4><p>默认情况下,Spark 仅仅使用了堆内内存.Executor端的堆内内存区域大致可以分为以下四大块：</p>
<p><strong>Execution内存</strong>    主要用于存放 Shuffle、Join、Sort、Aggregation 等计算过程中的临时数据</p>
<p><strong>Storage内存</strong>       主要用于存储 spark 的 cache 数据,例如RDD的缓存、unroll数据</p>
<p><strong>用户内存（User Memory）</strong>            主要用于存储 RDD 转换操作所需要的数据,例如 RDD 依赖等信息</p>
<p><strong>预留内存（Reserved Memory）</strong>    系统预留内存,会用来存储Spark内部对象</p>
<p>Spark 1.6 开始引入了Off-heap memory.这种模式不在JVM 内申请内存,</p>
<p>而是调用 Java 的 unsafe 相关 API 进行诸如 C 语言里面的malloc() 直接向操作系统申请内存.</p>
<p>由于这种方式不经过 JVM 内存管理,所以可以避免频繁的 GC,这种内存申请的缺点是必须自己编写内存申请和释放的逻辑.</p>
<p>利用JDK Unsafe API（从Spark 2.0开始,在管理堆外的存储内存时不再基于</p>
<p>Tachyon,而是与堆外的执行内存一样,基于JDK Unsafe API实现）,</p>
<p>Spark可以直接操作系统堆外内存,减少了不必要的内存开销,以及频繁的GC扫描和回收,</p>
<p>提升了处理性能.堆外内存可以被精确地申请和释放,而且序列化的数据占用的空间</p>
<p>可以被精确计算,所以相比堆内内存来说降低了管理的难度,也降低了误差.</p>
<h4 id="动态占用机制"><a href="#动态占用机制" class="headerlink" title="动态占用机制"></a>动态占用机制</h4><p>程序提交的时候我们都会设定基本的Execution内存和</p>
<p>Storage内存区域（通过 spark.memory.storageFraction 参数设置）;</p>
<p>在程序运行时,双方的空间都不足时,则存储到硬盘；将内存中的块存储到磁盘的策略是按照 LRU </p>
<p>规则(Least Recently Used)进行的.若己方空间不足而对方空余时,</p>
<p>可借用对方的空间;（存储空间不足是指不足以放下一个完整的 Block）</p>
<p>Execution内存的空间被对方占用后,可让对方将占用的部分转存到硬盘,然后”归还”借用的空间</p>
<p>Storage内存的空间被对方占用后,目前的实现是无法让对方”归还”,</p>
<p>因为需要考虑 Shuffle 过程中的很多因素,实现起来较为复杂；而且 </p>
<p>Shuffle 过程产生的文件在后面一定会被使用到,而 Cache 在内存的数据不一定在后面使用.</p>
<p>注意,上面说的借用对方的内存需要借用方和被借用方的内存类型都一样,</p>
<p>都是堆内内存或者都是堆外内存,不存在堆内内存不够去借用堆外内存的空间. </p>
<h2 id="shuffle阶段分析"><a href="#shuffle阶段分析" class="headerlink" title="shuffle阶段分析"></a>shuffle阶段分析</h2><h4 id="HashShuffle普通机制"><a href="#HashShuffle普通机制" class="headerlink" title="HashShuffle普通机制:"></a>HashShuffle普通机制:</h4><ol>
<li><p>每一个map task将不同结果写到不同的buffer中，每个buffer的大小为32K。buffer起到数据缓存的作用</p>
</li>
<li><p>每个buffer文件最后对应一个磁盘小文件</p>
</li>
<li><p> reduce task来拉取对应的磁盘小文件</p>
</li>
<li><p>map task的计算结果会根据分区器（默认是hashPartitioner）来决定写入到哪一个磁盘小文件中去.ReduceTask会去Map端拉取相应的磁盘小文件.  </p>
</li>
<li><p>产生的磁盘小文件的个数: M（map task的个数）* R（reducetask的个数）</p>
</li>
</ol>
<h4 id="合并机制"><a href="#合并机制" class="headerlink" title="合并机制"></a>合并机制</h4><p>产生磁盘小文件的个数: C(core的个数)*R（reduce的个数）</p>
<h4 id="SortShuffle普通机制"><a href="#SortShuffle普通机制" class="headerlink" title="SortShuffle普通机制"></a>SortShuffle普通机制</h4><p>没有开启mapsideconbine &amp;&amp; 分区数小于 spark.shuffle.sort.bypassMergeThreshold的参数值.这个值默认是200   bypass 例如</p>
<p>groupbykey或者groupby并且分区分区数小于200</p>
<p>判断Serializer是否relacation,没有聚合器 &amp;&amp; 分区数小于2^24  unsafeshuffle 例如repartitionandsortwithinpartition</p>
<p>否则 sortshuffle</p>
<ol>
<li><p>每个maptask将计算结果写入内存数据结构中,这个内存默认大小为5M</p>
</li>
<li><p>会有一个“监控器”来不定时的检查这个内存的大小,如果写满了5M,比如达到了5.01M,那么再给这个内存申请5.02M（5.01M * 2 – 5M </p>
<p>= 5.02）的内存,此时这个内存空间的总大小为10.02M</p>
</li>
<li><p>当“定时器”再次发现数据已经写满了,大小10.05M,会再次给它申请内存,大小为 10.05M * 2 – 10.02M = 10.08M</p>
</li>
<li><p>假如此时总的内存只剩下5M,不足以再给这个内存分配10.08M,那么这个内存会被锁起来,把里面的数据按照相同的key为一组,进行排</p>
<p>序后,分别写到不同的缓存中,然后溢写到不同的小文件中,而map task产生的新的计算结果会写入总内存剩余的5M中</p>
</li>
<li><p>buffer中的数据（已经排好序）溢写的时候,会分批溢写,默认一次溢写10000条数据,假如最后一部分数据不足10000条,那么剩下多少</p>
<p>条就一次性溢写多少条</p>
</li>
<li><p>每个map task产生的小文件,最终合并成一个大文件来让reduce拉取数据,合成大文件的同时也会生成这个大文件的索引文件,里面记录</p>
<p>着分区信息和偏移量（比如：key为hello的数据在第5个字节到第8097个字节）</p>
</li>
<li><p>最终产生的小文件数为2*m（map task的数量）</p>
</li>
</ol>
<h4 id="BypassMergeSortShuffle"><a href="#BypassMergeSortShuffle" class="headerlink" title="BypassMergeSortShuffle"></a>BypassMergeSortShuffle</h4><p>BypassMergeSortShuffleWriter 所有的中间数据都是在磁盘里,并没有利用内存.而且它只保证分区索引的排序,而并不保证数据的排序</p>
<p>IndexShuffleBlockResolver类负责创建索引文件,存储到ShuffleIndexBlock数据块中.它提供了writeIndexFileAndCommit方法创建索引.</p>
<p>因为创建索引文件,有线程竞争.所以它会先建立临时索引文件,然后再去检查索引文件是否已经存在,并且与临时索引文件是否相同.如果一</p>
<p>致,则删除临时索引文件.如果不一致,则会更新索引文件</p>
<p>BypassMergeSortShuffleWriter 算法适用于没有聚合,数据量不大的场景.给每个分区分配一个临时文件,对每个 record 的 key 使用分区器</p>
<p>（模式是hash,如果用户自定义就使用自定义的分区器）找到对应分区的输出文件并写入文件对应的文件</p>
<h4 id="Spark-submit分析"><a href="#Spark-submit分析" class="headerlink" title="Spark-submit分析"></a>Spark-submit分析</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CoarseGrainedExecutorBackend类</span></span><br><span class="line">driverConf.set(<span class="type">EXECUTOR_ID</span>, arguments.executorId)</span><br><span class="line">  <span class="keyword">val</span> env = <span class="type">SparkEnv</span>.createExecutorEnv(driverConf, arguments.executorId, arguments.bindAddress,</span><br><span class="line">    arguments.hostname, arguments.cores, cfg.ioEncryptionKey, isLocal = <span class="literal">false</span>)</span><br><span class="line">  <span class="comment">//注册executor</span></span><br><span class="line">  env.rpcEnv.setupEndpoint(<span class="string">&quot;Executor&quot;</span>,</span><br><span class="line">    backendCreateFn(env.rpcEnv, arguments, env, cfg.resourceProfile))</span><br><span class="line">  arguments.workerUrl.foreach &#123; url =&gt;</span><br><span class="line">    env.rpcEnv.setupEndpoint(<span class="string">&quot;WorkerWatcher&quot;</span>, <span class="keyword">new</span> <span class="type">WorkerWatcher</span>(env.rpcEnv, url))</span><br><span class="line">  &#125;</span><br><span class="line">  env.rpcEnv.awaitTermination()</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">RegisteredExecutor</span> =&gt;</span><br><span class="line">      logInfo(<span class="string">&quot;Successfully registered with driver&quot;</span>)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//启动executor</span></span><br><span class="line">        executor = <span class="keyword">new</span> <span class="type">Executor</span>(executorId, hostname, env, userClassPath, isLocal = <span class="literal">false</span>,</span><br><span class="line">          resources = _resources)</span><br><span class="line">        <span class="comment">//向driver通信</span></span><br><span class="line">        driver.get.send(<span class="type">LaunchedExecutor</span>(executorId))</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">          exitExecutor(<span class="number">1</span>, <span class="string">&quot;Unable to create executor due to &quot;</span> + e.getMessage, e)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//启动完成driver就开始创建rdd</span></span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//executor的本质</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> threadPool = &#123;</span><br><span class="line">    <span class="keyword">val</span> threadFactory = <span class="keyword">new</span> <span class="type">ThreadFactoryBuilder</span>()</span><br><span class="line">      .setDaemon(<span class="literal">true</span>)</span><br><span class="line">      .setNameFormat(<span class="string">&quot;Executor task launch worker-%d&quot;</span>)</span><br><span class="line">      .setThreadFactory((r: <span class="type">Runnable</span>) =&gt; <span class="keyword">new</span> <span class="type">UninterruptibleThread</span>(r, <span class="string">&quot;unused&quot;</span>))</span><br><span class="line">      .build()</span><br><span class="line">    <span class="type">Executors</span>.newCachedThreadPool(threadFactory).asInstanceOf[<span class="type">ThreadPoolExecutor</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">LaunchTask</span>(data) =&gt;</span><br><span class="line">      <span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">        exitExecutor(<span class="number">1</span>, <span class="string">&quot;Received LaunchTask command but executor was null&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//driver发送task到executor</span></span><br><span class="line">        <span class="keyword">val</span> taskDesc = <span class="type">TaskDescription</span>.decode(data.value)</span><br><span class="line">        logInfo(<span class="string">&quot;Got assigned task &quot;</span> + taskDesc.taskId)</span><br><span class="line">        taskResources(taskDesc.taskId) = taskDesc.resources</span><br><span class="line">        executor.launchTask(<span class="keyword">this</span>, taskDesc)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//executor重新把task给包装为taskrunner放到线程池中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">launchTask</span></span>(context: <span class="type">ExecutorBackend</span>, taskDescription: <span class="type">TaskDescription</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> tr = <span class="keyword">new</span> <span class="type">TaskRunner</span>(context, taskDescription)</span><br><span class="line">    runningTasks.put(taskDescription.taskId, tr)</span><br><span class="line">    threadPool.execute(tr)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TaskRunner 调用run方法</span></span><br><span class="line"><span class="comment">// 在task类里用runtask方法,调用方法</span></span><br><span class="line"> <span class="keyword">val</span> value = <span class="type">Utils</span>.tryWithSafeFinally &#123;</span><br><span class="line">            <span class="keyword">val</span> res = task.run(</span><br><span class="line">            taskAttemptId = taskId,</span><br><span class="line">            attemptNumber = taskDescription.attemptNumber,</span><br><span class="line">            metricsSystem = env.metricsSystem,</span><br><span class="line">            resources = taskDescription.resources)</span><br><span class="line">          threwException = <span class="literal">false</span></span><br><span class="line">          res</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//runtask</span></span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">runTask</span></span>(context: <span class="type">TaskContext</span>): <span class="type">MapStatus</span> = &#123;</span><br><span class="line">    <span class="comment">// Deserialize the RDD using the broadcast variable.</span></span><br><span class="line">    <span class="keyword">val</span> threadMXBean = <span class="type">ManagementFactory</span>.getThreadMXBean</span><br><span class="line">    <span class="keyword">val</span> deserializeStartTimeNs = <span class="type">System</span>.nanoTime()</span><br><span class="line">    <span class="keyword">val</span> deserializeStartCpuTime = <span class="keyword">if</span> (threadMXBean.isCurrentThreadCpuTimeSupported) &#123;</span><br><span class="line">      threadMXBean.getCurrentThreadCpuTime</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="number">0</span>L</span><br><span class="line">    <span class="keyword">val</span> ser = <span class="type">SparkEnv</span>.get.closureSerializer.newInstance()</span><br><span class="line">    <span class="keyword">val</span> rddAndDep = ser.deserialize[(<span class="type">RDD</span>[_], <span class="type">ShuffleDependency</span>[_, _, _])](</span><br><span class="line">      <span class="type">ByteBuffer</span>.wrap(taskBinary.value), <span class="type">Thread</span>.currentThread.getContextClassLoader)</span><br><span class="line">    _executorDeserializeTimeNs = <span class="type">System</span>.nanoTime() - deserializeStartTimeNs</span><br><span class="line">    _executorDeserializeCpuTime = <span class="keyword">if</span> (threadMXBean.isCurrentThreadCpuTimeSupported) &#123;</span><br><span class="line">      threadMXBean.getCurrentThreadCpuTime - deserializeStartCpuTime</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="number">0</span>L</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rdd = rddAndDep._1</span><br><span class="line">    <span class="keyword">val</span> dep = rddAndDep._2</span><br><span class="line">    <span class="comment">// While we use the old shuffle fetch protocol, we use partitionId as mapId in the</span></span><br><span class="line">    <span class="comment">// ShuffleBlockId construction.</span></span><br><span class="line">    <span class="keyword">val</span> mapId = <span class="keyword">if</span> (<span class="type">SparkEnv</span>.get.conf.get(config.<span class="type">SHUFFLE_USE_OLD_FETCH_PROTOCOL</span>)) &#123;</span><br><span class="line">      partitionId</span><br><span class="line">    &#125; <span class="keyword">else</span> context.taskAttemptId()</span><br><span class="line">    dep.shuffleWriterProcessor.write(rdd, dep, mapId, context, partition)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//shufflemaptask</span></span><br><span class="line"><span class="comment">//条件都不满足调用compute</span></span><br><span class="line"></span><br><span class="line">   writer.write(</span><br><span class="line">        rdd.iterator(partition, context).asInstanceOf[<span class="type">Iterator</span>[_ &lt;: <span class="type">Product2</span>[<span class="type">Any</span>, <span class="type">Any</span>]]])</span><br><span class="line">        writer.stop(success = <span class="literal">true</span>).get</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (storageLevel != <span class="type">StorageLevel</span>.<span class="type">NONE</span>) &#123;</span><br><span class="line">      getOrCompute(split, context)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      computeOrReadCheckpoint(split, context)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">computeOrReadCheckpoint</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">T</span>] =</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (isCheckpointedAndMaterialized) &#123;</span><br><span class="line">      firstParent[<span class="type">T</span>].iterator(split, context)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      compute(split, context)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compute</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">T</span>]</span><br><span class="line">  <span class="comment">//mappartitionRDD调用了这个方法</span></span><br><span class="line">  <span class="comment">//不断向上一个RDD要数据,直至数据源(hadoopRDD),这个RDD也有computer方法</span></span><br></pre></td></tr></table></figure>





<h2 id="Sort-采样分析"><a href="#Sort-采样分析" class="headerlink" title="Sort 采样分析"></a>Sort 采样分析</h2><h4 id="HashPartitioner"><a href="#HashPartitioner" class="headerlink" title="HashPartitioner"></a>HashPartitioner</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = key <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="literal">null</span> =&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="type">Utils</span>.nonNegativeMod(key.hashCode, numPartitions)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nonNegativeMod</span></span>(x: <span class="type">Int</span>, mod: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> rawMod = x % mod</span><br><span class="line">  rawMod + (<span class="keyword">if</span> (rawMod &lt; <span class="number">0</span>) mod <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RangePartitioner"><a href="#RangePartitioner" class="headerlink" title="RangePartitioner"></a>RangePartitioner</h4><ol>
<li> 先从迭代器的前k个元素,存储到蓄水池</li>
<li> 依次遍历余下的元素,比如遍历第m个元素,然后生成[0, m)区间的随机数 i.如果 i 小于 k,则替换掉原来的第 i 个元素</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reservoirSampleAndCount</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      input: <span class="type">Iterator</span>[<span class="type">T</span>],</span><br><span class="line">      k: <span class="type">Int</span>,</span><br><span class="line">      seed: <span class="type">Long</span> = <span class="type">Random</span>.nextLong())</span><br><span class="line">    : (<span class="type">Array</span>[<span class="type">T</span>], <span class="type">Long</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> reservoir = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">T</span>](k)</span><br><span class="line">    <span class="comment">// Put the first k elements in the reservoir.</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; k &amp;&amp; input.hasNext) &#123;</span><br><span class="line">      <span class="keyword">val</span> item = input.next()</span><br><span class="line">      reservoir(i) = item</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have consumed all the elements, return them. Otherwise do the replacement.</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">       <span class="comment">// 如果分区的数据全部才完了,则返回结果</span></span><br><span class="line">      <span class="comment">// If input size &lt; k, trim the array to return only an array of input size.</span></span><br><span class="line">      <span class="keyword">val</span> trimReservoir = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">T</span>](i)</span><br><span class="line">      <span class="type">System</span>.arraycopy(reservoir, <span class="number">0</span>, trimReservoir, <span class="number">0</span>, i)</span><br><span class="line">      (trimReservoir, i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 如果数据还有剩余，则进行蓄水池采样</span></span><br><span class="line">      <span class="comment">// If input size &gt; k, continue the sampling process.</span></span><br><span class="line">      <span class="keyword">var</span> l = i.toLong</span><br><span class="line">      <span class="keyword">val</span> rand = <span class="keyword">new</span> <span class="type">XORShiftRandom</span>(seed)</span><br><span class="line">      <span class="keyword">while</span> (input.hasNext) &#123;</span><br><span class="line">        <span class="keyword">val</span> item = input.next()</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">        <span class="comment">// There are k elements in the reservoir, and the l-th element has been</span></span><br><span class="line">        <span class="comment">// consumed. It should be chosen with probability k/l. The expression</span></span><br><span class="line">        <span class="comment">// below is a random long chosen uniformly from [0,l)</span></span><br><span class="line">        <span class="comment">// 生成随机数</span></span><br><span class="line">        <span class="keyword">val</span> replacementIndex = (rand.nextDouble() * l).toLong</span><br><span class="line">        <span class="comment">// 如果随机数小于k， 则替代原来的元素</span></span><br><span class="line">        <span class="keyword">if</span> (replacementIndex &lt; k) &#123;</span><br><span class="line">          reservoir(replacementIndex.toInt) = item</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//返回结果</span></span><br><span class="line">      (reservoir, l)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对每个分区进行采样</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sketch</span></span>[<span class="type">K</span> : <span class="type">ClassTag</span>](</span><br><span class="line">     rdd: <span class="type">RDD</span>[<span class="type">K</span>],</span><br><span class="line">     sampleSizePerPartition: <span class="type">Int</span>): (<span class="type">Long</span>, <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">Long</span>, <span class="type">Array</span>[<span class="type">K</span>])]) = &#123;</span><br><span class="line">   <span class="keyword">val</span> shift = rdd.id</span><br><span class="line">   <span class="comment">// val classTagK = classTag[K] // to avoid serializing the entire partitioner object</span></span><br><span class="line">   <span class="keyword">val</span> sketched = rdd.mapPartitionsWithIndex &#123; (idx, iter) =&gt;</span><br><span class="line">     <span class="keyword">val</span> seed = byteswap32(idx ^ (shift &lt;&lt; <span class="number">16</span>))</span><br><span class="line">     <span class="keyword">val</span> (sample, n) = <span class="type">SamplingUtils</span>.reservoirSampleAndCount(</span><br><span class="line">       iter, sampleSizePerPartition, seed)</span><br><span class="line">     <span class="type">Iterator</span>((idx, n, sample))</span><br><span class="line">   &#125;.collect()</span><br><span class="line">   <span class="keyword">val</span> numItems = sketched.map(_._2).sum</span><br><span class="line">   (numItems, sketched)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分区边界问题</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">determineBounds</span></span>[<span class="type">K</span>: <span class="type">Ordering</span> : <span class="type">ClassTag</span>](</span><br><span class="line">      candidates: <span class="type">ArrayBuffer</span>[(<span class="type">K</span>, <span class="type">Float</span>)],</span><br><span class="line">      partitions: <span class="type">Int</span>): <span class="type">Array</span>[<span class="type">K</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> ordering = implicitly[<span class="type">Ordering</span>[<span class="type">K</span>]]</span><br><span class="line">    <span class="comment">// 按照数据进行数据排序，默认升序排列</span></span><br><span class="line">    <span class="keyword">val</span> ordered = candidates.sortBy(_._1)</span><br><span class="line">    <span class="comment">// 获取总的样本数量大小</span></span><br><span class="line">    <span class="keyword">val</span> numCandidates = ordered.size</span><br><span class="line">    <span class="comment">// 计算总的权重大小</span></span><br><span class="line">    <span class="keyword">val</span> sumWeights = ordered.map(_._2.toDouble).sum</span><br><span class="line">    <span class="comment">// 计算步长</span></span><br><span class="line">    <span class="keyword">val</span> step = sumWeights / partitions</span><br><span class="line">    <span class="keyword">var</span> cumWeight = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> target = step</span><br><span class="line">    <span class="keyword">val</span> bounds = <span class="type">ArrayBuffer</span>.empty[<span class="type">K</span>]</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> previousBound = <span class="type">Option</span>.empty[<span class="type">K</span>]</span><br><span class="line">    <span class="keyword">while</span> ((i &lt; numCandidates) &amp;&amp; (j &lt; partitions - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="comment">// 获取排序后的第i个数据及权重</span></span><br><span class="line">      <span class="keyword">val</span> (key, weight) = ordered(i)</span><br><span class="line">      <span class="comment">// 累计权重</span></span><br><span class="line">      cumWeight += weight</span><br><span class="line">      <span class="keyword">if</span> (cumWeight &gt;= target) &#123;</span><br><span class="line">        <span class="comment">// Skip duplicate values.</span></span><br><span class="line">        <span class="comment">// 权重已经达到一个步长的范围，计算出一个分区id的值</span></span><br><span class="line">        <span class="keyword">if</span> (previousBound.isEmpty || ordering.gt(key, previousBound.get)) &#123;</span><br><span class="line">          <span class="comment">// 上一个边界值为空，或者当前边界key数据大于上一个边界的值，那么当前key有效，进行计算</span></span><br><span class="line">          <span class="comment">// 添加当前key到边界集合中</span></span><br><span class="line">          bounds += key</span><br><span class="line">          <span class="comment">// 累计target步长界限</span></span><br><span class="line">          target += step</span><br><span class="line">          <span class="comment">// 分区数量加1</span></span><br><span class="line">          j += <span class="number">1</span></span><br><span class="line">          <span class="comment">// 上一个边界的值重置为当前边界的值</span></span><br><span class="line">          previousBound = <span class="type">Some</span>(key)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    bounds.toArray</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="默认分区器"><a href="#默认分区器" class="headerlink" title="默认分区器"></a>默认分区器</h4><p>当触发shuffle,但没有指定partitioner.spark会自动生成默认的分区器</p>
<p>首先去寻找父类rdd（注意不是所有祖先的rdd，而仅仅是上一级的rdd）的partitioner,则返回其中的最大partitioner (按照分区数量排序)</p>
<p>如果父类rdd没有指定partitioner,但是spark.default.parallelism有在配置中指定,则使用该数值,创建HashPartitioner</p>
<p>否则,就找到父类rdd的最大分区数目,使用该数值,创建HashPartitioner</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">defaultPartitioner</span></span>(rdd: <span class="type">RDD</span>[_], others: <span class="type">RDD</span>[_]*): <span class="type">Partitioner</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> rdds = (<span class="type">Seq</span>(rdd) ++ others)</span><br><span class="line">  <span class="keyword">val</span> hasPartitioner = rdds.filter(_.partitioner.exists(_.numPartitions &gt; <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">if</span> (hasPartitioner.nonEmpty) &#123;</span><br><span class="line">    hasPartitioner.maxBy(_.partitions.length).partitioner.get</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rdd.context.conf.contains(<span class="string">&quot;spark.default.parallelism&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">HashPartitioner</span>(rdd.context.defaultParallelism)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">HashPartitioner</span>(rdds.map(_.partitions.length).max)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Sample采样"><a href="#Sample采样" class="headerlink" title="Sample采样"></a>Sample采样</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">-- 参数withReplacement</span><br><span class="line">是否放回就是概论中中的放回抽样和不放回抽样</span><br><span class="line">-- 参数fraction表示抽样比例</span><br><span class="line"><span class="number">0</span>~<span class="number">1</span>之间的浮点数</span><br><span class="line">--参数seed</span><br><span class="line">随机种子</span><br><span class="line">--用于抽样排查数据倾斜问题</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>The Hadoop Ecosystem</category>
        <category>Learning Spark</category>
      </categories>
      <tags>
        <tag>Work Systematically</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark数据案例分析</title>
    <url>/2020/09/20/Spark-Simple-Case-Analysis/</url>
    <content><![CDATA[<h2 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h2><h5 id="案例一-连续登陆"><a href="#案例一-连续登陆" class="headerlink" title="案例一:连续登陆"></a>案例一:连续登陆</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ContinuouslandingRdd</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//p1,2020-12-1</span></span><br><span class="line">  <span class="comment">//p1,2020-12-2</span></span><br><span class="line">  <span class="comment">//p1,2020-12-3</span></span><br><span class="line">  <span class="comment">//p1,2020-12-4</span></span><br><span class="line">  <span class="comment">//p1,2020-12-6</span></span><br><span class="line">  <span class="comment">//p1,2020-12-7</span></span><br><span class="line">  <span class="comment">//p1,2020-12-11</span></span><br><span class="line">  <span class="comment">//p1,2020-12-13</span></span><br><span class="line">  <span class="comment">//p2,2020-12-01</span></span><br><span class="line">  <span class="comment">//p2,2020-12-13</span></span><br><span class="line">  <span class="comment">//p2,2020-12-13</span></span><br><span class="line">  <span class="comment">//p2,2020-12-14</span></span><br><span class="line">  <span class="comment">//p2,2020-12-15</span></span><br><span class="line">  <span class="comment">//p3,2020-12-15</span></span><br><span class="line">  <span class="comment">//p4,2020-12-15</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span>.getClass.getSimpleName).setMaster(<span class="string">&quot;local[*]&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.textFile(<span class="string">&quot;src/main/resources/date1.csv&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> maprdd: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = rdd.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> data = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">      (data(<span class="number">0</span>), data(<span class="number">1</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//思路groupbykey获取去重,按照时间戳排序的组,减去排序的序列化,如果相等就是连续登陆的</span></span><br><span class="line">    <span class="keyword">val</span> etlrdd: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">String</span>, <span class="type">String</span>))] = maprdd.groupByKey().flatMapValues(datas =&gt; &#123;</span><br><span class="line">      <span class="comment">//去重按照时间戳来排序</span></span><br><span class="line">      <span class="keyword">val</span> sort = datas.toSet.toList.sorted</span><br><span class="line">      <span class="keyword">val</span> sdf = <span class="keyword">new</span> <span class="type">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> calendar = <span class="type">Calendar</span>.getInstance()</span><br><span class="line">      <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">      sort.map(data =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> date: <span class="type">Date</span> = sdf.parse(data)</span><br><span class="line">        calendar.setTime(date)</span><br><span class="line">        calendar.add(<span class="type">Calendar</span>.<span class="type">DATE</span>, -index)</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        (data, sdf.format(calendar.getTime))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取连续登陆的开始时间,结束时间,以及练习登陆的天数</span></span><br><span class="line">   etlrdd.map (&#123;</span><br><span class="line">      <span class="keyword">case</span> (x, (y, z)) =&gt; ((x, z), y)</span><br><span class="line">    &#125;).groupByKey().mapValues(data =&gt; &#123;</span><br><span class="line">     <span class="keyword">val</span> sort = data.toList.sorted</span><br><span class="line">     <span class="keyword">val</span> first_time = sort.head</span><br><span class="line">     <span class="keyword">val</span> last_time = sort.last</span><br><span class="line">     <span class="keyword">val</span> lon = sort.size</span><br><span class="line">     (lon,first_time,last_time)</span><br><span class="line">   &#125;).filter(_._2._1 &gt;= <span class="number">3</span>).map(&#123;<span class="keyword">case</span>((x,y),(z,q,p)) =&gt; (x,q,p) &#125;).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(p2,2020-12-13,2020-12-15)</span></span><br><span class="line">    <span class="comment">//(p1,2020-12-2,2020-12-4)</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="案例二-分组转化"><a href="#案例二-分组转化" class="headerlink" title="案例二:分组转化"></a>案例二:分组转化</h5><img src="https://upload-images.jianshu.io/upload_images/9049859-1abe0dba802b79fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SQL转化" style="zoom:50%;" />

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分组转化案例</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">GroupedIntoRdd</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span>.getClass.getSimpleName).setMaster(<span class="string">&quot;local[*]&quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.textFile(<span class="string">&quot;src/main/resources/data.csv&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> maprdd = rdd.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> data = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">      (data(<span class="number">0</span>).toInt, (data(<span class="number">1</span>), data(<span class="number">2</span>), data(<span class="number">3</span>).toInt))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按id来分组处理</span></span><br><span class="line">    <span class="keyword">val</span> etlrdd = maprdd.groupByKey().flatMapValues(data =&gt; &#123;</span><br><span class="line">      <span class="comment">//下一条的begin_time - 上一条的end_time &gt; 10min再分一组</span></span><br><span class="line">      <span class="comment">//按照begin_time来排序</span></span><br><span class="line">      <span class="keyword">val</span> sort = data.toSet.toList.sorted</span><br><span class="line">      <span class="keyword">val</span> sdf = <span class="keyword">new</span> <span class="type">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm&quot;</span>)</span><br><span class="line">      <span class="keyword">var</span> flag = <span class="number">0</span> <span class="comment">// 0或者1 用来判断是否小于十分钟</span></span><br><span class="line">      <span class="keyword">var</span> sum = <span class="number">0</span> <span class="comment">//划分分组</span></span><br><span class="line">      <span class="keyword">var</span> temp_time = <span class="number">0</span>L <span class="comment">//接收上一个的end_time</span></span><br><span class="line">      sort.map(da =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> begin_time = sdf.parse(da._1).getTime</span><br><span class="line">        <span class="keyword">val</span> end_time = sdf.parse(da._2).getTime</span><br><span class="line">        <span class="keyword">if</span> (temp_time != <span class="number">0</span>L) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((begin_time - temp_time) / (<span class="number">1000</span> * <span class="number">60</span>) &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += flag</span><br><span class="line">        temp_time = end_time</span><br><span class="line">        (begin_time, end_time, da._3, sum)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).map(&#123; <span class="keyword">case</span> (x, (y, z, q, p)) =&gt; ((x, p), (y, z, q)) &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> value = etlrdd.reduceByKey((x, y) =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> min = <span class="type">Math</span>.min(x._2, y._2)</span><br><span class="line">      <span class="keyword">val</span> max = <span class="type">Math</span>.max(x._2, y._2)</span><br><span class="line">      <span class="keyword">var</span> sum = x._3 + y._3</span><br><span class="line">      (min, max, sum)</span><br><span class="line">    &#125;</span><br><span class="line">    ).mapPartitions(iter =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> sdf = <span class="keyword">new</span> <span class="type">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm&quot;</span>)</span><br><span class="line">      iter.map(data =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> start = sdf.format(data._2._1)</span><br><span class="line">        <span class="keyword">val</span> last = sdf.format(data._2._2)</span><br><span class="line">        ((data._1._1, start), (last, data._2._3))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).sortByKey()</span><br><span class="line">    value.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SparkSQL"><a href="#SparkSQL" class="headerlink" title="SparkSQL"></a>SparkSQL</h2><h5 id="案例一-连续登陆-1"><a href="#案例一-连续登陆-1" class="headerlink" title="案例一:连续登陆"></a>案例一:连续登陆</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ContinuouslandingSql</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="keyword">this</span>.getClass.getSimpleName).master(<span class="string">&quot;local[*]&quot;</span>).getOrCreate()</span><br><span class="line">    spark.read.csv(<span class="string">&quot;src/main/resources/date1.csv&quot;</span>).toDF(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;dt&quot;</span>).createTempView(<span class="string">&quot;Continuouslanding&quot;</span>)</span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |id,</span></span><br><span class="line"><span class="string">        |min(dt),</span></span><br><span class="line"><span class="string">        |max(dt),</span></span><br><span class="line"><span class="string">        |count(landing)</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |(</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |id,dt,</span></span><br><span class="line"><span class="string">        |date_sub(dt,rn) as landing</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |(</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |id,dt,</span></span><br><span class="line"><span class="string">        |row_number() over(partition by id order by dt) as rn</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |(</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |distinct id,dt</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |Continuouslanding</span></span><br><span class="line"><span class="string">        |) t1</span></span><br><span class="line"><span class="string">        |) t2</span></span><br><span class="line"><span class="string">        |) t3</span></span><br><span class="line"><span class="string">        |group by id , landing</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin).show(<span class="number">100</span>,<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="案例二-分组转化-1"><a href="#案例二-分组转化-1" class="headerlink" title="案例二:分组转化"></a>案例二:分组转化</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">-- begin_time - 上一个的end_time 大于<span class="number">6</span>分钟就重新分一组</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">GroupedIntoSql</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="keyword">this</span>.getClass.getSimpleName).master(<span class="string">&quot;local[*]&quot;</span>).getOrCreate()</span><br><span class="line">    <span class="keyword">val</span> schema = <span class="keyword">new</span> <span class="type">StructType</span>(<span class="type">Array</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;id&quot;</span>, <span class="type">DataTypes</span>.<span class="type">StringType</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;begin_time&quot;</span>, <span class="type">DataTypes</span>.<span class="type">StringType</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;end_time&quot;</span>, <span class="type">DataTypes</span>.<span class="type">StringType</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;down_flow&quot;</span>, <span class="type">DataTypes</span>.<span class="type">DoubleType</span>),</span><br><span class="line">    ))</span><br><span class="line">    <span class="keyword">val</span> frame = spark.read.format(<span class="string">&quot;csv&quot;</span>).schema(schema).load(<span class="string">&quot;C:\\Users\\hp\\IdeaProjects\\Spark_Maven\\src\\main\\resources\\data.csv&quot;</span>)</span><br><span class="line">    frame.createTempView(<span class="string">&quot;GroupedInto&quot;</span>)</span><br><span class="line"></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |id,</span></span><br><span class="line"><span class="string">        |min(begin_time) as begin_time,</span></span><br><span class="line"><span class="string">        |max(end_time) as end_time,</span></span><br><span class="line"><span class="string">        |sum(down_flow) as down_flow</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |(</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |id,begin_time,end_time,down_flow,</span></span><br><span class="line"><span class="string">        |sum(flag) over(partition by id order by begin_time </span></span><br><span class="line"><span class="string">        |rows between unbounded preceding and current row ) as sum_flag</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |(</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |id,begin_time,end_time,down_flow,</span></span><br><span class="line"><span class="string">        |if((to_unix_timestamp(begin_time,&#x27;yyyy/M/dd HH:mm&#x27;) -</span></span><br><span class="line"><span class="string">        |to_unix_timestamp(rn_time,&#x27;yyyy/M/dd HH:mm&#x27;) )&gt; 600, 1, 0) as flag</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |(</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |id,begin_time,end_time,down_flow,</span></span><br><span class="line"><span class="string">        |lag(end_time,1,begin_time) over(partition by id order by begin_time ) as rn_time</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |GroupedInto</span></span><br><span class="line"><span class="string">        |) t1</span></span><br><span class="line"><span class="string">        |) t2</span></span><br><span class="line"><span class="string">        |) t3</span></span><br><span class="line"><span class="string">        |group by id , sum_flag</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin).show(<span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><h5 id="案例一-连续登陆-2"><a href="#案例一-连续登陆-2" class="headerlink" title="案例一:连续登陆"></a>案例一:连续登陆</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ContinuouslandingDsl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="keyword">this</span>.getClass.getSimpleName).master(<span class="string">&quot;local[*]&quot;</span>).getOrCreate()</span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line">    <span class="keyword">val</span> dataFrame = spark.read.csv(<span class="string">&quot;src/main/resources/date1.csv&quot;</span>).toDF(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;dt&quot;</span>)</span><br><span class="line">    dataFrame</span><br><span class="line">      .distinct().select(</span><br><span class="line">      col(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">      , col(<span class="string">&quot;dt&quot;</span>)</span><br><span class="line">      , row_number().over(<span class="type">Window</span>.partitionBy(<span class="string">&quot;id&quot;</span>).orderBy(col(<span class="string">&quot;dt&quot;</span>))</span><br><span class="line">        .rowsBetween(<span class="type">Window</span>.unboundedPreceding, <span class="type">Window</span>.currentRow)) as <span class="string">&quot;rn&quot;</span></span><br><span class="line">    )</span><br><span class="line">      .select(</span><br><span class="line">        col(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">        , col(<span class="string">&quot;dt&quot;</span>)</span><br><span class="line">        , date_sub(col(<span class="string">&quot;dt&quot;</span>), col(<span class="string">&quot;rn&quot;</span>)) as <span class="string">&quot;date_rn&quot;</span></span><br><span class="line">        <span class="comment">//spark2.0不支持使用expr()</span></span><br><span class="line">      )</span><br><span class="line">      .groupBy(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;date_rn&quot;</span>)</span><br><span class="line">      .agg(</span><br><span class="line">        min(col(<span class="string">&quot;dt&quot;</span>)) as <span class="string">&quot;begin_time&quot;</span></span><br><span class="line">        , max(col(<span class="string">&quot;dt&quot;</span>)) as <span class="string">&quot;end_time&quot;</span></span><br><span class="line">        , count(col(<span class="string">&quot;date_rn&quot;</span>)) as <span class="string">&quot;number&quot;</span></span><br><span class="line">      )</span><br><span class="line">      .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;begin_time&quot;</span>, <span class="string">&quot;end_time&quot;</span>, <span class="string">&quot;number&quot;</span>)</span><br><span class="line">      <span class="comment">// .drop(col(&quot;date_rn&quot;))</span></span><br><span class="line">      .show(<span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="案例二-分组转化-2"><a href="#案例二-分组转化-2" class="headerlink" title="案例二:分组转化"></a>案例二:分组转化</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">GroupedIntoSqlDsl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="keyword">this</span>.getClass.getSimpleName).master(<span class="string">&quot;local[*]&quot;</span>).getOrCreate()</span><br><span class="line">    <span class="keyword">val</span> dataFrame = spark.read.csv(<span class="string">&quot;src/main/resources/data.csv&quot;</span>).toDF(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;begin_time&quot;</span>, <span class="string">&quot;end_time&quot;</span>, <span class="string">&quot;down_flow&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span>  spark.implicits._</span><br><span class="line">    <span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line">    dataFrame.selectExpr(</span><br><span class="line">      <span class="string">&quot;id&quot;</span></span><br><span class="line">      ,<span class="string">&quot;begin_time&quot;</span></span><br><span class="line">      ,<span class="string">&quot;end_time&quot;</span></span><br><span class="line">      ,<span class="string">&quot;down_flow&quot;</span></span><br><span class="line">      ,<span class="string">&quot;lag(end_time,1,begin_time) over(partition by id order by begin_time) as lag_time &quot;</span> )</span><br><span class="line">      .select(</span><br><span class="line">        <span class="symbol">&#x27;id</span></span><br><span class="line">        ,<span class="symbol">&#x27;begin_time</span></span><br><span class="line">        ,<span class="symbol">&#x27;end_time</span></span><br><span class="line">        ,<span class="symbol">&#x27;down_flow</span></span><br><span class="line">        <span class="comment">//if (unix_timestamp(&#x27;begin_time,&quot;yyyy/M/dd HH:mm&quot;)-unix_timestamp(col(&quot;lag_time&quot;),&quot;yyyy/M/dd HH:mm&quot;) &gt; 600 ,1,0)</span></span><br><span class="line">        ,expr(<span class="string">&quot;if((to_unix_timestamp(begin_time,&#x27;yyyy/M/dd HH:mm&#x27;)-to_unix_timestamp(lag_time ,&#x27;yyyy/M/dd HH:mm&#x27;))&gt;600,1,0)&quot;</span>) as <span class="string">&quot;flag&quot;</span></span><br><span class="line">      )</span><br><span class="line">      .select(</span><br><span class="line">         col(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">        ,col(<span class="string">&quot;begin_time&quot;</span>)</span><br><span class="line">        ,col(<span class="string">&quot;end_time&quot;</span>)</span><br><span class="line">        ,col(<span class="string">&quot;down_flow&quot;</span>)</span><br><span class="line">        ,sum(col(<span class="string">&quot;flag&quot;</span>)).over( <span class="type">Window</span>.partitionBy(col(<span class="string">&quot;id&quot;</span>)).orderBy(col(<span class="string">&quot;begin_time&quot;</span>)).rowsBetween(<span class="type">Window</span>.unboundedPreceding,<span class="type">Window</span>.currentRow)) as <span class="string">&quot;rn&quot;</span></span><br><span class="line">      )</span><br><span class="line">     .groupBy(col(<span class="string">&quot;id&quot;</span>),col(<span class="string">&quot;rn&quot;</span>))</span><br><span class="line">     .agg(</span><br><span class="line">       min(col(<span class="string">&quot;begin_time&quot;</span>)) as <span class="string">&quot;begin_time&quot;</span></span><br><span class="line">       ,max((col(<span class="string">&quot;end_time&quot;</span>))) as <span class="string">&quot;end_time&quot;</span></span><br><span class="line">       ,sum(col(<span class="string">&quot;down_flow&quot;</span>)) as <span class="string">&quot;down_flow&quot;</span></span><br><span class="line">       )</span><br><span class="line">       <span class="comment">//要是后面有select 则不需要使用drop来过滤字段了</span></span><br><span class="line">      .drop(col(<span class="string">&quot;rn&quot;</span>))</span><br><span class="line">      .orderBy(col(<span class="string">&quot;id&quot;</span>))</span><br><span class="line">      .select(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;begin_time&quot;</span>,<span class="string">&quot;end_time&quot;</span>,<span class="string">&quot;down_flow&quot;</span>)</span><br><span class="line">      .show(<span class="number">100</span>,<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="闭包-多线程问题"><a href="#闭包-多线程问题" class="headerlink" title="闭包/多线程问题"></a>闭包/多线程问题</h2><p>在driver端初始化了一个object或class实例,要在executor运行,必须实现序列化接口</p>
<p>如果实例是object类型,则每个executor共享一个,如果是class类型,及new了一个实例,则一个task一个实例</p>
<p>在函数中初始化实例,如果是单例的,则一个进程(executor)只有一个实例,如果是class类型,看调用的算子,如果是map,则没来一条数据就</p>
<p>new 一个,如果是mappartition,则一个分区一个实例</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多个线程共用一个变量,会出现线程安全问题</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DateUntil</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> format = <span class="keyword">new</span> <span class="type">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(st: <span class="type">String</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> date = format.parse(st)</span><br><span class="line">    date.getTime</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加锁改进</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DateUntil</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> format = <span class="keyword">new</span> <span class="type">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(st: <span class="type">String</span>): <span class="type">Long</span> = synchronized &#123;</span><br><span class="line">    <span class="keyword">val</span> date = format.parse(st)</span><br><span class="line">    date.getTime</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用mappartition一个分区一个simpledateformat</span></span><br><span class="line">rdd.mapPartitions(data =&gt; &#123;</span><br><span class="line">   <span class="keyword">val</span> format = <span class="keyword">new</span> <span class="type">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br><span class="line">    data.map(txt =&gt; &#123;</span><br><span class="line">     <span class="keyword">val</span> date = format.parse(txt)</span><br><span class="line">     date.getTime</span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>The Hadoop Ecosystem</category>
        <category>Learning Spark</category>
      </categories>
      <tags>
        <tag>Work Systematically</tag>
      </tags>
  </entry>
  <entry>
    <title>DP</title>
    <url>/2020/08/17/Dynamic-Planning/</url>
    <content><![CDATA[<h4 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *对于方程的描述</span></span><br><span class="line"><span class="comment"> *1.当物品或者容量某一项为空,装入的最大价值都为0</span></span><br><span class="line"><span class="comment"> *2.当遍历到第i类商品的重量大于给出的容量时,是无法装入第i类商品,沿用上一个过程的装入策略即:w[i] &gt; j v[i][j] = v[i-1] [j]</span></span><br><span class="line"><span class="comment"> *3.当遍历到第i类商品的重量是小于给出的容量时,就可以装入第i类商品,理解v[i-1][j-w[i]]</span></span><br><span class="line"><span class="comment"> *装入前i-1类商品到剩余的空间(容量)--&gt;j-wi,-&gt;解释是在剩余空间下i-1中类型商品情况下的选择策略 max&#123;&#125;理解为比较与上一个策略的容 </span></span><br><span class="line"><span class="comment"> *量,要此次策略要采取的..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProgramming</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*01背包问题</span></span><br><span class="line"><span class="comment">     * 分别有三个物品 要存放到背包(重量为4)中 计算最大的价值</span></span><br><span class="line"><span class="comment">     * 重量:1 4 3</span></span><br><span class="line"><span class="comment">     * 价值:1500 3000 2000</span></span><br><span class="line"><span class="comment">     * 动态规划例题</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] hight = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] value = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">4</span>;<span class="comment">//背包的容量</span></span><br><span class="line">        <span class="keyword">int</span> m = value.length;<span class="comment">//物品的个数</span></span><br><span class="line">        <span class="comment">//设置一个二维数组表示总价值 加一表示 物品或者容量为0情况</span></span><br><span class="line">        <span class="keyword">int</span>[][] val = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val.length; i++) &#123;</span><br><span class="line">            val[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            val[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; val.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; val[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hight[i - <span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">                    <span class="comment">//采用上一个的策略</span></span><br><span class="line">                    val[i][j] = val[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//对该函数的说明   val[i-1][j-hight[i]] 第i个商品的剩余容量</span></span><br><span class="line">                    val[i][j] = Math.max(val[i - <span class="number">1</span>][j], value[i - <span class="number">1</span>] + val[i - <span class="number">1</span>][j - hight[i - <span class="number">1</span>]]);</span><br><span class="line">                    <span class="comment">//value[i] 是必定能取到的  后一个[j-hight[i]]剩余的空间,后一个的描述是,只有</span></span><br><span class="line">                    <span class="comment">//[j-hight[i]]空间 遍历到val[i]种类型的选择策略</span></span><br><span class="line">                    <span class="comment">//商品的类型是不断增加的</span></span><br><span class="line">                    <span class="comment">//原来函数的标准式:val[i][j] =  Math.max(val[i-1][j] , value[i] + val[i-1][j-hight[i]])</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; val[<span class="number">0</span>].length; i1++) &#123;</span><br><span class="line">                System.out.print(Integer.toString(val[i][i1]) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProgramming1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment">     * Description:</span></span><br><span class="line"><span class="comment">     * User: tongyongtao</span></span><br><span class="line"><span class="comment">     * Date: 2020-10-12</span></span><br><span class="line"><span class="comment">     * Time: 19:16</span></span><br><span class="line"><span class="comment">     * 重量:1 4 3</span></span><br><span class="line"><span class="comment">     * 价值:1500 3000 2000</span></span><br><span class="line"><span class="comment">     * 优化求出最后结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储每种商品的重量</span></span><br><span class="line">        <span class="keyword">int</span>[] weight = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">//存储每种商品的价格</span></span><br><span class="line">        <span class="keyword">int</span>[] value = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;;</span><br><span class="line">        <span class="comment">//背包的容量是4</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//构建一个二维数组用来表示每次选择的价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] val = <span class="keyword">new</span> <span class="keyword">int</span>[weight.length + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化val[][0] val[0][];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val.length; i++) &#123;</span><br><span class="line">            val[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            val[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于第一行和第一列都进行的赋值,所以从1开始遍历</span></span><br><span class="line">        <span class="comment">//假设第i个商品的重量是大于本次的容量的则采取上一次的策略</span></span><br><span class="line">        <span class="comment">//如果是小于本次容量的则进行比较   //上一次的策略和本次可以容纳的策略</span></span><br><span class="line">        <span class="comment">//构建方程 max&#123;val[i-1][j] , value[i] + val[i-1][j - weight[i]] &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//建一个数组来记录信息</span></span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[value.length + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; val.length; i++) &#123;</span><br><span class="line">            <span class="comment">//容量每次递增</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; val[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">//本次商品种类的重量是大于本次的容量的,选择的策略是上一次的</span></span><br><span class="line">                <span class="comment">//此处索引从1开始的</span></span><br><span class="line">                <span class="keyword">if</span> (weight[i - <span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">                    val[i][j] = val[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                  <span class="comment">/* else &#123;</span></span><br><span class="line"><span class="comment">                        //是可以采用本次商品的,策略是与上一次进行比较</span></span><br><span class="line"><span class="comment">                       val[i][j] = Math.max(val[i-1][j] , value[i-1] +val[i-1][j -weight[i-1]] );</span></span><br><span class="line"><span class="comment">                   &#125;*/</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (val[i - <span class="number">1</span>][j] &lt; value[i - <span class="number">1</span>] + val[i - <span class="number">1</span>][j - weight[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                    val[i][j] = value[i - <span class="number">1</span>] + val[i - <span class="number">1</span>][j - weight[i - <span class="number">1</span>]];</span><br><span class="line">                    path[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    val[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; val[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(val[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从上往下遍历获取最后一次的背包存储情况</span></span><br><span class="line">        <span class="keyword">int</span> i = path.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = path[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//索引从一开始</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;%d放入背包&quot;</span>, i);</span><br><span class="line">                <span class="comment">//背包的容量被占据</span></span><br><span class="line">                j -= weight[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="斐波那契问题"><a href="#斐波那契问题" class="headerlink" title="斐波那契问题"></a>斐波那契问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(fibonacci(<span class="number">12</span>));</span><br><span class="line">        System.out.println(fibonacci1(<span class="number">12</span>));</span><br><span class="line">        System.out.println(fibonacci2(<span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归实现</span></span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">1</span> || number == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fibonacci(number - <span class="number">1</span>) + fibonacci(number - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacci1</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//考虑建立一个数组存放所有的状态</span></span><br><span class="line">        <span class="comment">//注意容量和索引的不同</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[number];</span><br><span class="line">        <span class="comment">//初始化0 ,1</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; number; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[number-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划,考虑压缩</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacci2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两个变量接收遍历的值</span></span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> second = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= number; i++) &#123;</span><br><span class="line">              <span class="keyword">int</span> tmp = first + second;</span><br><span class="line">              first = second;</span><br><span class="line">              second = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClimbStairs</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment">     * Description:</span></span><br><span class="line"><span class="comment">     * User: tongyongtao</span></span><br><span class="line"><span class="comment">     * Date: 2020-10-11</span></span><br><span class="line"><span class="comment">     * Time: 20:27</span></span><br><span class="line"><span class="comment">     * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span></span><br><span class="line"><span class="comment">     * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span></span><br><span class="line"><span class="comment">     * f(x)=f(x−1)+f(x−2)</span></span><br><span class="line"><span class="comment">     * 动态规划和递归法的区别: 自下而上 自上而下</span></span><br><span class="line"><span class="comment">     * 注意滚动数组的应用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        climbStairs(<span class="number">12</span>);</span><br><span class="line">        System.out.println(climbStairs1(<span class="number">12</span>));</span><br><span class="line">        System.out.println(climbStairs2(<span class="number">12</span>));</span><br><span class="line">        System.out.println(climbStairs3(<span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//滚动数组方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//f(0)=1</span></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp的优化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//tmp只是一个临时变量,用来存储cur的值,然后赋值给prev</span></span><br><span class="line">            <span class="keyword">int</span> tmp = cur;</span><br><span class="line">            cur = prev + cur;</span><br><span class="line">            prev = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs3</span><span class="params">(<span class="keyword">int</span> ints)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ints &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ints;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> climbStairs3(ints - <span class="number">1</span>) + climbStairs3(ints - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="买卖股票的时机I"><a href="#买卖股票的时机I" class="headerlink" title="买卖股票的时机I"></a>买卖股票的时机I</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-13</span></span><br><span class="line"><span class="comment"> * Time: 20:25</span></span><br><span class="line"><span class="comment"> * 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span></span><br><span class="line"><span class="comment"> * 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</span></span><br><span class="line"><span class="comment"> * 注意：你不能在买入股票前卖出股票。</span></span><br><span class="line"><span class="comment"> * 例如: [7,1,5,3,6,4] 输出是5;</span></span><br><span class="line"><span class="comment"> * 说明过程:</span></span><br><span class="line"><span class="comment"> * 7 1 5 3 6 4</span></span><br><span class="line"><span class="comment"> * 0 0 4 4 5 5</span></span><br><span class="line"><span class="comment"> * -7 -1 -1 -1 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxProfit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(maxProfit1(ints));</span><br><span class="line">        System.out.println(maxProfit2(ints));</span><br><span class="line">        System.out.println(maxProfit3(ints));</span><br><span class="line">        System.out.println(maxProfit4(ints));</span><br><span class="line">        System.out.println(maxProfit5(ints));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一 暴力匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = prices[j] - prices[i];</span><br><span class="line">                <span class="keyword">if</span> (tmp &gt; maxProfit) maxProfit = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二 获取最小值和与最大值的差值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minProfit = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>; <span class="comment">//最大的差值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minProfit) minProfit = prices[i];  <span class="comment">//获取最小值</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] - minProfit &gt; maxProfit) maxProfit = prices[i] - minProfit;<span class="comment">//获取最大的正差值,先买后卖原则</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法三 比较简易的动态规划</span></span><br><span class="line">    <span class="comment">//构建方程 max = &#123;f(x),f(x-1)&#125;//f(x-1)是上一次的策略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit3</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最小的值</span></span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//最大的差值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; min) &#123;</span><br><span class="line">                max = Math.max(max, prices[i] - min);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//因为这里 prices[i]是小于min的 替换</span></span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法四 较为复杂的动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit4</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//说明:构建两个数组 sell 和 buy</span></span><br><span class="line">        <span class="comment">//对sell的说明:基于上一次策略 如果在本次策略买入会盈利的多少</span></span><br><span class="line">        <span class="comment">//对buy的说明基于本次策略,买入盈利的多少</span></span><br><span class="line">        <span class="keyword">int</span>[] sell = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">int</span>[] buy = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="comment">//初始化 sell buy</span></span><br><span class="line">        sell[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            sell[i] = Math.max(sell[i - <span class="number">1</span>], buy[i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">            buy[i] = Math.max(buy[i - <span class="number">1</span>], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次选择的策略是基于上一次的选择策略,如果在比较之后是亏损的,则结果是继承的,</span></span><br><span class="line">        <span class="comment">//sell的原则是 与上一次sell的收益相比 本次卖出的收益与上次买入股票价格的差值(buy的值)</span></span><br><span class="line">        <span class="comment">//buy 的原则是 与上一次策略(股票价格的差值)</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(sell[prices.length - <span class="number">1</span>], buy[prices.length - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法五 对方法四的优化 滚动法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit5</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">//sell</span></span><br><span class="line">            dp = Math.max(dp, dp1 + prices[i]);</span><br><span class="line">            <span class="comment">//buy</span></span><br><span class="line">            dp1 = Math.max(dp1,-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp,dp1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="买卖股票的时机II"><a href="#买卖股票的时机II" class="headerlink" title="买卖股票的时机II"></a>买卖股票的时机II</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-19</span></span><br><span class="line"><span class="comment"> * Time: 20:04</span></span><br><span class="line"><span class="comment"> * 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span></span><br><span class="line"><span class="comment"> * 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</span></span><br><span class="line"><span class="comment"> * 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxProfit2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">1</span> | prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置两个中间变量接收区域最大最小值</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            tmp = prices[i];</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; prices[i - <span class="number">1</span>] &amp;&amp; tmp &lt; prices[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                min = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmp &gt; prices[i - <span class="number">1</span>] &amp;&amp; tmp &gt; prices[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                max = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            num += max - min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//特例递增 和 递减</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//一次遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">//只要小于就买,否则不买</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; prices[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                sum += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//峰谷法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//要获取峰和谷</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; prices.length - <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt; prices.length - <span class="number">1</span> &amp;&amp; prices[i] &gt;= prices[i + <span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">            min = prices[i];</span><br><span class="line">            <span class="comment">//获取区域最大</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; prices.length - <span class="number">1</span> &amp;&amp; prices[i] &lt;= prices[i + <span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">            max = prices[i];</span><br><span class="line">            sum += max - min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//0表示持有现金 1表示持有股票</span></span><br><span class="line">    <span class="comment">//定义一个二维数组</span></span><br><span class="line">    <span class="comment">// int[][] dp = new int[][]; 第一项表示收益  第二项表示状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit3</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对初始状态的定义</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">//是否持现金要看当前现金 和股票卖出去的收益比值</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意  new int[prices.length][2];  dp[prices.length-1][0];数的区别....经常搞错</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同样可使用两个数组 或者滚动数组方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit4</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义持有现金和股票</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">int</span> cash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> stock = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> preCash = cash;</span><br><span class="line">        <span class="keyword">int</span> preStock = stock;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            cash = Math.max(preCash, preStock + prices[i]);</span><br><span class="line">            stock = Math.max(stock, preCash - prices[i]);</span><br><span class="line">            <span class="comment">//赋值上一项</span></span><br><span class="line">            preCash = cash;</span><br><span class="line">            preStock = stock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cash;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit5</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] cash = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">int</span>[] stock = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        cash[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        stock[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">             cash[i] = Math.max(cash[i-<span class="number">1</span>] ,stock[i-<span class="number">1</span>] + prices[i]);</span><br><span class="line">             stock[i] = Math.max(stock[i-<span class="number">1</span>],cash[i-<span class="number">1</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cash[prices.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User:</span></span><br><span class="line"><span class="comment"> * Date: 2020-11-11</span></span><br><span class="line"><span class="comment"> * Time: 22:16</span></span><br><span class="line"><span class="comment"> * 先看下题目：给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，</span></span><br><span class="line"><span class="comment"> * 每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚</span></span><br><span class="line"><span class="comment"> * 硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * coins 中是可选硬币面值，amount 是目标金额</span></span><br><span class="line"><span class="comment"> * int coinChange(int[] coins, int amount);</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * k = 3，面值分别为 1，2，5，总金额 amount = 11。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeTheChange</span> </span>&#123;</span><br><span class="line">    <span class="comment">//较好的说明</span></span><br><span class="line">    <span class="comment">//最后一个硬币是1的话，最少硬币数应该为【组成10的最少硬币数】+ 1枚（1块硬币）</span></span><br><span class="line">    <span class="comment">//最后一个硬币是2的话，最少硬币数应该为【组成9的最少硬币数】+ 1枚（2块硬币）</span></span><br><span class="line">    <span class="comment">//最后一个硬币是5的话，最少硬币数应该为【组成6的最少硬币数】+ 1枚（5块硬币）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(coinChange(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;, <span class="number">11</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断数组的容量和金额大小</span></span><br><span class="line">        <span class="keyword">if</span> (coins.length &lt;= <span class="number">0</span> || amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (amount ==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="comment">//考虑建立一个数组存放每个状态的值,表示dp[i] 要取出金额为i 需要的金币的最小的数量</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i] = <span class="number">99999</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= coin) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i - coin] + <span class="number">1</span>, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = dp[amount] == <span class="number">99999</span> ? -<span class="number">1</span>:dp[amount];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthOfLIS</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment">     * Description:</span></span><br><span class="line"><span class="comment">     * User:</span></span><br><span class="line"><span class="comment">     * Date: 2020-11-12</span></span><br><span class="line"><span class="comment">     * Time: 21:26</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; inte = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        inte.add(<span class="number">1</span>);</span><br><span class="line">        inte.add(<span class="number">2</span>);</span><br><span class="line">        inte.add(<span class="number">3</span>);</span><br><span class="line">        inte.add(<span class="number">4</span>);</span><br><span class="line">        inte.add(<span class="number">5</span>);</span><br><span class="line">        inte.add(<span class="number">6</span>);</span><br><span class="line">        inte.add(<span class="number">8</span>);</span><br><span class="line">        inte.forEach(System.out::println);</span><br><span class="line">        <span class="comment">//(-(插入点) - 1)。插入点 被定义为将键插入列表的那一点：即第一个大于此键的元素索引</span></span><br><span class="line">        System.out.println(Collections.binarySearch(inte, <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先边界条件的确定</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑就一个数组用来存放状态值,对数组的余地,dp[i] = number 第多少个数的最长上升子序列</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//考虑最小的长度为一,初始化数组</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//怎么确定转移方程,既是我们知道dp[i-1] 怎么求dp[i]</span></span><br><span class="line">        <span class="comment">//我们只要找到前面的子问题中最后一位比dp[i]小的最大子问题即可+1</span></span><br><span class="line">        <span class="comment">//使用一个循环求取所有的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">//这里的判断是求取的关键</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组中最大的状态就是最长的最长上升子序列</span></span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            tmp = Math.max(dp[i], tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLIS1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用二分查找</span></span><br><span class="line">        <span class="comment">//思路建立一个集合,首先存储第一次的数,以及如果某前面的数小于后面的数直接添加到集合中</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(nums.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">//集合的长度为0的时候或者前面的数小于后面的数就添加到集合中</span></span><br><span class="line">            <span class="keyword">if</span> (list.size() == <span class="number">0</span> || list.get(list.size() - <span class="number">1</span>) &lt; num) &#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//二分法 binarySearch返回值是第一个大于它的索引</span></span><br><span class="line">                <span class="comment">// (-(插入点) - 1)。插入点 被定义为将键插入列表的那一点：即第一个大于此键的元素索引</span></span><br><span class="line">                <span class="keyword">int</span> i = Collections.binarySearch(list, num);</span><br><span class="line">                <span class="comment">//如果i&gt;0 说明本来就存在直接替换即可 ,如果小于取反减去1</span></span><br><span class="line">                list.set((i &lt; <span class="number">0</span>) ? -i-<span class="number">1</span> : i , num);</span><br><span class="line">                 <span class="comment">//下面的这种写法通过不了</span></span><br><span class="line">               <span class="comment">// list.set((i &gt; 0) ? i : -i - 1, num);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="type">Arithmetic</span>.<span class="type">DynamicPlanning</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最长回文子串</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LongestPalindrome</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(longestPalindrome(<span class="string">&quot;cbbd&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span></span>(s: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> length = s.length</span><br><span class="line">    <span class="comment">//特例处理</span></span><br><span class="line">    <span class="keyword">if</span> (s.length &lt; <span class="number">2</span>) <span class="keyword">return</span> s.charAt(<span class="number">0</span>) + <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment">//定义接收回文的长度和qishiweizhi</span></span><br><span class="line">    <span class="keyword">var</span> len = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> first = <span class="number">0</span></span><br><span class="line">    <span class="comment">//创建二维布尔数组</span></span><br><span class="line">    <span class="keyword">var</span> array = <span class="type">Array</span>.ofDim[<span class="type">Boolean</span>](length, length)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until length) &#123;</span><br><span class="line">      array(i)(i) = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对角线必然是true,从1开始,先列-&gt;行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j &lt;- <span class="number">1</span> until length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">          array(i)(j) = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//表达式 [i + 1, j - 1] 不构成区间，即长度严格小于 2</span></span><br><span class="line">           <span class="keyword">if</span> (j - i  &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            array(i)(j) = <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果外面的相等则比较里面的里面的</span></span><br><span class="line">            array(i)(j) = array(i + <span class="number">1</span>)(j - <span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取值</span></span><br><span class="line">        <span class="keyword">if</span> (array(i)(j)  &amp;&amp; (j - i +<span class="number">1</span> &gt; len)) &#123;</span><br><span class="line">          len = j - i + <span class="number">1</span></span><br><span class="line">          first = i</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">          s.substring(first,first+len)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubArray</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 给定一个整数数组 nums ，找到一个具有最大和的连续子数组</span></span><br><span class="line"><span class="comment">     * （子数组最少包含一个元素），返回其最大和</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 思想:相加数组中的所有元素,直到遇到一个比这个和还要大的元素,舍弃这个和,重新求和,反复进行</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        maxSubArray1(nums);</span><br><span class="line">        maxSubArray2(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//f(i)=max&#123;f(i−1)+a 转移方程 滚动思想</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxSubArray1</span><span class="params">(<span class="keyword">int</span>[] ints)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//索引 0-ints.lenth</span></span><br><span class="line">        <span class="comment">//用来接收和</span></span><br><span class="line">        <span class="keyword">if</span> (ints.length==<span class="number">0</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//最大的值</span></span><br><span class="line">        <span class="keyword">int</span> max = ints[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : ints) &#123;</span><br><span class="line">            <span class="comment">//转移方程,如果前面的和小于x,则舍弃前面的所有数</span></span><br><span class="line">            sum = Math.max(sum + x, x);</span><br><span class="line">            <span class="comment">//比较与赋值</span></span><br><span class="line">            max = Math.max(sum, max);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxSubArray2</span><span class="params">(<span class="keyword">int</span>[] ints)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> length = ints.length;</span><br><span class="line">        <span class="comment">//构建一个dp存放以ints[i]为结尾最大子序</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        dp[<span class="number">0</span>] = ints[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 取当前元素的值 和 当前元素的值加上一次结果的值中最大数</span></span><br><span class="line">            dp[i] = Math.max(ints[i], dp[i - <span class="number">1</span>] + ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历dp数据获取最大的最大子序</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : dp) &#123;</span><br><span class="line">            max = Math.max(max, x);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转移方程的推导</span></span><br><span class="line"><span class="comment">//当最后两个字符相等的时，即 dp[i][j] = dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">//当 s 的长度为 i - 1,t 的长度为 j - 1 时</span></span><br><span class="line"><span class="comment">//若 s 为   t 的子序列，则当 s 的长度为 i ,t 的长度为 j 时，s 也为   t 的子序列</span></span><br><span class="line"><span class="comment">//若 s 不为 t 的子序列，则当 s 的长度为 i ,t 的长度为 j 时，s 也不为 t 的子序列</span></span><br><span class="line"><span class="comment">//当最后两个字符串不相等时，即 dp[i][j] = dp[i][j - 1]</span></span><br><span class="line"><span class="comment">//当 s 的长度为 i,t 的长度为 j - 1 时</span></span><br><span class="line"><span class="comment">//若 s 为   t 的子序列，则为 t 则加一个字符之后，s 的长度为 i ,t 的长度为 j 时，s 也为   t 的子序列</span></span><br><span class="line"><span class="comment">//若 s 不为 t 的子序列，则为 t 则加一个字符之后，s 的长度为 i ,t 的长度为 j 时，s 也为   t 的子序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span></span>(s: <span class="type">String</span>, t: <span class="type">String</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sl = s.length</span><br><span class="line">    <span class="keyword">val</span> tl = t.length</span><br><span class="line">    <span class="keyword">if</span> (sl == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (sl &gt; tl) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> dp = <span class="type">Array</span>.ofDim[<span class="type">Boolean</span>](sl + <span class="number">1</span>, tl + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to tl) &#123;</span><br><span class="line">      dp(<span class="number">0</span>)(i) = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (x &lt;- <span class="number">1</span> to sl; y &lt;- <span class="number">1</span> to tl) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.charAt(x - <span class="number">1</span>) == t.charAt(y - <span class="number">1</span>)) &#123;</span><br><span class="line">        dp(x)(y) = dp(x - <span class="number">1</span>)(y - <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        dp(x)(y) = dp(x)(y - <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(sl)(tl)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="跳跃游戏I"><a href="#跳跃游戏I" class="headerlink" title="跳跃游戏I"></a>跳跃游戏I</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CanJump</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(canJump(<span class="type">Array</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>)))</span><br><span class="line">    println(canJump1(<span class="type">Array</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">canJump</span></span>(nums: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Boolean</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一,从前往后跳</span></span><br><span class="line">    <span class="comment">//思路,某一步能跳的最大步径途中的所有经过的数,取最大的步径</span></span><br><span class="line">    <span class="comment">//设置一个val 接收跳到的最大位置</span></span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until nums.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      max = <span class="type">Math</span>.max(max, i + nums(i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max &gt;= nums.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">canJump1</span></span>(nums: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    <span class="comment">//从后往前</span></span><br><span class="line">    <span class="comment">//思路,如果倒数第二个能到达,则能到达</span></span><br><span class="line">        <span class="comment">//表示数组的最后一个元素</span></span><br><span class="line">    <span class="keyword">var</span> last = nums.length - <span class="number">1</span></span><br><span class="line">    <span class="comment">//逆向遍历,如果不存在就继续遍历</span></span><br><span class="line">     <span class="keyword">for</span> (i &lt;- (<span class="number">0</span> to  nums.length<span class="number">-2</span>).reverse )&#123;</span><br><span class="line">           println(i)</span><br><span class="line">           <span class="keyword">if</span> ((i + nums(i)&gt;last))&#123;</span><br><span class="line">               last = i</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">return</span>  last ==<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span></span>(cost: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="comment">//踏上topi 有两种选择 踏上前 min(i-2) + cost(i-1) 和 min(i-1) + cost(i)</span></span><br><span class="line">  <span class="comment">//考虑一个数组存放中间值</span></span><br><span class="line">  <span class="keyword">val</span> array = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](cost.length)</span><br><span class="line">  array(<span class="number">0</span>) = <span class="number">0</span></span><br><span class="line">  array(<span class="number">1</span>) = cost(<span class="number">1</span>).min(cost(<span class="number">0</span>))</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">2</span> until cost.length) &#123;</span><br><span class="line">    array(i) = (array(i - <span class="number">2</span>) + cost(i - <span class="number">1</span>)).min((array(i - <span class="number">1</span>) + cost(i)))</span><br><span class="line">  &#125;</span><br><span class="line">  array(cost.length - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs1</span></span>(cost: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line">   <span class="comment">//简单优化</span></span><br><span class="line">   <span class="keyword">var</span> min1 = <span class="number">0</span></span><br><span class="line">   <span class="keyword">var</span> min2 = cost(<span class="number">0</span>).min(cost(<span class="number">1</span>))</span><br><span class="line">   <span class="keyword">var</span> minresult = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> (i &lt;- <span class="number">2</span> until cost.length) &#123;</span><br><span class="line">     minresult = <span class="type">Math</span>.min(min1 + cost(i - <span class="number">1</span>), min2 + cost(i))</span><br><span class="line">     min1 = min2</span><br><span class="line">     min2 = minresult</span><br><span class="line">   &#125;</span><br><span class="line">   minresult</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//与上一种方法的区别在于是否包含i</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs2</span></span>(cost: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="comment">//要到达topi 则要比较 minresult(i-1) + cost(i) 和 minresult(i-2) + cost (i)</span></span><br><span class="line">  <span class="keyword">var</span> min1 = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> min2 = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">  cost.foreach(</span><br><span class="line">    data =&gt; &#123;</span><br><span class="line">      result = min1.min(min2) + data</span><br><span class="line">      min1 = min2</span><br><span class="line">      min2 = result</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">   min1.min(min2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs3</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length];</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; cost.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">2</span>], dp[i - <span class="number">1</span>]) + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[cost.length - <span class="number">2</span>], dp[cost.length - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影</span></span><br><span class="line"><span class="comment">// 响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span></span><br><span class="line"><span class="comment">//给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span></span><br><span class="line"><span class="comment">//输入：[2,7,9,3,1]</span></span><br><span class="line"><span class="comment">//输出：12</span></span><br><span class="line"><span class="comment">//解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span></span><br><span class="line"><span class="comment">//     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Rob</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">rob</span></span>(nums: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Int</span> = &#123;</span><br><span class="line">       <span class="keyword">if</span>(nums == <span class="literal">null</span> ||   nums.length ==<span class="number">0</span>) <span class="keyword">return</span>  <span class="number">0</span></span><br><span class="line">       <span class="keyword">if</span> (nums.length==<span class="number">1</span>)  <span class="keyword">return</span>    nums(<span class="number">0</span>)</span><br><span class="line">       <span class="keyword">var</span> a :<span class="type">Int</span> = nums(<span class="number">0</span>)</span><br><span class="line">       <span class="keyword">var</span> b :<span class="type">Int</span> = <span class="type">Math</span>.max(nums(<span class="number">0</span>),nums(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (i &lt;- <span class="number">2</span>  until  nums.length)&#123;</span><br><span class="line">                  <span class="keyword">var</span> tmp :<span class="type">Int</span> =  b</span><br><span class="line">                  b  = <span class="type">Math</span>.max(a+nums(i),b)</span><br><span class="line">                  a = tmp</span><br><span class="line">          &#125;</span><br><span class="line">           b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rob1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">37</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Rob1().rob1(ints));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//要判断是否为null 和 为 0</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">1</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用滚动数组方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//视为n-1项</span></span><br><span class="line">        <span class="keyword">int</span> first = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> second = Math.max(nums[<span class="number">1</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">               <span class="keyword">int</span>  tmp =  second;</span><br><span class="line">               <span class="comment">//这是结果</span></span><br><span class="line">               second = Math.max(first + nums[i],second);</span><br><span class="line">               first = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  second;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util</span><br><span class="line"><span class="comment">//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</span></span><br><span class="line"><span class="comment">//机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</span></span><br><span class="line"><span class="comment">//问总共有多少条不同的路径？</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">UniquePaths</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(uniquePaths1(<span class="number">3</span>, <span class="number">7</span>))</span><br><span class="line">    println(uniquePaths2(<span class="number">3</span>, <span class="number">7</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span></span>(m: <span class="type">Int</span>, n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="type">Array</span>.ofDim[<span class="type">Boolean</span>](m, n)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to m - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j &lt;- <span class="number">0</span> to n - <span class="number">1</span>) &#123;</span><br><span class="line">        array(i)(j) = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- array) &#123;</span><br><span class="line">      println(i.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths1</span></span>(m: <span class="type">Int</span>, n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> array = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](m, n)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until m) &#123;</span><br><span class="line">      array(i)(<span class="number">0</span>) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until n) &#123;</span><br><span class="line">      array(<span class="number">0</span>)(i) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> until m) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j &lt;- <span class="number">1</span> until n) &#123;</span><br><span class="line">        array(i)(j) = array(i - <span class="number">1</span>)(j) + array(i)(j - <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    array(m - <span class="number">1</span>)(n - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths2</span></span>(m: <span class="type">Int</span>, n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](n)</span><br><span class="line">    util.<span class="type">Arrays</span>.fill(array, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> until m) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j &lt;- <span class="number">1</span> until n) &#123;</span><br><span class="line">        array(j) += array(j - <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    array(n - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Computer engineering</category>
        <category>Arithmetic</category>
      </categories>
      <tags>
        <tag>Reading Books</tag>
        <tag>Sorting and Searching Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache-Hbase-API</title>
    <url>/2020/11/15/In-common-use-Apache-Hbase-API/</url>
    <content><![CDATA[<h1 id="Apache-Hbase"><a href="#Apache-Hbase" class="headerlink" title="Apache Hbase"></a>Apache Hbase</h1><p>HbaseUtils</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Connection;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-11-06</span></span><br><span class="line"><span class="comment"> * Time: 20:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HbaseUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Configuration configuration;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">        configuration = HBaseConfiguration.create();</span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="string">&quot;linux03,linux04,linux05&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (connection.isClosed() &amp;&amp; connection== null)</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="DDLTable"><a href="#DDLTable" class="headerlink" title="DDLTable"></a>DDLTable</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.NamespaceDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.TableName;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-11-06</span></span><br><span class="line"><span class="comment"> * Time: 20:34</span></span><br><span class="line"><span class="comment"> * DDL语法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DDLTable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(createTable(&quot;tab_111&quot;, &quot;f1&quot;, &quot;f2&quot;));</span></span><br><span class="line">        <span class="comment">// System.out.println(isTableExist(&quot;tab_1&quot;));</span></span><br><span class="line">       <span class="comment">// System.out.println(addFamily(&quot;tab_1&quot;, &quot;f3&quot;));</span></span><br><span class="line">        <span class="comment">//System.out.println(dropTable(&quot;tab_1&quot;));</span></span><br><span class="line">        System.out.println(createNamespace(<span class="string">&quot;myspace&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断表是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">isTableExist</span><span class="params">(String tableName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        <span class="comment">//对表的操作</span></span><br><span class="line">        Admin admin = connection.getAdmin();</span><br><span class="line">        <span class="keyword">return</span> admin.tableExists(TableName.valueOf(tableName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">createTable</span><span class="params">(String tableName, String... cfs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        <span class="comment">//首先判断表是否存在</span></span><br><span class="line">        <span class="comment">//判断列族是否为空</span></span><br><span class="line">        <span class="comment">//发现一个错误,竟然没写!  查了好久</span></span><br><span class="line">        <span class="keyword">if</span> (!isTableExist(tableName)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cfs.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                Admin admin = connection.getAdmin();</span><br><span class="line">                <span class="comment">//采用工厂方法</span></span><br><span class="line">                TableDescriptorBuilder tableDescriptorBuilder = TableDescriptorBuilder.newBuilder(TableName.valueOf(tableName));</span><br><span class="line">                <span class="comment">//添加列族</span></span><br><span class="line">                <span class="keyword">for</span> (String cf : cfs) &#123;</span><br><span class="line">                    ColumnFamilyDescriptorBuilder columnFamily = ColumnFamilyDescriptorBuilder.newBuilder(cf.getBytes());</span><br><span class="line">                    tableDescriptorBuilder.setColumnFamily(columnFamily.build());</span><br><span class="line">                &#125;</span><br><span class="line">                admin.createTable(tableDescriptorBuilder.build());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">createTable1</span><span class="params">(String table, String... cfs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        <span class="comment">//判断列族是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (cfs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断表是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (isTableExist(table)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Admin admin = connection.getAdmin();</span><br><span class="line">        <span class="comment">//表的构建</span></span><br><span class="line">        TableDescriptorBuilder tableDescriptorBuilder = TableDescriptorBuilder.newBuilder(TableName.valueOf(table));</span><br><span class="line">        <span class="comment">//列族的构建</span></span><br><span class="line">        <span class="keyword">for</span> (String cf : cfs) &#123;</span><br><span class="line">            ColumnFamilyDescriptorBuilder columnFamilyDescriptorBuilder = ColumnFamilyDescriptorBuilder.newBuilder(cf.getBytes());</span><br><span class="line">            tableDescriptorBuilder.setColumnFamily(columnFamilyDescriptorBuilder.build());</span><br><span class="line">        &#125;</span><br><span class="line">        admin.createTable(tableDescriptorBuilder.build());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加列族</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">addFamily</span><span class="params">(String tableName, String... cfs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        Admin admin = connection.getAdmin();</span><br><span class="line">        <span class="comment">//先判断表是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (isTableExist(tableName)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String cf : cfs) &#123;</span><br><span class="line">                ColumnFamilyDescriptorBuilder columnFamily = ColumnFamilyDescriptorBuilder.newBuilder(cf.getBytes());</span><br><span class="line">                admin.addColumnFamily(TableName.valueOf(tableName), columnFamily.build());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">dropTable</span><span class="params">(String tableName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        <span class="keyword">if</span> (isTableExist(tableName)) &#123;</span><br><span class="line"></span><br><span class="line">            Admin admin = connection.getAdmin();</span><br><span class="line">            admin.disableTable(TableName.valueOf(tableName));</span><br><span class="line">            admin.deleteTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建名称空间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  Boolean <span class="title">createNamespace</span><span class="params">(String spacename)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        Admin admin = connection.getAdmin();</span><br><span class="line">        NamespaceDescriptor build = NamespaceDescriptor.create(spacename).build();</span><br><span class="line">        admin.createNamespace(build);</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="DeleteData"><a href="#DeleteData" class="headerlink" title="DeleteData"></a>DeleteData</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.TableName;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Connection;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Delete;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Table;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-11-07</span></span><br><span class="line"><span class="comment"> * Time: 14:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// deleteData(&quot;tab_2&quot;,&quot;10001&quot;);</span></span><br><span class="line">        deleteData1(<span class="string">&quot;tab_2&quot;</span>, <span class="string">&quot;40001&quot;</span>, <span class="string">&quot;status&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除rowkey</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteData</span><span class="params">(String tableName, String rowkey)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Delete delete = <span class="keyword">new</span> Delete(Bytes.toBytes(rowkey));</span><br><span class="line">        table.delete(delete);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteData1</span><span class="params">(String tableName, String rowkey, String cf)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Table table = HbaseUtils.getConnection().getTable(TableName.valueOf(tableName));</span><br><span class="line">        Delete delete = <span class="keyword">new</span> Delete(Bytes.toBytes(rowkey));</span><br><span class="line">        delete.addFamily(Bytes.toBytes(cf));</span><br><span class="line">        table.delete(delete);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="DMLTable"><a href="#DMLTable" class="headerlink" title="DMLTable"></a>DMLTable</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.Cell;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.CellUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.CompareOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.TableName;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.filter.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DMLTable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment">     * Description:</span></span><br><span class="line"><span class="comment">     * User: tongyongtao</span></span><br><span class="line"><span class="comment">     * Date: 2020-11-06</span></span><br><span class="line"><span class="comment">     * Time: 22:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// putData(&quot;tab_2&quot;, &quot;60005&quot;, &quot;status&quot;, &quot;name&quot;, &quot;小胡&quot;);</span></span><br><span class="line">        <span class="comment">// getData(&quot;tab_2&quot;,&quot;10001&quot;);</span></span><br><span class="line">        <span class="comment">//  scanData(&quot;tab_2&quot;,&quot;&quot;,&quot;&quot;);</span></span><br><span class="line">        <span class="comment">// filterData(&quot;tab_2&quot;);</span></span><br><span class="line">        <span class="comment">// filterData1(&quot;tab_2&quot;,&quot;status&quot;,&quot;age&quot;,&quot;19&quot;);</span></span><br><span class="line">        <span class="comment">// filterData2(&quot;tab_2&quot;,&quot;status&quot;);</span></span><br><span class="line">        filterData3(<span class="string">&quot;tab_2&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putData</span><span class="params">(String tableName, String rowkey, String cf, String cm, String values)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Put put = <span class="keyword">new</span> Put(Bytes.toBytes(rowkey));</span><br><span class="line">        put.addColumn(Bytes.toBytes(cf), Bytes.toBytes(cm), Bytes.toBytes(values));</span><br><span class="line">        table.put(put);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数据get方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(String tableName, String rowkey)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Get get = <span class="keyword">new</span> Get(Bytes.toBytes(rowkey));</span><br><span class="line">        Result result = table.get(get);</span><br><span class="line">        <span class="keyword">for</span> (Cell cell : result.rawCells()) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(CellUtil.cloneFamily(cell)));</span><br><span class="line">            <span class="comment">// System.out.println(Arrays.toString(Bytes.toBytes(ByteBuffer.wrap(CellUtil.cloneQualifier(cell)))));</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(CellUtil.cloneQualifier(cell)));</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(CellUtil.cloneValue(cell)));</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(CellUtil.cloneRow(cell)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get方法获取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData1</span><span class="params">(String tableName, String rowkey)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line"></span><br><span class="line">        List&lt;Get&gt; gets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取多个rowkey</span></span><br><span class="line">        gets.add(<span class="keyword">new</span> Get(Bytes.toBytes(<span class="string">&quot;100001&quot;</span>)));</span><br><span class="line">        gets.add(<span class="keyword">new</span> Get(Bytes.toBytes(<span class="string">&quot;10002&quot;</span>)));</span><br><span class="line">        Result[] results = table.get(gets);</span><br><span class="line">        <span class="keyword">for</span> (Result result : results) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cell cell : result.rawCells()) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//scan方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scanData</span><span class="params">(String tableName, String start, String stop)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">        <span class="keyword">try</span> (ResultScanner scanner = table.getScanner(scan)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Result result : scanner) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Cell cell : result.rawCells()) &#123;</span><br><span class="line">                    System.out.println(((Bytes.toString(CellUtil.cloneRow(cell)))));</span><br><span class="line">                    System.out.println(Bytes.toString(CellUtil.cloneFamily(cell)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关于scan的过滤器  列族过滤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filterData</span><span class="params">(String tableName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">        Filter filter = <span class="keyword">new</span> RowFilter(CompareOperator.EQUAL, <span class="keyword">new</span> SubstringComparator(<span class="string">&quot;10001&quot;</span>));</span><br><span class="line">        scan.setFilter(filter);</span><br><span class="line">        ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">        <span class="keyword">for</span> (Result result : scanner) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cell cell : result.rawCells()) &#123;</span><br><span class="line">                System.out.println(Bytes.toString(CellUtil.cloneValue(cell)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关于scan过滤  值过滤 一般采用SingleColumnValueFilter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filterData1</span><span class="params">(String tableName, String cf, String cm, String values)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">        Filter filter = <span class="keyword">new</span> SingleColumnValueFilter</span><br><span class="line">                (Bytes.toBytes(cf), Bytes.toBytes(cm), CompareOperator.EQUAL, Bytes.toBytes(values));</span><br><span class="line">        scan.setFilter(filter);</span><br><span class="line">        ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">        <span class="keyword">for</span> (Result result : scanner) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cell cell : result.rawCells()) &#123;</span><br><span class="line">                System.out.println(Bytes.toString(CellUtil.cloneValue(cell)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//列族的过滤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filterData2</span><span class="params">(String tableName, String cf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">        FamilyFilter filter = <span class="keyword">new</span> FamilyFilter(CompareOperator.EQUAL, <span class="keyword">new</span> BinaryComparator(Bytes.toBytes(cf)));</span><br><span class="line">        scan.setFilter(filter);</span><br><span class="line">        ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">        <span class="keyword">for</span> (Result result : scanner) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cell cell : result.rawCells()) &#123;</span><br><span class="line">                System.out.println(Bytes.toString(CellUtil.cloneValue(cell)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filterData3</span><span class="params">(String tableName, String cm)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = HbaseUtils.getConnection();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">        QualifierFilter filter = <span class="keyword">new</span> QualifierFilter(CompareOperator.EQUAL, <span class="keyword">new</span> SubstringComparator(cm));</span><br><span class="line">        scan.setFilter(filter);</span><br><span class="line">        ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">        <span class="keyword">for</span> (Result result : scanner) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cell cell : result.rawCells()) &#123;</span><br><span class="line">                System.out.println(Bytes.toString(CellUtil.cloneValue(cell)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="MR-Interaction"><a href="#MR-Interaction" class="headerlink" title="MR Interaction"></a>MR Interaction</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Writable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInput;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutput;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HbaseBean1</span> <span class="keyword">implements</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String movie;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> rate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HbaseBean1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMovie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> movie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovie</span><span class="params">(String movie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movie = movie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRate</span><span class="params">(<span class="keyword">double</span> rate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rate = rate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeStamp</span><span class="params">(<span class="keyword">long</span> timeStamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeStamp = timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HbaseBean1</span><span class="params">(String movie, <span class="keyword">double</span> rate, <span class="keyword">long</span> timeStamp, String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movie = movie;</span><br><span class="line">        <span class="keyword">this</span>.rate = rate;</span><br><span class="line">        <span class="keyword">this</span>.timeStamp = timeStamp;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Movie&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;movie=&#x27;&quot;</span> + movie + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, rate=&quot;</span> + rate +</span><br><span class="line">                <span class="string">&quot;, timeStamp=&quot;</span> + timeStamp +</span><br><span class="line">                <span class="string">&quot;, uid=&#x27;&quot;</span> + uid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        dataOutput.writeUTF(movie);</span><br><span class="line">        dataOutput.writeDouble(rate);</span><br><span class="line">        dataOutput.writeLong(timeStamp);</span><br><span class="line">        dataOutput.writeUTF(uid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movie = dataInput.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.rate = dataInput.readDouble();</span><br><span class="line">        <span class="keyword">this</span>.timeStamp = dataInput.readLong();</span><br><span class="line">        <span class="keyword">this</span>.uid = dataInput.readUTF();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Scan;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableReducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-12</span></span><br><span class="line"><span class="comment"> * Time: 22:19</span></span><br><span class="line"><span class="comment"> * Hbase与MR的交互</span></span><br><span class="line"><span class="comment"> * 案例:电影案例 分析:设计rowkey  ImmutableBytesWritable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MR_Hbase1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;C:\\Users\\hp\\IdeaProjects\\GitHub_Maven\\src\\main\\resources\\hbase.json&quot;</span>&#125;;</span><br><span class="line">        Configuration con = HBaseConfiguration.create();</span><br><span class="line">        con.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="string">&quot;linux03,linux04,linux05&quot;</span>);</span><br><span class="line">        Job job = Job.getInstance(con, <span class="string">&quot;MR_Hbase&quot;</span>);</span><br><span class="line">        job.setMapperClass(MAP_Hbase1.class);</span><br><span class="line">        job.setReducerClass(Reduce_Hbase1.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(HbaseBean1.class);</span><br><span class="line">        <span class="comment">// 穿件扫描对象用来扫描源hbase中的所有的数据</span></span><br><span class="line">        Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">        <span class="comment">// 接收的扫描的数据的行数</span></span><br><span class="line">        scan.setCaching(<span class="number">200</span>);</span><br><span class="line">        scan.setCacheBlocks(<span class="keyword">false</span>);</span><br><span class="line">        job.setJarByClass(HbaseBean1.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入数据的路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// 插入数据的表要存在</span></span><br><span class="line">        TableMapReduceUtil.initTableReducerJob(<span class="string">&quot;movie1&quot;</span>, Reduce_Hbase1.class, job);</span><br><span class="line">        System.out.println(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="string">&quot;zq&quot;</span> : <span class="string">&quot;cw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MAP_Hbase1</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">HbaseBean1</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">static</span>  Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">                    <span class="comment">//电影名字和时间龊构成一个rowkey</span></span><br><span class="line">            HbaseBean1 hbaseBean = <span class="keyword">null</span>;</span><br><span class="line">            Text text = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                hbaseBean = gson.fromJson(value.toString(), HbaseBean1.class);</span><br><span class="line">                String movie = StringUtils.leftPad(hbaseBean.getMovie(), <span class="number">4</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                String movieStamp = StringUtils.leftPad( String.valueOf(hbaseBean.getTimeStamp()),<span class="number">9</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                text = <span class="keyword">new</span> Text();</span><br><span class="line">                text.set(movie+<span class="string">&quot;_&quot;</span>+movieStamp);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            context.write(text,hbaseBean);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce_Hbase1</span> <span class="keyword">extends</span> <span class="title">TableReducer</span>&lt;<span class="title">Text</span>, <span class="title">HbaseBean1</span>, <span class="title">ImmutableBytesWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;HbaseBean1&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">//key是rowkey values,迭代器只存储了一个</span></span><br><span class="line">            Put put = <span class="keyword">new</span> Put(key.toString().getBytes());</span><br><span class="line">            <span class="keyword">for</span> (HbaseBean1 value : values) &#123;</span><br><span class="line">                put.addColumn(<span class="string">&quot;cf&quot;</span>.getBytes(),<span class="string">&quot;moviename&quot;</span>.getBytes(),value.getMovie().getBytes());</span><br><span class="line">                put.addColumn(<span class="string">&quot;cf&quot;</span>.getBytes(),<span class="string">&quot;movierate&quot;</span>.getBytes(),String.valueOf(value.getRate()).getBytes());</span><br><span class="line">                put.addColumn(<span class="string">&quot;cf&quot;</span>.getBytes(),<span class="string">&quot;moviestamp&quot;</span>.getBytes(),String.valueOf(value.getTimeStamp()).getBytes());</span><br><span class="line">                put.addColumn(<span class="string">&quot;cf&quot;</span>.getBytes(),<span class="string">&quot;movieuid&quot;</span>.getBytes(),value.getUid().getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(<span class="keyword">null</span>,put);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Coprocessor"><a href="#Coprocessor" class="headerlink" title="Coprocessor"></a>Coprocessor</h2><h2 id="Phoenix"><a href="#Phoenix" class="headerlink" title="Phoenix"></a>Phoenix</h2>]]></content>
      <categories>
        <category>The Hadoop Ecosystem</category>
      </categories>
      <tags>
        <tag>Work Systematically</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器详解</title>
    <url>/2020/08/24/Java-CollectionsFramework/</url>
    <content><![CDATA[<h2 id="一-ArrayList和LinkedList的区别以及优缺点"><a href="#一-ArrayList和LinkedList的区别以及优缺点" class="headerlink" title="一.ArrayList和LinkedList的区别以及优缺点"></a>一.ArrayList和LinkedList的区别以及优缺点</h2><ol>
<li><p> ArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表结构。</p>
</li>
<li><p> 对于随机访问的get和set方法，ArrayList要优于LinkedList，因为LinkedList要移动指针。</p>
</li>
<li><p> 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p>
</li>
<li><p>对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的,分配一个内部Entry对象。</p>
</li>
<li><p>在ArrayList集合中添加或者删除一个元素时，当前的列表所所有的元素都会被移动。而LinkedList集合中添加或者删除一个元素的开销是固定的。</p>
</li>
<li><p>LinkedList集合不支持高效的随机随机访问（RandomAccess），因为可能产生二次项的行为。</p>
</li>
<li><p>ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间</p>
</li>
<li><p>我们进行对元素的增删查操作的时候，进行查操作时用ArrayList，进行增删操作的时候最好用LinkedList。</p>
</li>
</ol>
<h2 id="二-ArrayList源码分析"><a href="#二-ArrayList源码分析" class="headerlink" title="二.ArrayList源码分析"></a>二.ArrayList源码分析</h2><h4 id="方法源码分析"><a href="#方法源码分析" class="headerlink" title="方法源码分析"></a>方法源码分析</h4><h6 id="add"><a href="#add" class="headerlink" title="add"></a><code>add</code></h6><h6 id="remove"><a href="#remove" class="headerlink" title="remove"></a><code>remove</code></h6><h6 id="快速失败机制"><a href="#快速失败机制" class="headerlink" title="快速失败机制"></a><code>快速失败机制</code></h6><h6 id="关于遍历时删除"><a href="#关于遍历时删除" class="headerlink" title="关于遍历时删除"></a><code>关于遍历时删除</code></h6><h4 id="分析-ArrayList-扩容机制"><a href="#分析-ArrayList-扩容机制" class="headerlink" title="分析 ArrayList 扩容机制"></a>分析 ArrayList 扩容机制</h4><h6 id="add-1"><a href="#add-1" class="headerlink" title="add"></a><code>add</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="ensureCapacityInternal"><a href="#ensureCapacityInternal" class="headerlink" title="ensureCapacityInternal()"></a><code>ensureCapacityInternal()</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">             <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h6 id="ensureExplicitCapacity"><a href="#ensureExplicitCapacity" class="headerlink" title="ensureExplicitCapacity()"></a><code>ensureExplicitCapacity()</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h6 id="grow"><a href="#grow" class="headerlink" title="grow()"></a><code>grow()</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">       <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">      <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">      <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h6 id="hugeCapacity"><a href="#hugeCapacity" class="headerlink" title="hugeCapacity()"></a><code>hugeCapacity()</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *从上面 grow() 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) hugeCapacity() 方法来比较 minCapacity 和    *MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE </span></span><br><span class="line"><span class="comment">   *为 Integer.MAX_VALUE - 8</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">        <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">        <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">        <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h6 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy()"></a><code>System.arraycopy()</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment">    *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">    *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">       <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h6 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf()"></a><code>Arrays.copyOf()</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="ensureCapacity"><a href="#ensureCapacity" class="headerlink" title="ensureCapacity"></a><code>ensureCapacity</code></h6><p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">           <span class="comment">// any size if not default element table</span></span><br><span class="line">           ? <span class="number">0</span></span><br><span class="line">           <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">           <span class="comment">// supposed to be at default size.</span></span><br><span class="line">           : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">           ensureExplicitCapacity(minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="三-无序性和不可重复性的含义是什么"><a href="#三-无序性和不可重复性的含义是什么" class="headerlink" title="三.无序性和不可重复性的含义是什么"></a>三.无序性和不可重复性的含义是什么</h2><ul>
<li><p>无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数组的哈希值决定的</p>
</li>
<li><p>不可重复性：保证添加的元素按照equals（）判断时，不能返回true，即相同的元素只能添加一个,需要同时重写equals()方法和hashcode()方法</p>
</li>
</ul>
<h2 id="四-HashMap源码分析"><a href="#四-HashMap源码分析" class="headerlink" title="四.HashMap源码分析"></a>四.HashMap源码分析</h2><h4 id="方法源码分析-1"><a href="#方法源码分析-1" class="headerlink" title="方法源码分析"></a>方法源码分析</h4><h6 id="HashMap-hash"><a href="#HashMap-hash" class="headerlink" title="HashMap  hash "></a><code>HashMap  hash </code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//为什么这样设计 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line">  <span class="comment">//jdk1.7中有indexFor(int h, int length)方法,这个方法返回值就是数组下标</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//由于和（length-1）运算，length 绝大多数情况小于2的16次方。所以始终是hashcode 的低16位（甚至更低）参与运算。要是高16位     //也参与运算，会让得到的下标更加散列</span></span><br><span class="line">  <span class="comment">//&amp;和|都会使得结果偏向0或者1 ,并不是均匀的概念,所以用^</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="衡量数组是否需要扩增"><a href="#衡量数组是否需要扩增" class="headerlink" title="衡量数组是否需要扩增"></a><code>衡量数组是否需要扩增</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// loadFactor加载因子</span></span><br><span class="line"><span class="comment">//loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，</span></span><br><span class="line"><span class="comment">// 那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，</span></span><br><span class="line"><span class="comment">// 数组中存放的数据(entry)也就越少，也就越稀疏。</span></span><br><span class="line"><span class="comment">//loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。</span></span><br><span class="line"><span class="comment">// loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。</span></span><br><span class="line"><span class="comment">//给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 </span></span><br><span class="line"><span class="comment">// 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</span></span><br><span class="line"><span class="comment">//threshold</span></span><br><span class="line"><span class="comment">//*threshold = capacity * loadFactor*，当Size&gt;=threshold的时候，</span></span><br><span class="line"><span class="comment">// 那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。</span></span><br></pre></td></tr></table></figure>

<h6 id="put方法逻辑分析"><a href="#put方法逻辑分析" class="headerlink" title="put方法逻辑分析"></a><code>put方法逻辑分析</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值，转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当桶数组 table 为空时，通过扩容的方式初始化 table</span></span><br><span class="line"><span class="comment">//查找要插入的键值对是否已经存在，存在的话根据条件判断是否用新值替换旧值</span></span><br><span class="line"><span class="comment">//如果不存在，则将键值对链入链表中，并根据链表长度决定是否将链表转为红黑树</span></span><br><span class="line"><span class="comment">//判断键值对数量是否大于阈值，大于的话则进行扩容操作</span></span><br></pre></td></tr></table></figure>



<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><h6 id="resize"><a href="#resize" class="headerlink" title="resize"></a><code>resize</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果 table 不为空，表明已经初始化过了</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当 table 容量超过容量最大值，则不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 按旧容量和阈值的2倍计算新容量和阈值的大小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 初始化时，将 threshold 的值赋值给 newCap，</span></span><br><span class="line"><span class="comment">         * HashMap 使用 threshold 变量暂时保存 initialCapacity 参数的值</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 调用无参构造方法时，桶数组容量为默认容量，</span></span><br><span class="line"><span class="comment">         * 阈值为默认容量与默认负载因子乘积</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// newThr 为 0 时，按阈值计算公式进行计算</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 创建新的桶数组，桶数组的初始化也是在这里完成的</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 重新映射时，需要对红黑树进行拆分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 将分组后的链表映射到新桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五-LinkedHashMap-源码详细分析"><a href="#五-LinkedHashMap-源码详细分析" class="headerlink" title="五.LinkedHashMap 源码详细分析"></a>五.LinkedHashMap 源码详细分析</h2><h2 id="六-ConcurrentHashMap-源码详细分析"><a href="#六-ConcurrentHashMap-源码详细分析" class="headerlink" title="六.ConcurrentHashMap 源码详细分析"></a>六.ConcurrentHashMap 源码详细分析</h2><h4 id="方法源码分析-2"><a href="#方法源码分析-2" class="headerlink" title="方法源码分析"></a>方法源码分析</h4><h6 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with a default initial capacity (16),</span></span><br><span class="line"><span class="comment"> * load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分别是默认初始化容量,默认负载因子,默认并发级别</span></span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="Arrays-asList-避坑指南"><a href="#Arrays-asList-避坑指南" class="headerlink" title="Arrays.asList()避坑指南"></a>Arrays.asList()避坑指南</h2>]]></content>
      <categories>
        <category>Programming Language</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Summary of knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark性能优化简单分析</title>
    <url>/2020/11/10/Spark-Performance-Optimization/</url>
    <content><![CDATA[<h2 id="资源调优"><a href="#资源调优" class="headerlink" title="资源调优"></a>资源调优</h2><h4 id="Spark作业运行基本原理"><a href="#Spark作业运行基本原理" class="headerlink" title="Spark作业运行基本原理"></a>Spark作业运行基本原理</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. spark-submit 根据部署模式(本地或集群中某工作节点)启动一个对应的Driver进程,</span><br><span class="line">Driver进程本身会根据我们设置的参数,占有一定数量的内存和CPU core</span><br><span class="line"></span><br><span class="line">2. Driver进程要做的第一件事情就是向sparkstandalone集群也可以是yarn集群申请</span><br><span class="line">spark作业的资源(executor),集群管理器会根据我们为Spark作业设置的资源参数,在各</span><br><span class="line">个工作节点上,启动一定数量的Executor进程,每个Executor进程都占有一定数量的内存和CPU core</span><br><span class="line"></span><br><span class="line">3. 再申请到作业所需的资源,Driver进程就会开始调度和执行编写的作业代码,</span><br><span class="line">Driver进程会将我们编写的Spark作业代码分拆为多个stage,每个stage执行一部分代码片段,并为每个stage创建一批task</span><br><span class="line"></span><br><span class="line">4. Driver将这些task分配到各个executor进程中.task是最小的计算单位,</span><br><span class="line">一个stage中所有的tas   k都执行完毕之后,会在各个节点本地的磁盘文件中</span><br><span class="line">写入计算中间结果,然后Driver就会调度运行下一个stage</span><br><span class="line"></span><br><span class="line">5. 下一个stage的task的输入数据就是上一个stage输出的中间结果。如此循环往复,</span><br><span class="line">直到将我们自己编写的代码逻辑全部执行完,并且计算完所有的数据,得到我们想要的结果为止</span><br><span class="line">(Spark是根据shuffle类算子来进行stage的划分,shuffle算子执行以及之后的代码会被</span><br><span class="line">划分为下一个stage.因此一个stage刚开始执行的时候,它的每个task可能都会从上一个</span><br><span class="line">stage的task所在的节点,去通过网络传输拉取需要自己处理的所有key,然后对拉取到的</span><br><span class="line">所有相同的key使用我们自己编写的算子函数执行聚合操作)</span><br><span class="line"></span><br><span class="line">6. 当我们在代码中执行了cache/persist等持久化操作时,根据我们选择的持久化级别</span><br><span class="line">的不同,每个task计算出来的数据也会保存到Executor进程的内存或者所在节点的磁盘文件</span><br><span class="line">中.executor的内存分为三个部分(task代码执行内存占20%task通过shuffle拉取上游</span><br><span class="line">结果进行聚合等占据20%,RDD持久化占据60%),ask的执行速度是跟每个Executor进程的</span><br><span class="line">CPU core数量有直接关系的.一个CPU core同一时间只能执行一个线程</span><br></pre></td></tr></table></figure>



<h4 id="提交任务时合理分配资源"><a href="#提交任务时合理分配资源" class="headerlink" title="提交任务时合理分配资源"></a>提交任务时合理分配资源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">– total-executor-cores</span><br><span class="line">该参数用于设置Spark作业总共可以使用多少个core</span><br><span class="line">不要超过队列总CPU core的1/3~1/2左右比较合适</span><br><span class="line"></span><br><span class="line">– num-executors</span><br><span class="line">该参数用于设置Spark作业总共要用多少个Executor进程来执行</span><br><span class="line">每个Spark作业的运行一般设置50~100个左右的Executor进程比较合适,</span><br><span class="line">设置太少或太多的Executor进程都不好。设置的太少,无法充分利用集群资源；</span><br><span class="line">设置的太多的话,大部分队列可能无法给予充分的资源</span><br><span class="line"></span><br><span class="line">– executor-memory</span><br><span class="line">该参数用于设置每个Executor进程的内存.Executor内存的大小,很多时候直接</span><br><span class="line">决定了Spark作业的性能,而且跟常见的JVM OOM异常,也有直接的关联</span><br><span class="line">每个Executor进程的内存设置4G~8G较为合适.但是这只是一个参考值,</span><br><span class="line">具体的设置还是得根据不同部门的资源队列来定。可以看看自己团队的资源队列</span><br><span class="line">的最大内存限制是多少,num-executors乘以executor-memory,是不能超过队列的最大内存量的</span><br><span class="line">此外,如果你是跟团队里其他人共享这个资源队列,那么申请的内存量最好不要</span><br><span class="line">超过资源队列最大总内存的1/3~1/2,避免你自己的Spark作业占用了队列所</span><br><span class="line">有的资源,导致别的同事的作业无法运行</span><br><span class="line"></span><br><span class="line">– executor-cores</span><br><span class="line">该参数用于设置每个Executor进程的CPU core数量.这个参数决定了每个</span><br><span class="line">Executor进程并行执行task线程的能力.因为每个CPU core同一时间只能</span><br><span class="line">执行一个task线程,因此每个Executor进程的CPU core数量越多,越能够快速地执行完分配给自己的所有task线程</span><br><span class="line">Executor的CPU core数量设置为2~4个较为合适.同样得根据不同部门的</span><br><span class="line">资源队列来定,可以看看自己的资源队列的最大CPU core限制是多少,</span><br><span class="line">再依据设置的Executor数量,来决定每个Executor进程可以分配到几个</span><br><span class="line">CPU core.同样建议,如果是跟他人共享这个队列,那么num-executors * executor-cores</span><br><span class="line">不要超过队列总CPU core的1/3~1/2左右比较合适,也是避免影响其他同事的作业运行</span><br><span class="line"></span><br><span class="line">– driver-memory</span><br><span class="line">该参数用于设置Driver进程的内存</span><br><span class="line">Driver的内存通常来说不设置,或者设置1G左右应该就够了</span><br><span class="line">唯一需要注意的一点是,如果需要使用collect算子将RDD的数据全部拉取到</span><br><span class="line">Driver上进行处理,那么必须确保Driver的内存足够大,否则会出现OOM内存溢出的问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="提交的任务要充分使用资源"><a href="#提交的任务要充分使用资源" class="headerlink" title="提交的任务要充分使用资源"></a>提交的任务要充分使用资源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">- 降低HDFS的block块的大小</span><br><span class="line">因为Spark用的读取文件的方法是MR的方法,所以读取文件的时候,首先划分成</span><br><span class="line">一个一个的split。RDD的partition数=split数,而在默认情况下,split数=block数</span><br><span class="line">,所以partition数=block数,所以降低block块的大小可以增加block块的个数</span><br><span class="line">,从而增加partition的个数,从而提供并行度</span><br><span class="line"></span><br><span class="line">- sparkContext.textFile(path, numPartitions)</span><br><span class="line">在读取文件的时候可以指定分区数</span><br><span class="line"></span><br><span class="line">- coalesce(numPartitions, isshuffle)</span><br><span class="line">改变RDD分区数,一般设置第二个参数为false,用于减少分区</span><br><span class="line"></span><br><span class="line">- repartition(numPartitions)</span><br><span class="line">改变RDD分区数,一般用于增加分区数</span><br><span class="line"></span><br><span class="line">- reduceByKey、groupByKey这些算子都可以指定分区数,决定返回的RDD的分区个数</span><br><span class="line"></span><br><span class="line">- spark.default.parallelism</span><br><span class="line">该参数用于设置每个stage的默认task数量</span><br><span class="line">这个参数极为重要,如果不设置可能会直接影响你的Spark作业性能</span><br><span class="line">Spark作业的默认task数量为500~1000个较为合适</span><br><span class="line">很多人常犯的一个错误就是不去设置这个参数,那么此时就会导致</span><br><span class="line">Spark自己根据底层HDFS的block数量来设置task的数量,默认是一个HDFS block对应一个task</span><br><span class="line">通常来说,Spark默认设置的数量是偏少的（比如就几十个task）,</span><br><span class="line">如果task数量偏少的话,就会导致你前面设置好的Executor的参数都前功尽弃</span><br><span class="line">试想一下,无论你的Executor进程有多少个,内存和CPU有多大,</span><br><span class="line">但是task只有1个或者10个,那么90%的Executor进程可能根本就没有task执行,也就是白白浪费了资源</span><br><span class="line">因此Spark官网建议的设置原则是,设置该参数为num-executors * executor-cores</span><br><span class="line">的2~3倍较为合适,比如Executor的总CPU core数量为300个,那么设置1000个task是可以的,此时可以充分地利用Spark集群的资源</span><br><span class="line"></span><br><span class="line">- spark.sql.shuffle.partitions</span><br><span class="line">spark sql编程中产生shuffle,决定shuffle过程中reduce task的个数</span><br><span class="line">default：200</span><br><span class="line">参数调优建议：</span><br><span class="line">同 spark.default.parallelism</span><br><span class="line"></span><br><span class="line">- partitionBy(Partitioner)</span><br><span class="line">通过自定义分区器来改变partition个数</span><br><span class="line"></span><br><span class="line">- join算子也会改变RDD分区数</span><br><span class="line">val rdd3 = rdd1.join(rdd2)</span><br><span class="line">默认情况下(spark.default.parallelism没有设置)时,RDD3的分区数是</span><br><span class="line">由父RDD中分区数最多的RDD决定的,比如rdd1有2个分区,rdd2有3个分区,那么rdd3有3个分区</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="代码调优"><a href="#代码调优" class="headerlink" title="代码调优"></a>代码调优</h2><h4 id="代码调优的十个原则"><a href="#代码调优的十个原则" class="headerlink" title="代码调优的十个原则"></a>代码调优的十个原则</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 避免创建重复的RDD.对于同一份数据只应该创建一个RDD,否则spark作业会进行重复计算进而增加了作业开销</span><br><span class="line"></span><br><span class="line">2. 尽可能复用同一个RDD.对不同的数据执行算子操作时还要尽可能地复用一个RDD.</span><br><span class="line">比如说,有一个RDD的数据格式是key-value类型的,另一个是单value类型的,</span><br><span class="line">这两个RDD的value数据是完全一样的。那么此时我们可以只使用key-value类型</span><br><span class="line">的那个RDD,因为其中已经包含了另一个的数据。对于类似这种多个RDD的数据有重叠或者包含的情况,我们应该尽量复用一个RDD</span><br><span class="line"></span><br><span class="line">3. 对多次使用的RDD进行持久化.Spark中对于一个RDD执行多次算子的默认原理是这样的：</span><br><span class="line">每次你对一个RDD执行一个算子操作时,都会重新从源头处计算一遍,计算出那个RDD来,</span><br><span class="line">然后再对这个RDD执行你的算子操作,对多次使用的RDD进行持久化。此时Spark就会根据你的持久化策略,</span><br><span class="line">将RDD中的数据保存到内存或者磁盘中。以后每次对这个RDD进行算子操作时,都会直接从内存或磁盘中提取持久化的RDD数据</span><br><span class="line"></span><br><span class="line">以下情况考虑使用checkpoint()算子</span><br><span class="line">这个RDD是经过很长时间才计算完毕或者计算这个RDD的逻辑非常复杂,</span><br><span class="line">这说明这个RDD的计算结果非常重要,一般选用checkpoint来持久化,这样数据更</span><br><span class="line">安全了,task计算失败的时候会从checkpoint读取数据进行计算</span><br><span class="line">你的业务逻辑非常非常的复杂,RDD的依赖关系(lineage)非常长,使用checkpoint截断依赖关系,提高容错的效率</span><br><span class="line">对某个RDD执行 checkpoint() 之前,对该 RDD 执行 cache(),这样的话,</span><br><span class="line">新启动的job只需要把内存中的数据上传到HDFS中即可,不需要重新计算</span><br><span class="line"></span><br><span class="line">4. 尽量避免使用shuffle类算子.shuffle过程中,各个节点上的相同key</span><br><span class="line">都会先写入本地磁盘文件中,然后其他节点需要通过网络传输拉取各个节点上的磁盘文件中的相同key</span><br><span class="line">.而且相同key都拉取到同一个节点进行聚合操作时,还有可能会因为一个节点上处理的key过多</span><br><span class="line">,导致内存不够存放,进而溢写到磁盘文件中.因此在shuffle过程中,</span><br><span class="line">可能会发生大量的磁盘文件读写的IO操作,以及数据的网络传输操作.磁盘IO和网络数据传输也是shuffle性能较差的主要原因</span><br><span class="line"></span><br><span class="line">5. 如果因为业务需要,一定要使用shuffle操作,无法用map类的算子来替代,</span><br><span class="line">那么尽量使用可以map-side预聚合的算子.所谓的map-side预聚合,</span><br><span class="line">说的是在每个节点本地对相同的key进行一次聚合操作,类似于MapReduce中</span><br><span class="line">的本地combiner.map-side预聚合之后,每个节点本地就只会有一条相同的key,</span><br><span class="line">因为多条相同的key都被聚合起来了.其他节点在拉取所有节点上的相同key时,</span><br><span class="line">就会大大减少需要拉取的数据数量,从而也就减少了磁盘IO以及网络传输开销.</span><br><span class="line">通常来说,在可能的情况下,建议使用reduceByKey或者aggregateByKey算子</span><br><span class="line">来替代掉groupByKey算子.因为reduceByKey和aggregateByKey算子都会</span><br><span class="line">使用用户自定义的函数对每个节点本地的相同key进行预聚合.而groupByKey算子是不会进行预聚合的,全量的数据会在集群的各个节点之间分发和传输,性能相对来说比较差</span><br><span class="line"></span><br><span class="line">6. 使用高性能算子.</span><br><span class="line">(1). 使用reduceByKey/aggregateByKey替代groupByKey</span><br><span class="line"></span><br><span class="line">(2). 使用mapPartitions替代普通map.一次函数调用会处理一个partition所有的数据,而不是一次函数调用处理一条,性能相对来说会高一些.但是有的时候,使用mapPartitions会出现OOM（内存溢出）的问题.因为单次函数调用就要处理掉一个partition所有的数据,如果内存不够,垃圾回收时是无法回收掉太多对象的,很可能出现OOM异常</span><br><span class="line"></span><br><span class="line">(3). 使用foreachPartitions替代foreach</span><br><span class="line"></span><br><span class="line">(4). 使用filter之后进行coalesce操作.通常对一个RDD执行filter算子过滤掉RDD中较多数据后(比如30%以上的数据),建议使用coalesce算子,手动减少RDD的partition数量,将RDD中的数据压缩到更少的partition中去.因为filter之后,RDD的每个partition中都会有很多数据被过滤掉,此时如果照常进行后续的计算,其实每个task处理的partition中的数据量并不是很多,有一点资源浪费,而且此时处理的task越多,可能速度反而越慢.因此用coalesce减少partition数量,将RDD中的数据压缩到更少的partition之后,只要使用更少的task即可处理完所有的partition.在某些场景下,对于性能的提升会有一定的帮助</span><br><span class="line"></span><br><span class="line">(5). 使用repartitionAndSortWithinPartitions替代repartition与sort类操作.如果需要在repartition重分区之后,还要进行排序,建议直接使用repartitionAndSortWithinPartitions算子.因为该算子可以一边进行重分区的shuffle操作,一边进行排序.shuffle与sort两个操作同时进行,比先shuffle再sort来说,性能可能是要高的</span><br><span class="line"></span><br><span class="line">7. 尽量使用广播变量.在算子函数中使用到外部变量时,默认情况下</span><br><span class="line">,Spark会将该变量复制多个副本,通过网络传输到task中,此时每个task都有一个变量副本.</span><br><span class="line">如果变量本身比较大的话（比如100M,甚至1G）,那么大量的变量副本在网络中传输的性能开销,</span><br><span class="line">以及在各个节点的Executor中占用过多内存导致的频繁GC,都会极大地影响性能</span><br><span class="line"></span><br><span class="line">8. 使用Kryo优化序列化性能.</span><br><span class="line"></span><br><span class="line">9. 优化数据结构.Java中,有三种类型比较耗费内存:对象 字符串 集合类型 </span><br><span class="line">在Spark编码实现中,特别是对于算子函数中的代码,尽量不要使用上述三种数据结构,</span><br><span class="line">尽量使用字符串替代对象,使用原始类型（比如Int、Long）替代字符串,</span><br><span class="line">使用数组替代集合类型,这样尽可能地减少内存占用,从而降低GC频率,提升性能,</span><br><span class="line">但是在编码实践中发现,要做到该原则其实并不容易</span><br></pre></td></tr></table></figure>



<h4 id="持久化策略"><a href="#持久化策略" class="headerlink" title="持久化策略"></a>持久化策略</h4><h6 id="Spark的持久化级别"><a href="#Spark的持久化级别" class="headerlink" title="Spark的持久化级别"></a>Spark的持久化级别</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MEMORY_ONLY</span><br><span class="line">使用未序列化的Java对象格式,将数据保存在内存中.如果内存不够存放所有的数据,</span><br><span class="line">则数据可能就不会进行持久化.那么下次对这个RDD执行算子操作时,那些没有被持久化的数据,</span><br><span class="line">需要从源头处重新计算一遍.这是默认的持久化策略,使用cache()方法时,实际就是使用的这种持久化策略</span><br><span class="line"></span><br><span class="line">MEMORY_AND_DISK</span><br><span class="line">使用未序列化的Java对象格式,优先尝试将数据保存在内存中.如果内存不够存放所有的数据,</span><br><span class="line">会将数据写入磁盘文件中,下次对这个RDD执行算子时,持久化在磁盘文件中的数据会被读取出来使用</span><br><span class="line"></span><br><span class="line">MEMORY_ONLY_SER</span><br><span class="line">基本含义同MEMORY_ONLY.唯一的区别是,会将RDD中的数据进行序列化,RDD的每个</span><br><span class="line">partition会被序列化成一个字节数组.这种方式更加节省内存,从而可以避免持久化的数据占用过多内存导致频繁GC</span><br><span class="line"></span><br><span class="line">MEMORY_AND_DISK_SER</span><br><span class="line">基本含义同MEMORY_AND_DISK.唯一的区别是,会将RDD中的数据进行序列化,</span><br><span class="line">RDD的每个partition会被序列化成一个字节数组.这种方式更加节省内存,从而可以避免持久化的数据占用过多内存导致频繁GC</span><br><span class="line"></span><br><span class="line">DISK_ONLY</span><br><span class="line">使用未序列化的Java对象格式,将数据全部写入磁盘文件中</span><br><span class="line"></span><br><span class="line">MEMORY_ONLY_2, MEMORY_AND_DISK_2</span><br><span class="line">对于上述任意一种持久化策略,如果加上后缀_2,代表的是将每个持久化的数据,都复制一份副本,</span><br><span class="line">并将副本保存到其他节点上。这种基于副本的持久化机制主要用于进行容错。假如某个节点挂掉,</span><br><span class="line">节点的内存或磁盘中的持久化数据丢失了,那么后续对RDD计算时还可以使用该数据在其他节点上的副本。</span><br><span class="line">如果没有副本的话,就只能将这些数据从源头处重新计算一遍了</span><br></pre></td></tr></table></figure>



<h6 id="持久化策略-1"><a href="#持久化策略-1" class="headerlink" title="持久化策略"></a>持久化策略</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">默认情况下,性能最高的当然是MEMORY_ONLY,但前提是你的内存必须足够足够大,</span><br><span class="line">可以绰绰有余地存放下整个RDD的所有数据.因为不进行序列化与反序列化操作,</span><br><span class="line">就避免了这部分的性能开销；对这个RDD的后续算子操作,都是基于纯内存中的数据的操作,</span><br><span class="line">不需要从磁盘文件中读取数据,性能也很高；而且不需要复制一份数据副本,并远程传送到其他节点上.</span><br><span class="line">但是这里必须要注意的是,在实际的生产环境中,恐怕能够直接用这种策略的场景还是有限的,</span><br><span class="line"></span><br><span class="line">如果RDD中数据比较多时（比如几十亿）,直接用这种持久化级别,会导致JVM的OOM内存溢出异常</span><br><span class="line">如果使用MEMORY_ONLY级别时发生了内存溢出,那么建议尝试使用MEMORY_ONLY_SER级别.</span><br><span class="line">该级别会将RDD数据序列化后再保存在内存中,此时每个partition仅仅是一个字节数组而已,</span><br><span class="line">大大减少了对象数量,并降低了内存占用.这种级别比MEMORY_ONLY多出来的性能开销,</span><br><span class="line">主要就是序列化与反序列化的开销.但是后续算子可以基于纯内存进行操作,</span><br><span class="line">因此性能总体还是比较高的.此外,可能发生的问题同上,如果RDD中的数据量过多的话,</span><br><span class="line">还是可能会导致OOM内存溢出的异常</span><br><span class="line"></span><br><span class="line">如果纯内存的级别都无法使用,那么建议使用MEMORY_AND_DISK_SER策略,</span><br><span class="line">而不是MEMORY_AND_DISK策略.因为既然到了这一步,就说明RDD的数据量很大,</span><br><span class="line">内存无法完全放下.序列化后的数据比较少,可以节省内存和磁盘的空间开销.</span><br><span class="line">同时该策略会优先尽量尝试将数据缓存在内存中,内存缓存不下才会写入磁盘</span><br><span class="line"></span><br><span class="line">通常不建议使用DISK_ONLY和后缀为_2的级别：因为完全基于磁盘文件进行数据的读写,</span><br><span class="line">会导致性能急剧降低,有时还不如重新计算一次所有RDD.后缀为_2的级别,</span><br><span class="line">必须将所有数据都复制一份副本,并发送到其他节点上,数据复制以及网络传输会导致较大的性能开销,</span><br><span class="line">除非是要求作业的高可用性,否则不建议使用</span><br></pre></td></tr></table></figure>



<h2 id="数据本地化调优"><a href="#数据本地化调优" class="headerlink" title="数据本地化调优"></a>数据本地化调优</h2><h4 id="task数据本地化级别"><a href="#task数据本地化级别" class="headerlink" title="task数据本地化级别"></a>task数据本地化级别</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. PROCESS_LOCAL：进程本地化:task要计算的数据在同一个executor进程的内存中</span><br><span class="line">2. NODE_LOCAL：节点本地化: task要计算的数据在本机的磁盘上,或者本机另一个executor进程的内存中</span><br><span class="line">3. NO_PREF：没有本地化级别:task要计算的数据在其他的机子上</span><br><span class="line">4. RACK_LOCAL：机架本地化</span><br><span class="line">5. ANY：跨机架取数据</span><br></pre></td></tr></table></figure>



<h4 id="TaskScheduler发送task选择本地化级别的策略"><a href="#TaskScheduler发送task选择本地化级别的策略" class="headerlink" title="TaskScheduler发送task选择本地化级别的策略"></a>TaskScheduler发送task选择本地化级别的策略</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">比如计算需要的数据在node01这台服务器中的Executor1这个进程中,那么TaskScheduler</span><br><span class="line">会把TaskSet发往Executor1进程中执行,此时的数据本地化级别时PROCESS_LOCAL,Executor1</span><br><span class="line">是最佳的计算位置,如果发送的task在等待了3秒,重试了5次之后仍然没有执行,那么TaskScheduler</span><br><span class="line">就认为Executor1的资源不充足,不足以支撑计算,那么降低数据本地化级别,把task发往node01</span><br><span class="line">的另外一个进程Executor2中,这时的数据本地化级别为NODE_LOCAL,如果还无法执行,</span><br><span class="line">降低为RACK_LOCAL,ANY,直到Task可以开始计算</span><br></pre></td></tr></table></figure>



<h2 id="数据倾斜调优"><a href="#数据倾斜调优" class="headerlink" title="数据倾斜调优"></a>数据倾斜调优</h2><h4 id="定位数据倾斜"><a href="#定位数据倾斜" class="headerlink" title="定位数据倾斜"></a>定位数据倾斜</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 在进行shuffle的时候,必须将各个节点上相同的key拉取到某个节点上的一个task来进行处理,</span><br><span class="line">比如按照key进行聚合或join等操作.此时如果某个key对应的数据量特别大的话,就会发生数据倾斜</span><br><span class="line"></span><br><span class="line">2. 定位数据倾斜.如果是yarn-client模式直接查看本地log,如果是yarn-cluster模式查看spark-web-UI.</span><br><span class="line">如何定位发生了数据倾斜:首先通过spark-UI定位发生在哪些stage的task,当然可能发生某个task突然内存溢出,</span><br><span class="line">建议直接看yarn-client模式下本地log的异常栈,或者是通过YARN查看yarn-cluster模式下的log中的异常栈,</span><br><span class="line">一般来说，通过异常栈信息就可以定位到你的代码中哪一行发生了内存溢出</span><br><span class="line"></span><br><span class="line">3. 查看导致数据倾斜的key的数据分布情况.知道了数据倾斜发生在哪里之后,通常需要分析一下那个执行了</span><br><span class="line">shuffle操作并且导致了数据倾斜的RDD/Hive表,查看一下其中key的分布情况,这主要是为之后选择哪一种技术方案提供依据.</span><br></pre></td></tr></table></figure>



<h4 id="数据倾斜的解决方案"><a href="#数据倾斜的解决方案" class="headerlink" title="数据倾斜的解决方案"></a>数据倾斜的解决方案</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 使用Hive ETL预处理数据</span><br><span class="line">通过Hive ETL预先对数据按照key进行聚合,或者是预先和其他表进行join.治标不治本，Hive ETL中还是会发生数据倾斜</span><br><span class="line">在一些Java系统与Spark结合使用的项目中，会出现Java代码频繁调用Spark作业的场景,</span><br><span class="line">而且对Spark作业的执行性能要求很高,就比较适合使用这种方案。将数据倾斜提前到上游的Hive ETL,</span><br><span class="line">每天仅执行一次,只有那一次是比较慢的,而之后每次Java调用Spark作业时，执行速度都会很快,能够提供更好的用户体验</span><br><span class="line"></span><br><span class="line">2. 过滤少数导致倾斜的key</span><br><span class="line">如果我们判断那少数几个数据量特别多的key,对作业的执行和计算结果不是特别重要的话,那么干脆就直接过滤掉那少数几个key</span><br><span class="line">但是大多数情况下,导致倾斜的key还是很多的,并不是只有少数几个</span><br><span class="line"></span><br><span class="line">3. 提高shuffle的并行度</span><br><span class="line">设置一个参数,即spark.sql.shuffle.partitions,该参数代表了shuffle read task的并行度,</span><br><span class="line">该值默认是200,对于很多场景来说都有点过小,只是缓解了数据倾斜而已，没有彻底根除问题，根据实践经验来看，其效果有限</span><br><span class="line"></span><br><span class="line">4. 双重聚合</span><br><span class="line">将原本相同的key通过附加随机前缀的方式,变成多个不同的key,就可以让原本被一个task处理的数据分散到多个task上去做局部聚合,进而解决单个task处理数据量过多的问题.接着去除掉随机前缀,再次进行全局聚合,就可以得到最终的结果.仅仅适用于聚合类的shuffle操作,适用范围相对较窄.如果是join类的shuffle操作,还得用其他的解决方案</span><br><span class="line"></span><br><span class="line">5. 将reduce join转为map join</span><br><span class="line">不使用join算子进行连接操作,而使用Broadcast变量与map类算子实现join操作,进而完全规避掉shuffle类的操作,彻底避免数据倾斜的发生和出现</span><br><span class="line"></span><br><span class="line">6. 采样倾斜key并分拆join操作</span><br><span class="line">对于join导致的数据倾斜,如果只是某几个key导致了倾斜,可以将少数几个key分拆成独立RDD,并附加随机前缀打散成n份去进行join.如果导致倾斜的key特别多的话,比如成千上万个key都导致数据倾斜,那么这种方式也不适合</span><br><span class="line"></span><br><span class="line">7. 使用随机前缀和扩容RDD进行join</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Shuffle调优"><a href="#Shuffle调优" class="headerlink" title="Shuffle调优"></a>Shuffle调优</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. spark.shuffle.file.buffer</span><br><span class="line">默认值：32k</span><br><span class="line">该参数用于设置shuffle write task的BufferedOutputStream的buffer缓冲大小.</span><br><span class="line">将数据写到磁盘文件之前,会先写入buffer缓冲中,待缓冲写满之后,才会溢写到磁盘</span><br><span class="line"></span><br><span class="line">调优建议：如果作业可用的内存资源较为充足的话,可以适当增加这个参数的大小（比如64k）</span><br><span class="line">从而减少shuffle write过程中溢写磁盘文件的次数,也就可以减少磁盘IO次数,</span><br><span class="line">进而提升性能.在实践中发现,合理调节该参数,性能会有1%~5%的提升</span><br><span class="line"></span><br><span class="line">2. spark.reducer.maxSizeInFlight</span><br><span class="line">默认值：48m</span><br><span class="line">参数说明：该参数用于设置shuffle read task的buffer缓冲大小,而这个buffer缓冲决定了每次能够拉取多少数据</span><br><span class="line"></span><br><span class="line">调优建议：如果作业可用的内存资源较为充足的话,可以适当增加这个参数的大小（比如96m）,</span><br><span class="line">从而减少拉取数据的次数,也就可以减少网络传输的次数,进而提升性能.在实践中发现,合理调节该参数,性能会有1%~5%的提升.</span><br><span class="line"></span><br><span class="line">3. spark.shuffle.io.maxRetries</span><br><span class="line">默认值：3</span><br><span class="line">参数说明：shuffle read task从shuffle write task所在节点拉取属于自己的数据时</span><br><span class="line">如果因为网络异常导致拉取失败,是会自动进行重试的.该参数就代表了可以重试的最大次数.</span><br><span class="line">如果在指定次数之内拉取还是没有成功,就可能会导致作业执行失败</span><br><span class="line"></span><br><span class="line">调优建议：对于那些包含了特别耗时的shuffle操作的作业,建议增加重试最大次数（比如60次）</span><br><span class="line">以避免由于JVM的full gc或者网络不稳定等因素导致的数据拉取失败.在实践中发现,</span><br><span class="line">对于针对超大数据量（数十亿~上百亿）的shuffle过程,调节该参数可以大幅度提升稳定性.</span><br><span class="line"></span><br><span class="line">4. spark.shuffle.io.retryWait</span><br><span class="line">默认值：5s</span><br><span class="line">参数说明：具体解释同上,该参数代表了每次重试拉取数据的等待间隔,默认是5s.</span><br><span class="line"></span><br><span class="line">调优建议：建议加大间隔时长（比如60s）,以增加shuffle操作的稳定性.</span><br><span class="line"></span><br><span class="line">5. spark.shuffle.memoryFraction</span><br><span class="line">默认值：0.2</span><br><span class="line">参数说明：该参数代表了Executor内存中,分配给shuffle read task进行聚合操作的内存比例,默认是20%.</span><br><span class="line"></span><br><span class="line">调优建议：在资源调优中讲解过这个参数.如果内存充足,而且很少使用持久化操作,建议调高这个比例,给shuffle read的聚合操作更多内存,以避免由于内存不足导致聚合过程中频繁读写磁盘.在实践中发现,合理调节该参数可以将性能提升10%左右.</span><br><span class="line"></span><br><span class="line">6. spark.shuffle.manager</span><br><span class="line">默认值：sort</span><br><span class="line">参数说明：该参数用于设置ShuffleManager的类型.Spark 1.5以后,有三个可选项：</span><br><span class="line">hash、sort和tungsten-sort.HashShuffleManager是Spark 1.2以前的默认选项,</span><br><span class="line">但是Spark 1.2以及之后的版本默认都是SortShuffleManager了.tungsten-sort</span><br><span class="line">与sort类似,但是使用了tungsten计划中的堆外内存管理机制,内存使用效率更高.</span><br><span class="line"></span><br><span class="line">调优建议：由于SortShuffleManager默认会对数据进行排序,因此如果你的</span><br><span class="line">业务逻辑中需要该排序机制的话,则使用默认的SortShuffleManager就可以；</span><br><span class="line">而如果你的业务逻辑不需要对数据进行排序,那么建议参考后面的几个参数调优,</span><br><span class="line">通过bypass机制或优化的HashShuffleManager来避免排序操作,同时提供较好的磁盘读写性能.这里要注意的是,tungsten-sort要慎用,因为之前发现了一些相应的bug.</span><br><span class="line"></span><br><span class="line">7. spark.shuffle.sort.bypassMergeThreshold</span><br><span class="line">默认值：200</span><br><span class="line">参数说明：当ShuffleManager为SortShuffleManager时,如果shuffle read task的</span><br><span class="line">数量小于这个阈值（默认是200）,则shuffle write过程中不会进行排序操作,</span><br><span class="line">而是直接按照未经优化的HashShuffleManager的方式去写数据,但是最后会将每个</span><br><span class="line">task产生的所有临时磁盘文件都合并成一个文件,并会创建单独的索引文件.</span><br><span class="line"></span><br><span class="line">调优建议：当你使用SortShuffleManager时,如果的确不需要排序操作,那么建议</span><br><span class="line">将这个参数调大一些,大于shuffle read task的数量.那么此时就会自动启用</span><br><span class="line">bypass机制,map-side就不会进行排序了,减少了排序的性能开销.但是这种方式下,</span><br><span class="line">依然会产生大量的磁盘文件,因此shuffle write性能有待提高.</span><br><span class="line"></span><br><span class="line">8. spark.shuffle.consolidateFiles</span><br><span class="line">默认值：false</span><br><span class="line">参数说明：如果使用HashShuffleManager,该参数有效.如果设置为true,</span><br><span class="line">那么就会开启consolidate机制,会大幅度合并shuffle write的输出文件,</span><br><span class="line">对于shuffle read task数量特别多的情况下,这种方法可以极大地减少磁盘IO开销,提升性能.</span><br><span class="line"></span><br><span class="line">调优建议：如果的确不需要SortShuffleManager的排序机制,那么除了使用</span><br><span class="line">bypass机制,还可以尝试将spark.shffle.manager参数手动指定为hash,</span><br><span class="line">使用HashShuffleManager,同时开启consolidate机制.在实践中尝试过,发现其性能比开启了bypass机制的SortShuffleManager要高出10%~30%.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>The Hadoop Ecosystem</category>
        <category>Learning Spark</category>
      </categories>
      <tags>
        <tag>Work Systematically</tag>
      </tags>
  </entry>
  <entry>
    <title>数据仓库1.0</title>
    <url>/2020/12/10/Data-System-Warehouse/</url>
    <content><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>​     As the number of users increases, the volume of business and data also increases.In order to improve the company’s business<br>conversion rate and operation, building a data warehousecan better manage and maintain user behavior data, and conduct<br>statistical analysis on users’ online access behavior, consumption behavior and business behavior to support the company’s operation.</p>
<h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><blockquote>
<p><a href="https://github.com/nino-laiqiu/TiTan">https://github.com/nino-laiqiu/TiTan</a></p>
</blockquote>
<h3 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h3><blockquote>
<p><a href="https://www.jianshu.com/u/231b91963a0e">https://www.jianshu.com/u/231b91963a0e</a></p>
</blockquote>
<h3 id="Technology-Selection"><a href="#Technology-Selection" class="headerlink" title="Technology Selection"></a>Technology Selection</h3><p>Data acquisition and transmission :Flume Kafka Sqoop</p>
<p>Storage :Hdfs Mysql  Hbase Redis</p>
<p>Calculate :Hive Spark MapReduce</p>
<p>Inquire :Presto Kylin</p>
<p>Visualization :Superset Sersors</p>
<p>Scheduling:Azkaban</p>
<p>Metadata management:Atlas</p>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><p>Explain the project and sort out the actual production process.<br>The process of collecting behavioral data from the log server, collecting business data from the business database to the data<br>warehouse, and the architecture of the data warehouse and the association of various tables are briefly explained</p>
<blockquote>
<p><a href="https://www.jianshu.com/writer#/notebooks/48164698/notes/81982588">https://www.jianshu.com/writer#/notebooks/48164698/notes/81982588</a></p>
</blockquote>
<h1 id="ODS-gt-DWD-用户行为数据分析"><a href="#ODS-gt-DWD-用户行为数据分析" class="headerlink" title="ODS -&gt; DWD(用户行为数据分析)"></a>ODS -&gt; DWD(用户行为数据分析)</h1><h3 id="维度集成"><a href="#维度集成" class="headerlink" title="维度集成"></a>维度集成</h3><h5 id="GeoHash编码"><a href="#GeoHash编码" class="headerlink" title="GeoHash编码"></a>GeoHash编码</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//经纬度字典表存入数据库</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Geo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().config(conf).getOrCreate()</span><br><span class="line">    <span class="keyword">val</span> rdd = spark.sparkContext.textFile(<span class="string">&quot;file:///C:\\Users\\hp\\IdeaProjects\\TiTan\\dataware\\src\\main\\resources\\geodict.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">val</span> maprdd = rdd.map(data =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> txt = data.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> str = txt(<span class="number">4</span>).split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">      <span class="comment">//第一个是维度 第二个是精度</span></span><br><span class="line">      <span class="keyword">val</span> geo: <span class="type">String</span> = <span class="type">GeoHash</span>.withCharacterPrecision(txt(<span class="number">3</span>).toDouble, txt(<span class="number">2</span>).toDouble, <span class="number">6</span>).toBase32</span><br><span class="line">      (geo, str(<span class="number">0</span>), str(<span class="number">1</span>), str(<span class="number">2</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">val</span> frame = maprdd.toDF(<span class="string">&quot;geo&quot;</span>, <span class="string">&quot;province&quot;</span>, <span class="string">&quot;city&quot;</span>, <span class="string">&quot;district&quot;</span>)</span><br><span class="line">    frame.write.format(<span class="string">&quot;jdbc&quot;</span>)</span><br><span class="line">      <span class="comment">// 注意格式</span></span><br><span class="line">      .option(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;jdbc:mysql://linux03:3306/db_demo1?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&quot;</span>)</span><br><span class="line">      .option(<span class="string">&quot;dbtable&quot;</span>, <span class="string">&quot;geo&quot;</span>)</span><br><span class="line">      .option(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>)</span><br><span class="line">      .option(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">      .mode(<span class="string">&quot;append&quot;</span>)</span><br><span class="line">      .save()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="IDMapping"><a href="#IDMapping" class="headerlink" title="IDMapping"></a>IDMapping</h3><h5 id="方案一-IDBind评分"><a href="#方案一-IDBind评分" class="headerlink" title="方案一:IDBind评分"></a>方案一:IDBind评分</h5><p><strong>步骤</strong></p>
<p>score表的构成deviceID account score timestamp<br>1.创建今天的bind表:<br>由两个部分union all 组成<br>第一部分:今天的新设备<br>过滤出今天表没有account的数据,与昨天的bind表join 并且deviceid is null<br>第二部分今天的账号不为空的的数据(都为空没有讨论的必要)<br>要点:如何设置表的字段<br><strong>设备只要昨天出现过就取昨天的,否则今天的<br>账号只要昨天出现过就取昨天的,否则今天的<br>时间戳取最大的<br>score(今天deviceid和昨天都出现则分数相加,今天出现昨天没有分数不变,今天没有出现昨天出现分数衰减)</strong></p>
<p>2.创建今天guid字段<br>获取今天的评分表,获取同一个设备组的最大分数数据,今天的log表与这个处理过的评分表left join<br>规则:<br><strong>如果今天的account不为空guid就取这个<br>否则获取评分表的account,guid为评分表的account,这个情况是处理没有今天数据没有account字段的情况<br>否则其他情况guid就是今天的设备号</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IdBindMappingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  每日滚动更新： 设备和账号的绑定评分（表）</span></span><br><span class="line"><span class="comment">    设备id,登录账号,绑定得分,最近一次登录时间戳</span></span><br><span class="line"><span class="comment">    deviceid,account,score,ts</span></span><br><span class="line"><span class="comment">    这个数据的加工，应该是一个逐日滚动计算的方式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    具体计算逻辑：</span></span><br><span class="line"><span class="comment">        1. 加载 T-1 日的绑定评分表</span></span><br><span class="line"><span class="comment">        2. 计算  T日的  &quot;设备-账号绑定评分&quot;</span></span><br><span class="line"><span class="comment">        3. 综合 T-1日 和 T日的  绑定评分数据得到 T日的绑定评分数据最终结果</span></span><br><span class="line"><span class="comment">    T日的设备-账号绑定评分，得分规则：  每登录一次，+100分</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    两日数据综合合并的逻辑</span></span><br><span class="line"><span class="comment">    T-1 日</span></span><br><span class="line"><span class="comment">    d01,a01,900</span></span><br><span class="line"><span class="comment">    d02,a02,800</span></span><br><span class="line"><span class="comment">    d01,a11,600</span></span><br><span class="line"><span class="comment">    d03,a03,700</span></span><br><span class="line"><span class="comment">    d04,a04,600</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    T日</span></span><br><span class="line"><span class="comment">    d01,a01,200</span></span><br><span class="line"><span class="comment">    d03,a03,100</span></span><br><span class="line"><span class="comment">    d03,a13,100</span></span><br><span class="line"><span class="comment">    d06,a06,200</span></span><br><span class="line"><span class="comment">    d06,a04,100*/</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">WARN</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().enableHiveSupport().config(<span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span></span><br><span class="line">      .getClass.getSimpleName).setMaster(<span class="string">&quot;local[*]&quot;</span>)).getOrCreate()</span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line">    <span class="keyword">val</span> schema = <span class="keyword">new</span> <span class="type">StructType</span>(<span class="type">Array</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;deviceid&quot;</span>, <span class="type">DataTypes</span>.<span class="type">StringType</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;account&quot;</span>, <span class="type">DataTypes</span>.<span class="type">StringType</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;timestamp&quot;</span>, <span class="type">DataTypes</span>.<span class="type">DoubleType</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">&quot;sessionid&quot;</span>, <span class="type">DataTypes</span>.<span class="type">StringType</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> file = spark.read.format(<span class="string">&quot;csv&quot;</span>).option(<span class="string">&quot;header&quot;</span>, <span class="literal">false</span>.toString).schema(schema).load(<span class="string">&quot;file:///C:\\Users\\hp\\IdeaProjects\\TiTan\\dataware\\src\\main\\resources\\idbind.csv&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> frame = file.select(<span class="string">&quot;deviceid&quot;</span>, <span class="string">&quot;account&quot;</span>, <span class="string">&quot;timestamp&quot;</span>, <span class="string">&quot;sessionid&quot;</span>)</span><br><span class="line">    frame.createTempView(<span class="string">&quot;cur_day_log&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  deviceid,account,timestamp,sessionid</span></span><br><span class="line"><span class="comment">        d01,a01,12235,s01</span></span><br><span class="line"><span class="comment">        d01,a01,12266,s01</span></span><br><span class="line"><span class="comment">        d01,a01,12345,s02</span></span><br><span class="line"><span class="comment">        d01,a01,12368,s02</span></span><br><span class="line"><span class="comment">        d01,,12345,s03</span></span><br><span class="line"><span class="comment">        d01,,12376,s03</span></span><br><span class="line"><span class="comment">        d02,a02,12445,s04</span></span><br><span class="line"><span class="comment">        d02,a02,12576,s04</span></span><br><span class="line"><span class="comment">        d03,a03,13345,s05</span></span><br><span class="line"><span class="comment">        d03,a03,13376,s05</span></span><br><span class="line"><span class="comment">        d04,,14786,s06</span></span><br><span class="line"><span class="comment">        d04,,14788,s06*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 最好将这些标识数据写入到hive中进行查询与覆盖</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo 按设备和账号来分组,存在一次就+100分 ---- 今天的绑定评分</span></span><br><span class="line">    <span class="keyword">val</span> today_temp = spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |deviceid,account,cast(count(distinct sessionid ) * 100 as double) as score ,max(timestamp) as  timestamp</span></span><br><span class="line"><span class="string">        |from cur_day_log</span></span><br><span class="line"><span class="string">        |group by deviceid,account</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line"></span><br><span class="line">    today_temp</span><br><span class="line">      <span class="comment">// TODO  此处过滤出没有账号登录的log,为什么?</span></span><br><span class="line">      <span class="comment">// TODO 生成今天的评分表,过滤出账号为空的记录,假设这个设备正好是新设备,</span></span><br><span class="line">      <span class="comment">//   确实要过滤出来防止重复,如果不是新的设备那么之前的score表一定有记录</span></span><br><span class="line"></span><br><span class="line">      .where(<span class="string">&quot;trim(account) != &#x27;&#x27; and account is not null&quot;</span>)</span><br><span class="line">      .select(<span class="string">&quot;deviceid&quot;</span>, <span class="string">&quot;account&quot;</span>, <span class="string">&quot;score&quot;</span>, <span class="string">&quot;timestamp&quot;</span>)</span><br><span class="line">      .createTempView(<span class="string">&quot;today_score&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 测试 != null 和 is not null</span></span><br><span class="line"><span class="comment">     spark.sql(</span></span><br><span class="line"><span class="comment">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">          |select</span></span><br><span class="line"><span class="comment">          |deviceid,account,cast(count(distinct sessionid ) * 100 as double) as score ,max(timestamp) as  timestamp</span></span><br><span class="line"><span class="comment">          |from cur_day_log</span></span><br><span class="line"><span class="comment">          |group by deviceid,account</span></span><br><span class="line"><span class="comment">          |&quot;&quot;&quot;.stripMargin).where(&quot;trim(account) != &#x27;&#x27; and account != null&quot;).show()*/</span></span><br><span class="line"></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select * from  today_score</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin).show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 昨天的绑定评分表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> preFrame = spark.read.format(<span class="string">&quot;csv&quot;</span>).option(<span class="string">&quot;header&quot;</span>, <span class="literal">true</span>.toString).load(<span class="string">&quot;file:///C:\\Users\\hp\\IdeaProjects\\TiTan\\dataware\\src\\main\\resources\\idscore.csv&quot;</span>)</span><br><span class="line">    preFrame.selectExpr(<span class="string">&quot;deviceid&quot;</span>, <span class="string">&quot;account&quot;</span>, <span class="string">&quot;cast(timestamp as double) as timestamp &quot;</span>, <span class="string">&quot;cast(score as double) as score&quot;</span>)</span><br><span class="line">      .createTempView(<span class="string">&quot;last_score&quot;</span>)</span><br><span class="line"></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select * from  last_score</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin).show()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 整合昨天和今天的评分表,临时</span></span><br><span class="line">    <span class="comment">// 历史出现 今天出现 评分相加(取昨天的)</span></span><br><span class="line">    <span class="comment">// 历史出现 今天不出现 评分衰减(取昨天的)</span></span><br><span class="line">    <span class="comment">// 历史不出现 今天出现  取今天的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> score_temp = spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |nvl(pre.deviceid,cur.deviceid) as deviceid, -- 设备</span></span><br><span class="line"><span class="string">        |nvl(pre.account,cur.account) as account, -- 账号</span></span><br><span class="line"><span class="string">        |nvl(cur.timestamp,pre.timestamp) as timestamp, -- 最近一次访问时间戳</span></span><br><span class="line"><span class="string">        |case</span></span><br><span class="line"><span class="string">        |when pre.deviceid is not null and cur.deviceid is not null then pre.score+cur.score</span></span><br><span class="line"><span class="string">        |when pre.deviceid is not null and cur.deviceid is null then pre.score*0.5</span></span><br><span class="line"><span class="string">        |when pre.deviceid is  null and cur.deviceid is not  null then cur.score</span></span><br><span class="line"><span class="string">        |end as score</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |last_score pre</span></span><br><span class="line"><span class="string">        |full join</span></span><br><span class="line"><span class="string">        |today_score cur</span></span><br><span class="line"><span class="string">        |on pre.deviceid = cur.deviceid and  pre.account = cur.account</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 今天临时的评分表,没有新设备,已经过滤掉了</span></span><br><span class="line">    score_temp.createTempView(<span class="string">&quot;score_temp&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  TODO 定义今天的新设备 与昨天left join</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出今天账号为null或者空的数据,与昨天的评分表join且deviceid is  null,获取新的设备</span></span><br><span class="line">    today_temp</span><br><span class="line">      <span class="comment">// 注意这里是 or</span></span><br><span class="line">      .where(<span class="string">&quot;trim(account) = &#x27;&#x27; or account is  null&quot;</span>).createTempView(<span class="string">&quot;cur_may_new&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//与昨天left join 取出 昨天设备为null的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意字段的对齐</span></span><br><span class="line">    <span class="comment">//获取今天的新的设备与临时的没有新设备的进行union all</span></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |a.deviceid,</span></span><br><span class="line"><span class="string">        |a.account,</span></span><br><span class="line"><span class="string">        |a.timestamp,</span></span><br><span class="line"><span class="string">        |a.score</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |cur_may_new a</span></span><br><span class="line"><span class="string">        |left join last_score b</span></span><br><span class="line"><span class="string">        |on a.deviceid = b.deviceid</span></span><br><span class="line"><span class="string">        |where b.deviceid is  null</span></span><br><span class="line"><span class="string">        |</span></span><br><span class="line"><span class="string">        |union all</span></span><br><span class="line"><span class="string">        |select deviceid,account,timestamp,score from  score_temp</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin).show()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存在把两个用户识别为同一个人是可能性</span></span><br><span class="line">    <span class="comment">// join计算量大</span></span><br><span class="line">    <span class="comment">// 评分衰减加权规则不合理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="方案二-图计算"><a href="#方案二-图计算" class="headerlink" title="方案二:图计算"></a>方案二:图计算</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">GraphxUniqueLdentification</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().config(<span class="keyword">new</span> <span class="type">SparkConf</span>())</span><br><span class="line">      .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">      .enableHiveSupport()</span><br><span class="line">      .master(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">      .getOrCreate()</span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line">    <span class="keyword">val</span> frame = spark.read.table(<span class="string">&quot;db_demo1.app_event_log&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dataFrame = frame.select(<span class="string">&quot;account&quot;</span>, <span class="string">&quot;deviceId&quot;</span>)</span><br><span class="line">    <span class="comment">//暂时的一个用户标识</span></span><br><span class="line">    <span class="keyword">val</span> temporaryOne: <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">String</span>]] = dataFrame.rdd.map(row =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> account = row.getAs[<span class="type">String</span>](<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">val</span> deviceId = row.getAs[<span class="type">String</span>](<span class="number">1</span>)</span><br><span class="line">      <span class="type">Array</span>(account, deviceId).filter(<span class="type">StringUtils</span>.isNotBlank(_))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//println(temporaryOne.collect().length)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 构造图的点和边</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> today_dot: <span class="type">RDD</span>[(<span class="type">Long</span>, <span class="type">String</span>)] = temporaryOne.flatMap(arr =&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (element &lt;- arr) <span class="keyword">yield</span> (element.hashCode.toLong, element)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> today_side: <span class="type">RDD</span>[<span class="type">Edge</span>[<span class="type">String</span>]] = temporaryOne.flatMap(arr =&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to arr.length - <span class="number">2</span>; j &lt;- i + <span class="number">1</span> until arr.length) <span class="keyword">yield</span> <span class="type">Edge</span>(arr(i).hashCode.toLong, arr(j).hashCode.toLong, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125;).map((_, <span class="number">1</span>))</span><br><span class="line">      .reduceByKey(_ + _)</span><br><span class="line">      .filter(_._2 &gt; <span class="number">2</span>)</span><br><span class="line">      .map(_._1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 这里是把第一次的日志获取的用户标签写入到hive中</span></span><br><span class="line">    <span class="comment">//firstOneGuid(today_dot,today_side)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 生成今天的 DUID &amp;&amp; 用户标签写入到hive中</span></span><br><span class="line">    <span class="comment">//today_Guid(today_dot,today_side)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO  将今日的图计算结果与昨天的结果进行比对,如果最小的 guid 出现在今天了,则替换为昨天的guid</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别读取hive表中的用户标签字段</span></span><br><span class="line">    <span class="keyword">val</span> last_identifying: collection.<span class="type">Map</span>[<span class="type">VertexId</span>, <span class="type">VertexId</span>] = spark.read.table(<span class="string">&quot;dw.graphData&quot;</span>).select(<span class="string">&quot;identifying_hash&quot;</span>, <span class="string">&quot;guid&quot;</span>).where(<span class="string">&quot;dy=&#x27;2020-12-16&#x27;&quot;</span>).rdd</span><br><span class="line">      .map(row =&gt; &#123;</span><br><span class="line">        (row.getAs[<span class="type">VertexId</span>](<span class="number">0</span>), row.getAs[<span class="type">VertexId</span>](<span class="number">1</span>))</span><br><span class="line">      &#125;)</span><br><span class="line">      .collectAsMap()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把昨天的标签数据广播出去 把今天的数据按照guid按照分组</span></span><br><span class="line">    <span class="keyword">val</span> last_identifying_broadcast = spark.sparkContext.broadcast(last_identifying)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> today_identifying: <span class="type">RDD</span>[(<span class="type">VertexId</span>, <span class="type">VertexId</span>)] = spark.read.table(<span class="string">&quot;dw.graphData&quot;</span>).select(<span class="string">&quot;identifying_hash&quot;</span>, <span class="string">&quot;guid&quot;</span>).where(<span class="string">&quot;dy=&#x27;2020-12-17&#x27;&quot;</span>).rdd</span><br><span class="line">      .map(row =&gt; &#123;</span><br><span class="line">        (row.getAs[<span class="type">VertexId</span>](<span class="string">&quot;guid&quot;</span>), row.getAs[<span class="type">VertexId</span>](<span class="string">&quot;identifying_hash&quot;</span>))</span><br><span class="line">      &#125;)</span><br><span class="line">      .groupByKey()</span><br><span class="line">      .mapPartitions(iter =&gt; &#123;</span><br><span class="line">        <span class="comment">//获取映射字典</span></span><br><span class="line">        <span class="keyword">val</span> idmpMap = last_identifying_broadcast.value</span><br><span class="line">        iter.map(tp =&gt; &#123;</span><br><span class="line">          <span class="keyword">var</span> guid = tp._1</span><br><span class="line">          <span class="keyword">val</span> identifying_hash = tp._2</span><br><span class="line">          <span class="keyword">var</span> findmin_guid = <span class="literal">false</span></span><br><span class="line">          <span class="keyword">for</span> (elem &lt;- identifying_hash <span class="keyword">if</span> !findmin_guid) &#123;</span><br><span class="line">            <span class="comment">//如果在今日存在 昨天的那个最小的guid 那么就把今天的guid替换为昨天的那个</span></span><br><span class="line">            <span class="keyword">val</span> maybeId: <span class="type">Option</span>[<span class="type">VertexId</span>] = idmpMap.get(elem)</span><br><span class="line">            <span class="keyword">if</span> (maybeId.isDefined) &#123;</span><br><span class="line">              guid = maybeId.get</span><br><span class="line">              findmin_guid = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          (guid, identifying_hash)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;).flatMap(tp =&gt; &#123;</span><br><span class="line">      <span class="comment">//扁平化</span></span><br><span class="line">      <span class="keyword">val</span> guid = tp._1</span><br><span class="line">      <span class="keyword">val</span> identifying_hash = tp._2</span><br><span class="line">      <span class="keyword">for</span> (elem &lt;- identifying_hash) <span class="keyword">yield</span> (elem, guid)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//today_identifying.toDF(&quot;identifying_hash&quot;, &quot;guid&quot;).show(20)</span></span><br><span class="line">    <span class="comment">//把数据写入到hive表中,覆盖今天的标签表</span></span><br><span class="line">    today_identifying.toDF(<span class="string">&quot;identifying_hash&quot;</span>, <span class="string">&quot;guid&quot;</span>).createTempView(<span class="string">&quot;graph&quot;</span>)</span><br><span class="line"></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |insert overwrite table  dw.graphData   partition(dy=&#x27;2020-12-17&#x27;)</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |identifying_hash,guid</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |graph</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">today_Guid</span></span>(today_dot: <span class="type">RDD</span>[(<span class="type">Long</span>, <span class="type">String</span>)], today_side: <span class="type">RDD</span>[<span class="type">Edge</span>[<span class="type">String</span>]]) &#123;</span><br><span class="line">      <span class="comment">// TODO  读取上一日的生成的标签字段</span></span><br><span class="line">      <span class="keyword">val</span> oneday_identifying: <span class="type">RDD</span>[<span class="type">Row</span>] = spark.read.table(<span class="string">&quot;dw.graphData&quot;</span>).select(<span class="string">&quot;identifying_hash&quot;</span>, <span class="string">&quot;guid&quot;</span>).where(<span class="string">&quot;dy=&#x27;2020-12-16&#x27;&quot;</span>).rdd</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> last_dot: <span class="type">RDD</span>[(<span class="type">VertexId</span>, <span class="type">String</span>)] = oneday_identifying.map(row =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> identifying_hash = row.getAs[<span class="type">VertexId</span>](<span class="number">0</span>)</span><br><span class="line">        (identifying_hash, <span class="string">&quot;&quot;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> last_side: <span class="type">RDD</span>[<span class="type">Edge</span>[<span class="type">String</span>]] = oneday_identifying.map(row =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> scr: <span class="type">VertexId</span> = row.getAs[<span class="type">VertexId</span>](<span class="string">&quot;identifying_hash&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> dst = row.getAs[<span class="type">VertexId</span>](<span class="string">&quot;guid&quot;</span>)</span><br><span class="line">        <span class="type">Edge</span>(scr, dst, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 构建图</span></span><br><span class="line">      <span class="keyword">val</span> graph = <span class="type">Graph</span>(today_dot.union(last_dot), today_side.union(last_side))</span><br><span class="line">      graph.connectedComponents().vertices.toDF(<span class="string">&quot;identifying_hash&quot;</span>, <span class="string">&quot;guid&quot;</span>).createTempView(<span class="string">&quot;graph&quot;</span>)</span><br><span class="line"></span><br><span class="line">      spark.sql(</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">          |insert  into  table  dw.graphData   partition(dy=&#x27;2020-12-17&#x27;)</span></span><br><span class="line"><span class="string">          |select</span></span><br><span class="line"><span class="string">          |identifying_hash,guid</span></span><br><span class="line"><span class="string">          |from</span></span><br><span class="line"><span class="string">          |graph</span></span><br><span class="line"><span class="string">          |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstOneGuid</span></span>(dot: <span class="type">RDD</span>[(<span class="type">Long</span>, <span class="type">String</span>)], side: <span class="type">RDD</span>[<span class="type">Edge</span>[<span class="type">String</span>]]) &#123;</span><br><span class="line">      <span class="keyword">val</span> graph = <span class="type">Graph</span>(dot, side)</span><br><span class="line">      <span class="keyword">val</span> conngraph = graph.connectedComponents().vertices</span><br><span class="line">      <span class="comment">// todo 此处的guid是标识中的最小的值,我们可以把这个guid替换为一个生成的唯一的UUID来作为一个guid</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> graphDataFrame = conngraph.toDF(<span class="string">&quot;identifying_hash&quot;</span>, <span class="string">&quot;guid&quot;</span>)</span><br><span class="line">      graphDataFrame.createTempView(<span class="string">&quot;graph&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// TODO 把用户唯一标识库写入到hive表中</span></span><br><span class="line">      spark.sql(</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">          |insert  into  table  dw.graphData   partition(dy=&#x27;2020-12-16&#x27;)</span></span><br><span class="line"><span class="string">          |select</span></span><br><span class="line"><span class="string">          |identifying_hash,guid</span></span><br><span class="line"><span class="string">          |from</span></span><br><span class="line"><span class="string">          |graph</span></span><br><span class="line"><span class="string">          |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin).show()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="新老用户标识"><a href="#新老用户标识" class="headerlink" title="新老用户标识"></a>新老用户标识</h3><h5 id="方案一-布隆过滤器"><a href="#方案一-布隆过滤器" class="headerlink" title="方案一:布隆过滤器"></a>方案一:布隆过滤器</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试布隆过滤器</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">BloomFilterTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//hadoopBloom()</span></span><br><span class="line">    sparkBloom()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用hadoop的布隆过滤器</span></span><br><span class="line">  <span class="comment">// TODO 注意hadoop的序列化器和spark的序列化器不一致,要在config中指定序列化器</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hadoopBloom</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> filter = <span class="keyword">new</span> <span class="type">BloomFilter</span>(<span class="number">1000000</span>, <span class="number">5</span>, <span class="type">Hash</span>.<span class="type">MURMUR_HASH</span>)</span><br><span class="line">    filter.add(<span class="keyword">new</span> <span class="type">Key</span>(<span class="string">&quot;a&quot;</span>.getBytes()))</span><br><span class="line">    filter.add(<span class="keyword">new</span> <span class="type">Key</span>(<span class="string">&quot;b&quot;</span>.getBytes()))</span><br><span class="line">    filter.add(<span class="keyword">new</span> <span class="type">Key</span>(<span class="string">&quot;c&quot;</span>.getBytes()))</span><br><span class="line">    filter.add(<span class="keyword">new</span> <span class="type">Key</span>(<span class="string">&quot;d&quot;</span>.getBytes()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> bool = filter.membershipTest(<span class="keyword">new</span> <span class="type">Key</span>(<span class="string">&quot;a&quot;</span>.getBytes))</span><br><span class="line">    <span class="keyword">val</span> bool1 = filter.membershipTest(<span class="keyword">new</span> <span class="type">Key</span>(<span class="string">&quot;dwd&quot;</span>.getBytes))</span><br><span class="line">    println(bool)</span><br><span class="line">    println(bool1)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//使用spark的布隆过滤器</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sparkBloom</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().config(<span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="keyword">this</span>.getClass.getSimpleName)).getOrCreate()</span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">val</span> filter = spark.sparkContext.makeRDD(<span class="type">List</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>)).toDF(<span class="string">&quot;alphabet&quot;</span>).stat.bloomFilter(<span class="string">&quot;alphabet&quot;</span>, <span class="number">100000</span>, <span class="number">0.001</span>)</span><br><span class="line">    <span class="keyword">val</span> bool = filter.mightContain(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> bool1 = filter.mightContain(<span class="string">&quot;R&quot;</span>)</span><br><span class="line">    println(bool)</span><br><span class="line">    println(bool1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="方案二-Spark广播变量"><a href="#方案二-Spark广播变量" class="headerlink" title="方案二:Spark广播变量"></a>方案二:Spark广播变量</h5><p>把表中的deviceid account字段 广播出去即可,如果两个字段都存在则 isnew =1</p>
<h1 id="DWD-gt-DWS-用户行为数据分析"><a href="#DWD-gt-DWS-用户行为数据分析" class="headerlink" title="DWD -&gt; DWS(用户行为数据分析)"></a>DWD -&gt; DWS(用户行为数据分析)</h1><h3 id="流量-用户分析主题"><a href="#流量-用户分析主题" class="headerlink" title="流量/用户分析主题"></a>流量/用户分析主题</h3><h5 id="会话聚合表-轻度聚合"><a href="#会话聚合表-轻度聚合" class="headerlink" title="会话聚合表(轻度聚合)"></a>会话聚合表(轻度聚合)</h5><p>按用户会话粒度聚合可以支持多种报表,例如:访问次数,访问深度(定义包括重复的页面),跳出页,流量对比等</p>
<p>轻度聚合是对个体的统计,当然也只是个体某次会话的统计,统计个体只要对guid分组即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 从DWD表enent_app_detail,按照用户会话粒度聚合</span></span><br><span class="line"><span class="comment">-- 一次会话一个用户可能在不同的地点,这个来用第一个城市/地域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dw.traffic_aggr_session</span><br><span class="line">(</span><br><span class="line">    guid             <span class="keyword">string</span>,</span><br><span class="line">    session_id       <span class="keyword">string</span>,</span><br><span class="line">    start_time       <span class="built_in">bigint</span>,</span><br><span class="line">    end_time         <span class="built_in">bigint</span>,</span><br><span class="line">    in_page          <span class="keyword">string</span>,</span><br><span class="line">    out_page         <span class="keyword">string</span>,</span><br><span class="line">    pv_cnt           <span class="built_in">bigint</span>, <span class="comment">--  一次会话访问的页面的总数</span></span><br><span class="line">    isnew            <span class="built_in">int</span>,</span><br><span class="line">    hour_segment     <span class="built_in">int</span>,    <span class="comment">--  定义为start_time的访问hour,用来统计某时段的会话总数</span></span><br><span class="line">    province         <span class="keyword">string</span>,</span><br><span class="line">    city             <span class="keyword">string</span>,</span><br><span class="line">    district         <span class="keyword">string</span>,</span><br><span class="line">    device_type      <span class="keyword">string</span>,</span><br><span class="line">    release_channel  <span class="keyword">string</span>,</span><br><span class="line">    app_version      <span class="keyword">string</span>,</span><br><span class="line">    os_name          <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (dy  <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> parquet</span><br><span class="line">tblproperties(<span class="string">&quot;parquet.compress&quot;</span>=<span class="string">&quot;snappy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- HQL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> x <span class="keyword">as</span> (</span><br><span class="line">  <span class="keyword">select</span></span><br><span class="line">    guid, <span class="comment">-- 唯一标识(日活)</span></span><br><span class="line">    sessionId,</span><br><span class="line">    <span class="keyword">first_value</span>(<span class="string">`timeStamp`</span>) <span class="keyword">over</span> ( <span class="comment">--  timeStamp不规范</span></span><br><span class="line">      <span class="keyword">partition</span> <span class="keyword">by</span> guid,</span><br><span class="line">      sessionId</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">        <span class="string">`timeStamp`</span> <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span></span><br><span class="line">        <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span></span><br><span class="line">    ) <span class="keyword">as</span> start_time,</span><br><span class="line">    <span class="keyword">last_value</span>(<span class="string">`timeStamp`</span>) <span class="keyword">over</span> (</span><br><span class="line">      <span class="keyword">partition</span> <span class="keyword">by</span> guid,</span><br><span class="line">      sessionId</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">        <span class="string">`timeStamp`</span> <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span></span><br><span class="line">        <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span></span><br><span class="line">    ) <span class="keyword">as</span> end_time,</span><br><span class="line">    <span class="keyword">first_value</span>(properties [<span class="string">&#x27;pageid&#x27;</span>]) <span class="keyword">over</span> ( <span class="comment">-- 从map中获取访问的页面信息</span></span><br><span class="line">      <span class="keyword">partition</span> <span class="keyword">by</span> guid,</span><br><span class="line">      sessionId</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">        <span class="string">`timeStamp`</span> <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span></span><br><span class="line">        <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span></span><br><span class="line">    ) <span class="keyword">as</span> in_page,</span><br><span class="line">    <span class="keyword">last_value</span>(properties [<span class="string">&#x27;pageid&#x27;</span>]) <span class="keyword">over</span> (</span><br><span class="line">      <span class="keyword">partition</span> <span class="keyword">by</span> guid,</span><br><span class="line">      sessionId</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">        <span class="string">`timeStamp`</span> <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span></span><br><span class="line">        <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span></span><br><span class="line">    ) <span class="keyword">as</span> out_page,</span><br><span class="line">    newuser,</span><br><span class="line">    <span class="keyword">first_value</span>(province) <span class="keyword">over</span> (</span><br><span class="line">      <span class="keyword">partition</span> <span class="keyword">by</span> guid,</span><br><span class="line">      sessionId</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">        <span class="string">`timestamp`</span> <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span></span><br><span class="line">        <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span></span><br><span class="line">    ) <span class="keyword">as</span> province,</span><br><span class="line">    <span class="keyword">first_value</span>(city) <span class="keyword">over</span> (</span><br><span class="line">      <span class="keyword">partition</span> <span class="keyword">by</span> guid,</span><br><span class="line">      sessionId</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">        <span class="string">`timestamp`</span> <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span></span><br><span class="line">        <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span></span><br><span class="line">    ) <span class="keyword">as</span> city,</span><br><span class="line">    <span class="keyword">first_value</span>(district) <span class="keyword">over</span> (</span><br><span class="line">      <span class="keyword">partition</span> <span class="keyword">by</span> guid,</span><br><span class="line">      sessionId</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">        <span class="string">`timestamp`</span> <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span></span><br><span class="line">        <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span></span><br><span class="line">    ) <span class="keyword">as</span> district,</span><br><span class="line">    devicetype,</span><br><span class="line">    releasechannel,</span><br><span class="line">    appversion,</span><br><span class="line">    osName</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">    enent_app_detail</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    dy = <span class="string">&#x27;2020-12-11&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> eventid = <span class="string">&#x27;pageView&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span></span><br><span class="line">  <span class="keyword">table</span> dw.traffic_aggr_session <span class="keyword">partition</span>(dy = <span class="string">&#x27;2020-12-11&#x27;</span>)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  guid,</span><br><span class="line">  sessionId,</span><br><span class="line">  <span class="keyword">min</span>(start_time) <span class="keyword">as</span> start_time,</span><br><span class="line">  <span class="keyword">min</span>(end_time) <span class="keyword">as</span> end_time,</span><br><span class="line">  <span class="keyword">min</span>(in_page) <span class="keyword">as</span> in_page,</span><br><span class="line">  <span class="keyword">min</span>(out_page) <span class="keyword">as</span> out_page,</span><br><span class="line">  <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> pv_cnt,</span><br><span class="line">  <span class="keyword">min</span>(newuser) <span class="keyword">as</span> isnew,</span><br><span class="line">  <span class="keyword">hour</span>(</span><br><span class="line">    from_unixtime(<span class="keyword">cast</span>(<span class="keyword">min</span>(start_time) / <span class="number">1000</span> <span class="keyword">as</span> <span class="built_in">bigint</span>)) <span class="comment">-- 这里要把double转成bigint类型</span></span><br><span class="line">  ) <span class="keyword">as</span> hour_segment, <span class="comment">-- 此次在某时段访问的</span></span><br><span class="line">  <span class="keyword">min</span>(province) <span class="keyword">as</span> province,</span><br><span class="line">  <span class="keyword">min</span>(city) <span class="keyword">as</span> city,</span><br><span class="line">  <span class="keyword">min</span>(district) <span class="keyword">as</span> district,</span><br><span class="line">  <span class="keyword">min</span>(devicetype) <span class="keyword">as</span> device_type,</span><br><span class="line">  <span class="keyword">min</span>(releasechannel) <span class="keyword">as</span> release_channel,</span><br><span class="line">  <span class="keyword">min</span>(appversion) <span class="keyword">as</span> app_version,</span><br><span class="line">  <span class="keyword">min</span>(osname) <span class="keyword">as</span> os_name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  x</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">  guid,</span><br><span class="line">  sessionId</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="流量用户聚合表"><a href="#流量用户聚合表" class="headerlink" title="流量用户聚合表"></a>流量用户聚合表</h5><p>按用户维度进行聚合,是对会话维度聚合表进行进一步的聚合</p>
<h5 id="多维立方体-高阶聚合"><a href="#多维立方体-高阶聚合" class="headerlink" title="多维立方体(高阶聚合)"></a>多维立方体(高阶聚合)</h5><p>实际生产中在各种指标下的统计有各种维度组合,工作繁冗</p>
<p>关键要点:创建一个统一的目标维度,这个表应该包含所有的可能性维度字段</p>
<p>利用hive的高阶聚合函数,在一条SQL中实现可能的维度组合</p>
<p>高阶聚合不是对个体的统计,是对全局的统计</p>
<p><strong>with cube 函数包含所有可能的组合</strong></p>
<p><strong>grouping sets() 用户自定义所有可能的组合</strong></p>
<p><strong>with rollup 右到做递减多级的统计</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 多维组合表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dw.traffic_overview_cube(</span><br><span class="line">  province         <span class="keyword">string</span>,</span><br><span class="line">  city             <span class="keyword">string</span>,</span><br><span class="line">  district         <span class="keyword">string</span>,</span><br><span class="line">  device_type      <span class="keyword">string</span>,</span><br><span class="line">  release_channel  <span class="keyword">string</span>,</span><br><span class="line">  app_version      <span class="keyword">string</span>,</span><br><span class="line">  os_name          <span class="keyword">string</span>,</span><br><span class="line">  hour_segment     <span class="built_in">int</span>   ,</span><br><span class="line">  session_cnt      <span class="built_in">bigint</span>, <span class="comment">-- 会话总和</span></span><br><span class="line">  pv_cnt           <span class="built_in">bigint</span>, <span class="comment">-- 访问页面总和</span></span><br><span class="line">  acc_timelong     <span class="built_in">bigint</span>, <span class="comment">-- 访问总时长</span></span><br><span class="line">  uv_cnt           <span class="built_in">bigint</span>  <span class="comment">-- 访问总人数</span></span><br><span class="line">)</span><br><span class="line">partitioned <span class="keyword">by</span> (dy  <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> parquet</span><br><span class="line">tblproperties (<span class="string">&quot;parquet.compress&quot;</span>=<span class="string">&quot;snappy&quot;</span>)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shell脚本运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 高阶聚合表  traffic_aggr_session 到 traffic_overview_cube</span></span><br><span class="line">export HADOOP_HOME=/opt/hadoop/hadoop-3.1.1/</span><br><span class="line">export SPARK_HOME=/opt/spark/spark-3.0.1-bin/</span><br><span class="line">export HIVE_HOME=/opt/hive/hive-3.1.2/</span><br><span class="line"></span><br><span class="line">DT_CAL=\`date -d&#x27;-1 day&#x27; +%Y-%m-%d\`</span><br><span class="line"></span><br><span class="line">if [ $# -eq 1 ]</span><br><span class="line">then</span><br><span class="line">DT_CAL=$1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;准备启动任务，要计算的数据日期： $DT_CAL  ...........&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">HIVE_HOME/bin/hive -e <span class="string">&quot;</span></span></span><br><span class="line">insert into  table dw.traffic_overview_cube partition (dy=&#x27;$&#123;DT_CAL&#125;&#x27;)</span><br><span class="line">select</span><br><span class="line">  province,</span><br><span class="line">  city,</span><br><span class="line">  district,</span><br><span class="line">  device_type,</span><br><span class="line">  release_channel,</span><br><span class="line">  app_version,</span><br><span class="line">  os_name,</span><br><span class="line">  hour_segment,</span><br><span class="line">  count(1) as session_cnt, -- 会话总数</span><br><span class="line">  sum(pv_cnt) as pv_cnt,   -- 访问页面总数</span><br><span class="line">  sum(end_time - start_time) as time_long, -- 总访问时长</span><br><span class="line">  count( distinct guid) as  uv_cnt -- 访问用户总数</span><br><span class="line">from</span><br><span class="line">  dw.traffic_aggr_session</span><br><span class="line">where dy=&#x27;$&#123;DT_CAL&#125;&#x27;</span><br><span class="line">group by</span><br><span class="line">  province,</span><br><span class="line">  city,</span><br><span class="line">  district,</span><br><span class="line">  device_type,</span><br><span class="line">  release_channel,</span><br><span class="line">  app_version,</span><br><span class="line">  os_name,</span><br><span class="line">  hour_segment</span><br><span class="line">  grouping sets (</span><br><span class="line">    (),(province),</span><br><span class="line">    (province, city),</span><br><span class="line">    (province, city, district),</span><br><span class="line">    (device_type),</span><br><span class="line">    (release_channel),</span><br><span class="line">    (device_type, app_version),</span><br><span class="line">    (hour_segment),</span><br><span class="line">    (os_name, app_version)</span><br><span class="line">  );</span><br><span class="line">&quot;</span><br><span class="line"></span><br><span class="line">if [ $? -eq 0 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;&gt;&gt;&gt;&gt;   任务成功    &gt;&gt;&gt;&gt;      &quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;&gt;&gt;&gt;&gt;   任务失败 &gt;&gt;&gt;&gt;&gt;   &quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h3 id="用户活跃度分析主题"><a href="#用户活跃度分析主题" class="headerlink" title="用户活跃度分析主题"></a>用户活跃度分析主题</h3><h5 id="类拉链表"><a href="#类拉链表" class="headerlink" title="类拉链表"></a>类拉链表</h5><p>步骤一: dw.traffic_aggr_session会话表计算今天登录的用户guid</p>
<p>步骤二:昨天的活跃表与今天的日活表full join;计算的规则:</p>
<p>first_dt   guid   range_start 规则是一致的,只要昨天有那就是昨天的,否则今天的(这种情况是新用户了)</p>
<p>range_end 规则:如果昨天登录了,今天没有登录,那就昨天日期,连续中断要封存,如果昨天没有但是有那就今天的(新用户),其他情况一律是昨天日期(昨天用户今天没有登录的情形,封闭区间保持原样)</p>
<p>步骤三:一种情形没有full jion上:之前存在的用户今天登陆的( max(range_end) != ‘9999-12-31’),所以要union all  </p>
<p>从活跃表中获取这种用户的guid和first_dt与日活表left semi join </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 类拉链表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dw.user_act_range(</span><br><span class="line">first_dt    <span class="keyword">string</span>,</span><br><span class="line">guid        <span class="keyword">string</span>,</span><br><span class="line">range_start <span class="keyword">string</span>,</span><br><span class="line">range_end   <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">partitioned <span class="keyword">by</span> (dt <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> parquet</span><br><span class="line">tblproperties (<span class="string">&quot;parquet.compress&quot;</span>=<span class="string">&quot;snappy&quot;</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取今日登陆的人数</span></span><br><span class="line"><span class="comment">-- 如果range_end都封闭了,但是今天登陆了,是不会出现在这里的,考虑使用 union all</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  nvl(pre.first_dt, cur.cur_time) <span class="keyword">as</span> first_dt,</span><br><span class="line">  <span class="comment">-- 如果之前存在那就取之前,之前不存在那就是新用户了</span></span><br><span class="line">  nvl(pre.guid, cur.guid) <span class="keyword">as</span> guid,</span><br><span class="line">  nvl(pre.range_start, cur.cur_time) <span class="keyword">as</span> range_start,</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">when</span> pre.range_end = <span class="string">&#x27;9999-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">and</span> cur.cur_time <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">then</span> pre.pre_time <span class="comment">--  昨天登录,今天没有登录</span></span><br><span class="line">  <span class="keyword">when</span> pre.range_end <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">then</span> cur.cur_time <span class="comment">-- 新用户(jion不上的)</span></span><br><span class="line">  <span class="keyword">else</span> pre.range_end <span class="comment">-- 封闭区间保持原样</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">as</span> range_end</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      first_dt,</span><br><span class="line">      guid,</span><br><span class="line">      range_start,</span><br><span class="line">      range_end,</span><br><span class="line">      dy <span class="keyword">as</span> pre_time</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      dw.user_act_range</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">      dy = <span class="string">&#x27;2020-12-10&#x27;</span></span><br><span class="line">  ) pre <span class="keyword">full</span></span><br><span class="line">  <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      guid,</span><br><span class="line">      <span class="keyword">max</span>(dy) <span class="keyword">as</span> cur_time</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      dw.traffic_aggr_session</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">      dy = <span class="string">&#x27;2020-12-11&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">      guid</span><br><span class="line">  ) cur <span class="keyword">on</span> pre.guid = cur.guid</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">  <span class="comment">-- 从会话层获取今日登陆的用户</span></span><br><span class="line">  <span class="comment">-- range_end封闭且今日登陆的情况</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  first_dt <span class="keyword">as</span> first_dt,</span><br><span class="line">  o1.guid <span class="keyword">as</span> guid,</span><br><span class="line">  <span class="string">&#x27;2020-12-11&#x27;</span> <span class="keyword">as</span> range_start,</span><br><span class="line">  <span class="string">&#x27;9999-12-31&#x27;</span> <span class="keyword">as</span> range_end</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      guid,</span><br><span class="line">      first_dt</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      dw.user_act_range</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">      dy = <span class="string">&#x27;2020-12-10&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">      guid,</span><br><span class="line">      first_dt</span><br><span class="line">    <span class="keyword">having</span></span><br><span class="line">      <span class="keyword">max</span>(range_end) != <span class="string">&#x27;9999-12-31&#x27;</span></span><br><span class="line">  ) o1 <span class="comment">-- 从会话层取出今天登陆的所有用户</span></span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">semi</span></span><br><span class="line">  <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      guid</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      dw.traffic_aggr_session</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">      dy = <span class="string">&#x27;2020-12-11&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">      guid</span><br><span class="line">  ) o2 <span class="keyword">on</span> o1.guid = o2.guid</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 报表分析-连续活跃区间分布</span></span><br><span class="line"><span class="comment">-- 取最大的活跃区间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> x <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">datediff</span>(<span class="keyword">if</span>(range_end=<span class="string">&#x27;9999-12-31&#x27;</span>,<span class="string">&#x27;2020-12-29&#x27;</span>,range_end),<span class="keyword">if</span>(<span class="keyword">date_sub</span>(<span class="string">&#x27;2020-12-29&#x27;</span> , <span class="number">30</span>)&lt; range_start,range_start,<span class="keyword">date_sub</span>(<span class="string">&#x27;2020-12-29&#x27;</span>,<span class="number">30</span>)))) <span class="keyword">as</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">dw.user_act_range</span><br><span class="line"><span class="keyword">where</span> dy=<span class="string">&#x27;2020-12-17&#x27;</span> <span class="keyword">and</span> <span class="keyword">date_sub</span>(<span class="string">&#x27;2020-12-29&#x27;</span>,<span class="number">30</span>) &lt;= range_end</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> guid</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">if</span>(<span class="keyword">num</span>&lt;=<span class="number">10</span>,<span class="number">1</span>,<span class="literal">null</span>)) <span class="keyword">as</span> continous_10,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">if</span>(<span class="keyword">num</span>&gt;<span class="number">10</span> <span class="keyword">and</span> <span class="keyword">num</span>&lt;=<span class="number">20</span> ,<span class="number">1</span>,<span class="literal">null</span>)) <span class="keyword">as</span> continous_20,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">if</span>(<span class="keyword">num</span>&gt;<span class="number">20</span> <span class="keyword">and</span> <span class="keyword">num</span>&lt;=<span class="number">30</span> ,<span class="number">1</span>,<span class="literal">null</span>)) <span class="keyword">as</span> continous_30</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">x</span><br></pre></td></tr></table></figure>



<h5 id="bitMap思想"><a href="#bitMap思想" class="headerlink" title="bitMap思想"></a>bitMap思想</h5><p><strong>计算方案</strong><br>步骤一:去重按照guid datime<br>步骤二:按照guid来分组聚合<br>使用sum(pow(2,datediff(时间,dt))) 类型为double,sum的结果是登陆数的和<br>把上述的结果转换为bin() 说明最近登陆的在bitmap的最右边,考虑使用lpad()来补全<br>考虑使用reverse来反转,这样最左边就是最近登陆的天数<br>步骤三:更新这个bitmap表<br>与今天的表进行join,on guid<br>对这个bitmap进行补全,补全的规则如下:<br>substr(1,1,30),今天和bitmap表的都有则+1 今天有bitmap表无则是新的guid 今天无bitmap表有说明没有登录+0</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 测试数据</span></span><br><span class="line"><span class="comment">-- 假设有一张包含所有用户登陆信息的表 字段 dt guid,按照dt,guid进行聚合去重生成一张临时表dou,目的是要创建初始bitmap表</span></span><br><span class="line"><span class="comment">-- bitmap生成表报的思路:使用like函数,replace函数,split()函数即可解决用户登陆问题</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">reverse</span>(<span class="keyword">lpad</span>(<span class="keyword">bin</span>(<span class="keyword">cast</span>(<span class="keyword">sum</span>(<span class="keyword">pow</span>(<span class="number">2</span>,<span class="keyword">datediff</span>(<span class="string">&#x27;2020-11-18&#x27;</span>,dt))) <span class="keyword">as</span> <span class="built_in">bigint</span>)),<span class="number">31</span>,<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">db_demo1.dou</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> guid</span><br><span class="line"><span class="comment">-- 其实只要存储sum()的即可,上面用于计算</span></span><br><span class="line"><span class="comment">-- 更新今天的bitmap表,可能会有转换类型错误没有测试</span></span><br><span class="line"><span class="comment">-- 方案一:</span></span><br><span class="line"><span class="keyword">with</span> a <span class="keyword">as</span> (</span><br><span class="line">  <span class="keyword">select</span></span><br><span class="line">    <span class="comment">-- 会话视图层</span></span><br><span class="line">    guid</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">    dw.traffic_aggr_session</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    dy = <span class="string">&#x27;2020-12-17&#x27;</span></span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    guid</span><br><span class="line">),</span><br><span class="line">b <span class="keyword">as</span> (</span><br><span class="line">  <span class="keyword">select</span></span><br><span class="line">    <span class="comment">-- bitmap表</span></span><br><span class="line">    guid,</span><br><span class="line">    <span class="keyword">reverse</span>(<span class="keyword">lpad</span>(<span class="keyword">cast</span>(<span class="keyword">bin</span>(<span class="keyword">bitmap</span>) <span class="keyword">as</span> <span class="keyword">string</span>), <span class="number">31</span>, <span class="string">&#x27;0&#x27;</span>)) <span class="keyword">as</span> bitstr</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">    dw.bitmp_30d</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    dy = <span class="string">&#x27;2020-12-16&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span></span><br><span class="line">  <span class="keyword">table</span> dw.bitmp_30d <span class="keyword">partition</span>(dt = <span class="string">&#x27;2020-12-17&#x27;</span>)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  nvl(a.guid, b.guid) <span class="keyword">as</span> guid,</span><br><span class="line">  <span class="keyword">conv</span>(</span><br><span class="line">    <span class="comment">-- conv函数把二进制转为10进制</span></span><br><span class="line">    <span class="keyword">reverse</span>(</span><br><span class="line">      <span class="comment">-- 反转把最近登陆反转到结尾,离今天越近数值越小</span></span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">when</span> a.guid <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">      <span class="keyword">and</span> b.guid <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">then</span> <span class="keyword">concat</span>(<span class="string">&#x27;1&#x27;</span>, <span class="keyword">substr</span>(bitstr, <span class="number">1</span>, <span class="number">30</span>)) <span class="keyword">when</span> a.guid <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line">      <span class="keyword">and</span> b.guid <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">then</span> <span class="keyword">concat</span>(<span class="string">&#x27;0&#x27;</span>, <span class="keyword">substr</span>(bitstr, <span class="number">1</span>, <span class="number">30</span>)) <span class="keyword">when</span> b.guid <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">then</span> rpad(<span class="string">&#x27;1&#x27;</span>, <span class="number">31</span>, <span class="string">&#x27;0&#x27;</span>) <span class="keyword">end</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">  ) <span class="keyword">as</span> <span class="keyword">bitmap</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  a <span class="keyword">full</span></span><br><span class="line">  <span class="keyword">join</span> b <span class="keyword">on</span> a.guid = b.guid</span><br><span class="line"><span class="comment">-- 方案二:&amp;运算</span></span><br><span class="line"></span><br><span class="line">T+<span class="number">1</span>日，用户没活跃，则如下更新：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">bin</span>(<span class="number">1073741823</span> &amp; <span class="keyword">cast</span>(<span class="keyword">conv</span>(<span class="string">&#x27;111111111111111111111111111111&#x27;</span>,<span class="number">2</span>,<span class="number">10</span>)*<span class="number">2</span> <span class="keyword">as</span> <span class="built_in">int</span>));</span><br><span class="line"></span><br><span class="line">T+1日，用户活跃，则如下更新：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">bin</span>(<span class="number">1073741823</span> &amp; <span class="keyword">cast</span>(<span class="keyword">conv</span>(<span class="string">&#x27;111111111111111111111111111111&#x27;</span>,<span class="number">2</span>,<span class="number">10</span>)*<span class="number">2</span>+<span class="number">1</span> <span class="keyword">as</span> <span class="built_in">int</span>));</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="用户连续活跃分析"><a href="#用户连续活跃分析" class="headerlink" title="用户连续活跃分析"></a>用户连续活跃分析</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连续活跃天数</span></span><br><span class="line"><span class="comment">//guid,first_dt,rng_start,rng_end</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">UserActivityAnalysis</span> </span>&#123;</span><br><span class="line">  <span class="comment">//注意传入日期的格式:&#x27;2020-06-03&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().master(<span class="string">&quot;local[*]&quot;</span>).appName(<span class="keyword">this</span>.getClass.getSimpleName).getOrCreate()</span><br><span class="line">    <span class="keyword">val</span> dataFrame = spark.read.option(<span class="string">&quot;header&quot;</span>,<span class="literal">true</span>.toString).csv(<span class="string">&quot;file:///C:\\Users\\hp\\IdeaProjects\\TiTan\\dataware\\src\\main\\resources\\Useractivityanalysis.csv&quot;</span>)</span><br><span class="line">      .where(<span class="string">&quot;rng_end = &#x27;9999-12-31&#x27;&quot;</span>)</span><br><span class="line">      .selectExpr(<span class="string">&quot;cast(guid as int) &quot;</span>, <span class="string">s&quot;datediff(<span class="subst">$&#123;args(0)&#125;</span>,rng_start) as days&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">import</span>  spark.implicits._</span><br><span class="line">      <span class="comment">// 循环获取天数</span></span><br><span class="line">    dataFrame.show(<span class="number">100</span>,<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">val</span> value = dataFrame.rdd.flatMap(row =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> guid = row.getAs[<span class="type">Int</span>](<span class="string">&quot;guid&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> days = row.getAs[<span class="type">Int</span>](<span class="string">&quot;days&quot;</span>)</span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to days + <span class="number">1</span>) <span class="keyword">yield</span> (guid, i)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    value.toDF(<span class="string">&quot;guid&quot;</span>,<span class="string">&quot;days&quot;</span>).createTempView(<span class="string">&quot;UserActivity&quot;</span>)</span><br><span class="line"></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">s&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |$&#123;args(0)&#125; as dt,</span></span><br><span class="line"><span class="string">        |days ,--天数</span></span><br><span class="line"><span class="string">        |count(1) ,-- 人数</span></span><br><span class="line"><span class="string">        |collect_set(guid) -- 人</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |UserActivity</span></span><br><span class="line"><span class="string">        |group by days</span></span><br><span class="line"><span class="string">        |order by days</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin).show(<span class="number">100</span>,<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="用户访问间隔分析"><a href="#用户访问间隔分析" class="headerlink" title="用户访问间隔分析"></a>用户访问间隔分析</h5><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户访问间隔分析</span></span><br><span class="line"><span class="comment">//guid,first_dt,rng_start,rng_end</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">UserAccessInterval</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="keyword">this</span>.getClass.getSimpleName).master(<span class="string">&quot;local[*]&quot;</span>).getOrCreate()</span><br><span class="line">    <span class="keyword">val</span> schema = <span class="keyword">new</span> <span class="type">StructType</span>()</span><br><span class="line">      .add(<span class="string">&quot;guid&quot;</span>, <span class="type">DataTypes</span>.<span class="type">LongType</span>)</span><br><span class="line">      .add(<span class="string">&quot;first_dt&quot;</span>, <span class="type">DataTypes</span>.<span class="type">StringType</span>)</span><br><span class="line">      .add(<span class="string">&quot;rng_start&quot;</span>, <span class="type">DataTypes</span>.<span class="type">StringType</span>)</span><br><span class="line">      .add(<span class="string">&quot;rng_end&quot;</span>, <span class="type">DataTypes</span>.<span class="type">StringType</span>)</span><br><span class="line">    <span class="keyword">val</span> frame = spark.read.schema(schema).csv(<span class="string">&quot;file:///C:\\Users\\hp\\IdeaProjects\\TiTan\\dataware\\src\\main\\resources\\UserAccessInterval.csv&quot;</span>)</span><br><span class="line">    frame.createTempView(<span class="string">&quot;tmp&quot;</span>)</span><br><span class="line">    <span class="comment">/*1.过滤出rng_end时间与今天相比小于30的数据</span></span><br><span class="line"><span class="comment">    2.把rng_end为9999-12-31的日期改成2020-03-14</span></span><br><span class="line"><span class="comment">    3.如果first_dt与今天相比大于30天则更改为今天的日期-30,否则不变*/</span></span><br><span class="line">    <span class="keyword">val</span> frame1 = spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |  guid,</span></span><br><span class="line"><span class="string">        |  if(datediff(&#x27;2020-03-14&#x27;,rng_start)&gt;=30,date_sub(&#x27;2020-03-14&#x27;,30),rng_start) as rng_start,</span></span><br><span class="line"><span class="string">        |  if(rng_end = &#x27;9999-12-31&#x27;,&#x27;2020-03-14&#x27;,rng_end) as rng_end</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |  tmp</span></span><br><span class="line"><span class="string">        |where datediff(&#x27;2020-03-14&#x27;,rng_end) &lt;=30</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计登陆间隔</span></span><br><span class="line">    <span class="comment">//按用户来分组</span></span><br><span class="line">    <span class="keyword">val</span> guidrdd = frame1.rdd.map(row =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> guid = row.getAs[<span class="type">Long</span>](<span class="string">&quot;guid&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> rng_start = row.getAs[<span class="type">String</span>](<span class="string">&quot;rng_start&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> rng_end = row.getAs[<span class="type">String</span>](<span class="string">&quot;rng_end&quot;</span>)</span><br><span class="line">      (guid, (rng_start, rng_end))</span><br><span class="line">    &#125;).groupByKey()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> value = guidrdd.flatMap(data =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> guid = data._1</span><br><span class="line">      <span class="keyword">val</span> sorted = data._2.toList.sortBy(_._2)</span><br><span class="line">      <span class="comment">//统计间隔为0的次数</span></span><br><span class="line">      <span class="keyword">val</span> list: <span class="type">List</span>[(<span class="type">Long</span>, <span class="type">Int</span>, <span class="type">Int</span>)] = <span class="keyword">for</span> (elem &lt;- sorted) <span class="keyword">yield</span> (guid, <span class="number">0</span>, datediff(elem._1, elem._2))</span><br><span class="line"></span><br><span class="line">      <span class="comment">//统计间隔为N的次数(要排序),用后一个的rng_start- 前一个的 rng_end</span></span><br><span class="line">      <span class="keyword">val</span> list1 = <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until sorted.length - <span class="number">1</span>) <span class="keyword">yield</span> (guid, datediff(sorted(i)._2, sorted(i + <span class="number">1</span>)._1), <span class="number">1</span>)</span><br><span class="line">      list ++ list1</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line">    value.toDF(<span class="string">&quot;guid&quot;</span>, <span class="string">&quot;interval&quot;</span>, <span class="string">&quot;times&quot;</span>)</span><br><span class="line">      .groupBy(<span class="string">&quot;guid&quot;</span>, <span class="string">&quot;interval&quot;</span>).agg(sum(<span class="string">&quot;times&quot;</span>) as <span class="string">&quot;times&quot;</span>)</span><br><span class="line">      .show(<span class="number">100</span>, <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//时间相减</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">datediff</span></span>(date1: <span class="type">String</span>, date2: <span class="type">String</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sdf = <span class="keyword">new</span> <span class="type">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> s1: <span class="type">Date</span> = sdf.parse(date2)</span><br><span class="line">    <span class="keyword">val</span> s2: <span class="type">Date</span> = sdf.parse(date1)</span><br><span class="line">    ((s1.getTime - s2.getTime) / (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>)).toInt</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户访问间隔分析</span></span><br><span class="line"><span class="comment">//guid,first_dt,rng_start,rng_end</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">UserAccessInterval1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//UserAccessInterval是spark实现,UserAccessInterval1是SQL实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="keyword">this</span>.getClass.getSimpleName).master(<span class="string">&quot;local[*]&quot;</span>).getOrCreate()</span><br><span class="line">    <span class="keyword">val</span> schema = <span class="keyword">new</span> <span class="type">StructType</span>()</span><br><span class="line">      .add(<span class="string">&quot;guid&quot;</span>, <span class="type">DataTypes</span>.<span class="type">LongType</span>)</span><br><span class="line">      .add(<span class="string">&quot;first_dt&quot;</span>, <span class="type">DataTypes</span>.<span class="type">StringType</span>)</span><br><span class="line">      .add(<span class="string">&quot;rng_start&quot;</span>, <span class="type">DataTypes</span>.<span class="type">StringType</span>)</span><br><span class="line">      .add(<span class="string">&quot;rng_end&quot;</span>, <span class="type">DataTypes</span>.<span class="type">StringType</span>)</span><br><span class="line">    <span class="keyword">val</span> frame = spark.read.option(<span class="string">&quot;header&quot;</span>, <span class="literal">true</span>.toString).schema(schema).csv(<span class="string">&quot;file:///C:\\Users\\hp\\IdeaProjects\\TiTan\\dataware\\src\\main\\resources\\UserAccessInterval.csv&quot;</span>)</span><br><span class="line">    frame.createTempView(<span class="string">&quot;usertable&quot;</span>)</span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |with x as (</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |  guid,</span></span><br><span class="line"><span class="string">        |  if(datediff(&#x27;2020-03-14&#x27;,rng_start) &gt;= 30,date_sub(&#x27;2020-03-14&#x27;,30),rng_start) as rng_start,</span></span><br><span class="line"><span class="string">        |  if(rng_end = &#x27;9999-12-31&#x27;,&#x27;2020-03-14&#x27;,rng_end) as rng_end</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |  usertable -- 测试省略分区</span></span><br><span class="line"><span class="string">        |where datediff(&#x27;2020-03-14&#x27;,rng_end) &lt;= 30</span></span><br><span class="line"><span class="string">        |)</span></span><br><span class="line"><span class="string">        |</span></span><br><span class="line"><span class="string">        |-- 计算间隔为0的天数</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |  guid,</span></span><br><span class="line"><span class="string">        |  0 as interval ,</span></span><br><span class="line"><span class="string">        |  datediff(rng_end,rng_start) as times</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |x</span></span><br><span class="line"><span class="string">        |</span></span><br><span class="line"><span class="string">        |union all</span></span><br><span class="line"><span class="string">        |-- 计算间隔为N的天数</span></span><br><span class="line"><span class="string">        |-- 去重rn为null的值,无法计算</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |  guid,</span></span><br><span class="line"><span class="string">        |  datediff(date_rn,rng_end) as interval,</span></span><br><span class="line"><span class="string">        |  1 as times</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |(</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |  guid,</span></span><br><span class="line"><span class="string">        |  rng_end,</span></span><br><span class="line"><span class="string">        |  lead(rng_start,1,null) over(partition by guid order by rng_end) as date_rn</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |  x</span></span><br><span class="line"><span class="string">        |) o</span></span><br><span class="line"><span class="string">        |where date_rn is not null</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin).show(<span class="number">100</span>,<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="新用户留存分析主题"><a href="#新用户留存分析主题" class="headerlink" title="新用户留存分析主题"></a>新用户留存分析主题</h3><h5 id="新用户留存报表"><a href="#新用户留存报表" class="headerlink" title="新用户留存报表"></a>新用户留存报表</h5><img src="https://upload-images.jianshu.io/upload_images/9049859-9d842ed8cabc5770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新用户留存分析表" style="zoom:50%;" />

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基于流量/用户活跃度分析主题</span></span><br><span class="line"><span class="comment">-- 今日(2020-12-16)的新用户留存分析(新用户的定义:某人的初次登入日期就是这日的新用户)</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="string">&#x27;2020-12-16&#x27;</span> <span class="keyword">as</span> calc_dt, <span class="comment">-- 计算日</span></span><br><span class="line">  first_dt <span class="keyword">as</span> first_dt, <span class="comment">-- 用户第一次登陆日期                                     </span></span><br><span class="line">  <span class="keyword">datediff</span>(<span class="string">&#x27;2020-12-16&#x27;</span>, first_dt) <span class="keyword">as</span> retention_days, <span class="comment">-- 留存日</span></span><br><span class="line">  <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> user_cnt <span class="comment">-- 留存数</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  dw.user_act_range</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  dy = <span class="string">&#x27;2020-12-16&#x27;</span></span><br><span class="line">  <span class="keyword">and</span> range_end = <span class="string">&#x27;9999-12-31&#x27;</span></span><br><span class="line">  <span class="keyword">and</span> <span class="keyword">datediff</span>(<span class="string">&#x27;2020-12-16&#x27;</span>, first_dt) &lt;= <span class="number">30</span> <span class="comment">-- 过滤出超过一个月的情况</span></span><br><span class="line">  <span class="keyword">and</span> first_dt &lt; <span class="string">&#x27;2020-12-16&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">  first_dt,</span><br><span class="line">  <span class="keyword">datediff</span>(<span class="string">&#x27;2020-12-16&#x27;</span>, first_dt)</span><br></pre></td></tr></table></figure>



<h3 id="用户事件分析主题"><a href="#用户事件分析主题" class="headerlink" title="用户事件分析主题"></a>用户事件分析主题</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按照用户和事件两个维度进行聚合,统计出每个用户的行为记录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dw.event_overview_aggr_user(</span><br><span class="line">  guid <span class="keyword">string</span>,</span><br><span class="line">  event_id <span class="keyword">string</span>,</span><br><span class="line">  <span class="comment">-- 事件类型</span></span><br><span class="line">  act_cnt <span class="built_in">int</span> <span class="comment">-- 事件访问次数</span></span><br><span class="line">) PARTITIONED <span class="keyword">BY</span> (dy <span class="keyword">string</span>) <span class="keyword">STORED</span> <span class="keyword">AS</span> PARQUET TBLPROPERTIES(<span class="string">&quot;parquet.compress&quot;</span> = <span class="string">&quot;snappy&quot;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span></span><br><span class="line">  <span class="keyword">table</span> dw.event_overview_aggr_user <span class="keyword">partition</span>(dy = <span class="string">&#x27;2020-12-11&#x27;</span>)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  guid <span class="keyword">as</span> guid,</span><br><span class="line">  eventid <span class="keyword">as</span> event_id,</span><br><span class="line">  <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> act_cnt</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  dw.enent_app_detail</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  dy = <span class="string">&#x27;2020-12-11&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">  guid,</span><br><span class="line">  eventid <span class="comment">-- 报表分析,事件访问次数的range</span></span><br><span class="line">  <span class="comment">-- 如果不借助用户事件聚合维度表直接group by guid 则无法知道具体的每个用户的具体的访问记录</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="string">&#x27;2020-12-11&#x27;</span> <span class="keyword">as</span> dt,</span><br><span class="line">  event_id <span class="keyword">as</span> event_id,</span><br><span class="line">  <span class="keyword">sum</span>(act_cnt) <span class="keyword">as</span> act_cnt,  <span class="comment">-- 一共访问了多少次</span></span><br><span class="line">  <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> act_users,   <span class="comment">-- 有多少用户</span></span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">if</span>(act_cnt &lt;= <span class="number">10</span>, <span class="number">1</span>, <span class="literal">null</span>)) <span class="keyword">as</span> cnt_0_users,</span><br><span class="line">  <span class="comment">-- 访问占比 cnt11_20_users</span></span><br><span class="line">  <span class="keyword">count</span>(</span><br><span class="line">    <span class="keyword">if</span>(</span><br><span class="line">      act_cnt &lt;= <span class="number">20</span></span><br><span class="line">      <span class="keyword">and</span> act_cnt &gt; <span class="number">10</span>,</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      <span class="literal">null</span></span><br><span class="line">    )</span><br><span class="line">  ) <span class="keyword">as</span> cnt_1_users,</span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">if</span>(act_cnt &gt; <span class="number">10</span>, <span class="number">1</span>, <span class="literal">null</span>)) <span class="keyword">as</span> cnt_3_users</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  dw.event_overview_aggr_user</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  dy = <span class="string">&#x27;2020-12-11&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">  event_id</span><br></pre></td></tr></table></figure>



<h3 id="漏斗模型分析主题"><a href="#漏斗模型分析主题" class="headerlink" title="漏斗模型分析主题"></a>漏斗模型分析主题</h3><h5 id="业务路径概况统计"><a href="#业务路径概况统计" class="headerlink" title="业务路径概况统计"></a>业务路径概况统计</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dw.funnel_statistic_1d</span><br><span class="line">( </span><br><span class="line">  funnel_name  <span class="keyword">string</span>,<span class="comment">-- 漏斗的业务步骤</span></span><br><span class="line">  guid         <span class="keyword">string</span>,<span class="comment">-- 用户</span></span><br><span class="line">  comp_step    <span class="built_in">int</span> <span class="comment">-- 用户完成这个步骤多少步</span></span><br><span class="line">)</span><br><span class="line">partitioned <span class="keyword">by</span> (dy <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> parquet </span><br><span class="line">tblproperties(<span class="string">&quot;parquet.compress&quot;</span> = <span class="string">&quot;snappy&quot;</span>)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> dw.funnel_statistic_1d <span class="keyword">partition</span>(dy=<span class="string">&#x27;2020-12-12&#x27;</span>)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="string">&#x27;浏览分享添加&#x27;</span> <span class="keyword">as</span> funnel_name,</span><br><span class="line">  guid,</span><br><span class="line">  comp_step</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      guid <span class="keyword">as</span> guid,</span><br><span class="line">      <span class="comment">-- sort_array()返回的是一个数组  regexp_extract() 只能对字符串操作</span></span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">when</span> regexp_extract(</span><br><span class="line">        <span class="keyword">concat_ws</span>(</span><br><span class="line">          <span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">          sort_array(</span><br><span class="line">            collect_list(</span><br><span class="line">              <span class="keyword">concat_ws</span>(<span class="string">&#x27;_&#x27;</span>, <span class="keyword">cast</span>(<span class="string">`timestamp`</span> <span class="keyword">as</span> <span class="keyword">string</span>), eventId)</span><br><span class="line">            )</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">        <span class="string">&#x27;.*?(pageView).*?(share).*?(addCart).*?&#x27;</span>,</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">      ) = <span class="string">&#x27;addCart&#x27;</span> <span class="keyword">then</span> <span class="number">3</span> <span class="keyword">when</span> regexp_extract(</span><br><span class="line">        <span class="keyword">concat_ws</span>(</span><br><span class="line">          <span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">          sort_array(</span><br><span class="line">            collect_list(</span><br><span class="line">              <span class="keyword">concat_ws</span>(<span class="string">&#x27;_&#x27;</span>, <span class="keyword">cast</span>(<span class="string">`timestamp`</span> <span class="keyword">as</span> <span class="keyword">string</span>), eventId)</span><br><span class="line">            )</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">        <span class="string">&#x27;.*?(pageView).*?(share).*?&#x27;</span>,</span><br><span class="line">        <span class="number">2</span></span><br><span class="line">      ) = <span class="string">&#x27;share&#x27;</span> <span class="keyword">then</span> <span class="number">2</span> <span class="keyword">when</span> regexp_extract(</span><br><span class="line">        <span class="keyword">concat_ws</span>(</span><br><span class="line">          <span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">          sort_array(</span><br><span class="line">            collect_list(</span><br><span class="line">              <span class="keyword">concat_ws</span>(<span class="string">&#x27;_&#x27;</span>, <span class="keyword">cast</span>(<span class="string">`timestamp`</span> <span class="keyword">as</span> <span class="keyword">string</span>), eventId)</span><br><span class="line">            )</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">        <span class="string">&#x27;.*?(pageView).*?&#x27;</span>,</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">      ) = <span class="string">&#x27;pageView&#x27;</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span> <span class="keyword">as</span> comp_step</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      dw.enent_app_detail</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">      dy = <span class="string">&#x27;2020-12-12&#x27;</span></span><br><span class="line">      <span class="keyword">and</span> <span class="comment">-- 漏斗步骤(</span></span><br><span class="line">        (</span><br><span class="line">          eventId = <span class="string">&#x27;pageView&#x27;</span></span><br><span class="line">          <span class="keyword">and</span> properties [<span class="string">&#x27;pageId&#x27;</span>] = <span class="string">&#x27;877&#x27;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">or</span> (</span><br><span class="line">          eventId = <span class="string">&#x27;share&#x27;</span></span><br><span class="line">          <span class="keyword">and</span> properties [<span class="string">&#x27;pageId&#x27;</span>] = <span class="string">&#x27;791&#x27;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">or</span> (</span><br><span class="line">          eventId = <span class="string">&#x27;addCart&#x27;</span></span><br><span class="line">          <span class="keyword">and</span> properties [<span class="string">&#x27;pageId&#x27;</span>] = <span class="string">&#x27;72&#x27;</span></span><br><span class="line">           )</span><br><span class="line">         <span class="keyword">group</span> <span class="keyword">by</span> guid</span><br><span class="line">     )o</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  comp_step &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 报表案例:统计完成步骤的人数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">if</span>(comp_step&gt;=<span class="number">1</span>,<span class="number">1</span>,<span class="literal">null</span>)) <span class="keyword">as</span> step_1,<span class="comment">--完成第一步的人</span></span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">if</span>(comp_step&gt;=<span class="number">2</span>,<span class="number">1</span>,<span class="literal">null</span>)) <span class="keyword">as</span> step_2,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">if</span>(comp_step&gt;=<span class="number">3</span>,<span class="number">1</span>,<span class="literal">null</span>)) <span class="keyword">as</span> step_3,</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">dw.funnel_statistic_1d </span><br><span class="line"><span class="keyword">where</span> dy=<span class="string">&#x27;2020-12-12&#x27;</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 访问路径明细表</span></span><br><span class="line"><span class="comment">-- guid  ssessionid  eventid  ts  referral  stay_time</span></span><br><span class="line"><span class="keyword">with</span> x <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">guid,</span><br><span class="line">ssessionid,</span><br><span class="line">eventid[<span class="string">&#x27;url&#x27;</span>] <span class="keyword">as</span> eventid, </span><br><span class="line">row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> guid , ssessionid <span class="keyword">order</span> <span class="keyword">by</span> ts) <span class="keyword">as</span> step,</span><br><span class="line">lag(eventid[<span class="string">&#x27;url&#x27;</span>],<span class="number">1</span>,<span class="literal">null</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> guid , ssessionid <span class="keyword">order</span> <span class="keyword">by</span> ts) <span class="keyword">as</span> referral </span><br><span class="line"><span class="keyword">lead</span>(ts,<span class="number">1</span>,<span class="literal">null</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> guid , ssessionid <span class="keyword">order</span> <span class="keyword">by</span> ts) - ts <span class="keyword">as</span> stay_time</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">ods_etl <span class="comment">-- 经过etl处理的原表</span></span><br><span class="line"><span class="keyword">where</span> dy = <span class="string">&#x27;2020-12-12&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> dwd_atl_rut_dtl  <span class="keyword">partition</span> (dy = <span class="string">&#x27;2020-12-12&#x27;</span>)</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">guid, <span class="comment">-- 用户唯一标识</span></span><br><span class="line">ssessionid, <span class="comment">-- 会话</span></span><br><span class="line">eventid, <span class="comment">--  事件</span></span><br><span class="line">step , <span class="comment">--第几步</span></span><br><span class="line">referral ,  <span class="comment">-- 前一个事件</span></span><br><span class="line"><span class="keyword">if</span>(stay_time <span class="keyword">is</span> <span class="literal">null</span> ,<span class="number">3000</span>,stay_time) <span class="keyword">as</span> stay_time <span class="comment">-- 最后一个页面停留时间怎么处理(给定一个定长),停留时间</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">x </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 访问路径概况统计报表</span></span><br><span class="line"><span class="comment">-- 使用count() over() 也可以实现</span></span><br><span class="line"><span class="keyword">with</span> x <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  eventid,step,referral,</span><br><span class="line">  <span class="keyword">count</span>(ssessionid)  <span class="keyword">as</span> rut_cnt <span class="comment">-- 不需要去重</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">  dwd_atl_rut_dtl</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>  eventid,step,referral</span><br><span class="line">) </span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  eventid,step,referral,</span><br><span class="line">  rut_cnt, <span class="comment">-- 路径会话数</span></span><br><span class="line">  <span class="keyword">sum</span>(rut_cnt) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> eventid,step <span class="keyword">order</span> <span class="keyword">by</span> eventid) <span class="keyword">as</span> step_cnt, <span class="comment">-- 步骤会话数</span></span><br><span class="line">  <span class="keyword">sum</span>(rut_cnt) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> eventid <span class="keyword">order</span> <span class="keyword">by</span> eventid) <span class="keyword">as</span> page_cnt <span class="comment">-- 页面会话数</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">  x </span><br></pre></td></tr></table></figure>



<h3 id="事件归因分析主题"><a href="#事件归因分析主题" class="headerlink" title="事件归因分析主题*"></a>事件归因分析主题*</h3><p>归因分析是对用户复杂的消费行为路径的分析,归因分析(Attribution Analysis)要解决的问题就是广告效果的产生,其功劳应该如何合理的分配给哪些渠道。</p>
<p>末次触点分析:转化路径少周期短的业务,或者就是起临门一脚作用的广告,为了吸引客户购买，点击直接落地到商品详情页</p>
<p>首次触点分析:这种模型适用于没什么品牌知名度的公司,关注能给他们带来客户的最初的渠道,对于扩展市场很有帮助的渠道</p>
<p>末次非直接点击归因:业务的直接流量大部分都被来自于被其他渠道吸引的客户,需要排除掉直接流量</p>
<p>线性归因分析:根据线性归因模型的特点，他更适用于企业期望在整个销售周期内保持与客户的联系，并维持品牌认知度的公司.在这种情况下,各个渠道在客户的考虑过程中,都起到相同的促进作用</p>
<p>时间衰减归因分析:客户决策周期短、销售周期短的情况,比如,做短期的促销,就打了两天的广告，那么这两天的广告理应获得较高的权重</p>
<p>U型归因分析:混合使用了首次互动归因和末次互动归因</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FactorAnalysis</span> </span>&#123;</span><br><span class="line">  <span class="comment">//归因分析:对用户复杂的消费行为路径的分析</span></span><br><span class="line">  <span class="comment">//目标事件 e6</span></span><br><span class="line">  <span class="comment">//待归因事件 &#x27;e1&#x27;,&#x27;e3&#x27;,&#x27;e5&#x27;</span></span><br><span class="line">  <span class="comment">//数据:见项目factor.csv</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="keyword">this</span>.getClass.getSimpleName).master(<span class="string">&quot;local[*]&quot;</span>).enableHiveSupport().getOrCreate()</span><br><span class="line">    spark.read.format(<span class="string">&quot;csv&quot;</span>).load(<span class="string">&quot;file:///C:\\Users\\hp\\IdeaProjects\\TiTan\\dataware\\src\\main\\resources\\factor.csv&quot;</span>).toDF(<span class="string">&quot;guid&quot;</span>, <span class="string">&quot;event&quot;</span>, <span class="string">&quot;timestamp&quot;</span>).createTempView(<span class="string">&quot;factor&quot;</span>)</span><br><span class="line">    <span class="comment">//使用SQL的方式聚合出每个用户的事件信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |guid,</span></span><br><span class="line"><span class="string">        |sort_array(collect_list(concat_ws(&#x27;_&#x27;,timestamp,event) )) as eventId</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |factor</span></span><br><span class="line"><span class="string">        |where event in (&#x27;e1&#x27;,&#x27;e3&#x27;,&#x27;e5&#x27;,&#x27;e6&#x27;)</span></span><br><span class="line"><span class="string">        |group by guid</span></span><br><span class="line"><span class="string">        |having array_contains(collect_list(event),&#x27;e6&#x27;)</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin).createTempView(<span class="string">&quot;attr_event&quot;</span>)</span><br><span class="line"></span><br><span class="line">    spark.udf.register(<span class="string">&quot;first_time&quot;</span>, firstTime)</span><br><span class="line">    spark.udf.register(<span class="string">&quot;first_time1&quot;</span>, firstTime1)</span><br><span class="line">    spark.udf.register(<span class="string">&quot;Thelastattribution&quot;</span>, <span class="type">Thelastattribution</span>)</span><br><span class="line">    spark.udf.register(<span class="string">&quot;linearattribution&quot;</span>, linearattribution)</span><br><span class="line">    spark.udf.register(<span class="string">&quot;decay&quot;</span>, decay)</span><br><span class="line"></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |guid,</span></span><br><span class="line"><span class="string">        |decay(eventId,array(&#x27;e1&#x27;,&#x27;e3&#x27;,&#x27;e5&#x27;)) as attribute</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |attr_event</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin).show(<span class="number">10</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 其实只要返回第一个值即可,发现问题:可能会用多个&quot;e6&quot;</span></span><br><span class="line">  <span class="keyword">val</span> firstTime = (event_list: mutable.<span class="type">WrappedArray</span>[<span class="type">String</span>], attribute: mutable.<span class="type">WrappedArray</span>[<span class="type">String</span>]) =&gt; &#123;</span><br><span class="line">    <span class="comment">//判断首次出现的事件&#x27;e1&#x27;,&#x27;e3&#x27;,&#x27;e5&#x27;</span></span><br><span class="line">    <span class="keyword">val</span> event = event_list.map(data =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> strings = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">      (strings(<span class="number">0</span>), strings(<span class="number">1</span>))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> array = <span class="keyword">for</span> (i &lt;- event; j &lt;- attribute <span class="keyword">if</span> (i._2 == j)) <span class="keyword">yield</span> (i, j)</span><br><span class="line">    <span class="comment">// 按照 value 来去重获取第一次出现的值</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">var</span> sort = <span class="type">Ordering</span>[(<span class="type">String</span>, <span class="type">String</span>)].on[(<span class="type">String</span>, (<span class="type">String</span>, <span class="type">String</span>))](t =&gt; t._2).reverse</span><br><span class="line">    <span class="keyword">var</span> set = mutable.<span class="type">TreeSet</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">String</span>)]()</span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- array) &#123;</span><br><span class="line">      set += elem</span><br><span class="line">    &#125;</span><br><span class="line">    set.head._2</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> firstTime1 = (event_list: mutable.<span class="type">WrappedArray</span>[<span class="type">String</span>], attribute: mutable.<span class="type">WrappedArray</span>[<span class="type">String</span>]) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> tuple: (<span class="type">List</span>[<span class="type">String</span>], <span class="type">List</span>[<span class="type">String</span>]) = event_list.toList.map(_.split(<span class="string">&quot;_&quot;</span>)(<span class="number">1</span>)).span(_ != <span class="string">&quot;e6&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> temp: (<span class="type">List</span>[<span class="type">String</span>], <span class="type">List</span>[<span class="type">String</span>]) = tuple</span><br><span class="line">    <span class="keyword">var</span> strings = <span class="type">ListBuffer</span>[<span class="type">String</span>]()</span><br><span class="line">    <span class="keyword">while</span> (temp._2.nonEmpty) &#123;</span><br><span class="line">      <span class="keyword">if</span> (temp._1.nonEmpty) &#123;</span><br><span class="line">        strings += temp._1.head</span><br><span class="line">      &#125;</span><br><span class="line">      temp = temp._2.tail.span(_ != <span class="string">&quot;e6&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    strings</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 末次触点归因</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">Thelastattribution</span> = (event_list: mutable.<span class="type">WrappedArray</span>[<span class="type">String</span>], attribute: mutable.<span class="type">WrappedArray</span>[<span class="type">String</span>]) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> tuple: (<span class="type">List</span>[<span class="type">String</span>], <span class="type">List</span>[<span class="type">String</span>]) = event_list.toList.map(_.split(<span class="string">&quot;_&quot;</span>)(<span class="number">1</span>)).span(_ != <span class="string">&quot;e6&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> strings = <span class="type">ListBuffer</span>[<span class="type">String</span>]()</span><br><span class="line">    <span class="keyword">while</span> (tuple._2.nonEmpty) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tuple._1.nonEmpty) &#123;</span><br><span class="line">        <span class="comment">//init 方法是返回除最后一个元素之外的全部元素</span></span><br><span class="line">        strings += tuple._1.last</span><br><span class="line">      &#125;</span><br><span class="line">      tuple = tuple._2.tail.span(_ != <span class="string">&quot;e6&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    strings</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//线性归因</span></span><br><span class="line">  <span class="keyword">val</span> linearattribution = (event_list: mutable.<span class="type">WrappedArray</span>[<span class="type">String</span>], attribute: mutable.<span class="type">WrappedArray</span>[<span class="type">String</span>]) =&gt; &#123;</span><br><span class="line">    <span class="comment">//要对每段的匹配到的去重</span></span><br><span class="line">    <span class="keyword">var</span> tuple: (<span class="type">List</span>[<span class="type">String</span>], <span class="type">List</span>[<span class="type">String</span>]) = event_list.toList.map(_.split(<span class="string">&quot;_&quot;</span>)(<span class="number">1</span>)).span(_ != <span class="string">&quot;e6&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="type">ListBuffer</span>[(<span class="type">String</span>, <span class="type">Int</span>)]()</span><br><span class="line">    <span class="keyword">while</span> (tuple._2.nonEmpty) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tuple._1.nonEmpty) &#123;</span><br><span class="line">        <span class="keyword">val</span> value = tuple._1.toSet</span><br><span class="line">        <span class="keyword">val</span> size = value.size</span><br><span class="line">        <span class="keyword">for</span> (elem &lt;- value) &#123;</span><br><span class="line">          buffer += ((elem, <span class="number">100</span> / size))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      tuple = tuple._2.tail.span(_ != <span class="string">&quot;e6&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    buffer</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//时间衰减归因</span></span><br><span class="line">  <span class="keyword">val</span> decay = (event_list: mutable.<span class="type">WrappedArray</span>[<span class="type">String</span>], attribute: mutable.<span class="type">WrappedArray</span>[<span class="type">String</span>]) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> tuple: (<span class="type">List</span>[<span class="type">String</span>], <span class="type">List</span>[<span class="type">String</span>]) = event_list.toList.map(_.split(<span class="string">&quot;_&quot;</span>)(<span class="number">1</span>)).span(_ != <span class="string">&quot;e6&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="type">ListBuffer</span>[(<span class="type">String</span>, <span class="type">Double</span>)]()</span><br><span class="line">    <span class="keyword">while</span> (tuple._2.nonEmpty) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tuple._1.nonEmpty) &#123;</span><br><span class="line">        <span class="keyword">val</span> list = tuple._1.toSet.toList</span><br><span class="line">        <span class="keyword">val</span> seq = <span class="keyword">for</span> (i &lt;- list.indices) <span class="keyword">yield</span> <span class="type">Math</span>.pow(<span class="number">0.9</span>, i)</span><br><span class="line">        <span class="keyword">val</span> tuples1: immutable.<span class="type">Seq</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = <span class="keyword">for</span> (j &lt;- list.indices) <span class="keyword">yield</span> (list(j), seq(j) / seq.sum)</span><br><span class="line">        <span class="keyword">for</span> (elem &lt;- tuples1) &#123;</span><br><span class="line">          buffer += elem</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      tuple = tuple._2.tail.span(_ != <span class="string">&quot;e6&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    buffer</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//|guid|attribute                                                                       |</span></span><br><span class="line">  <span class="comment">//+----+--------------------------------------------------------------------------------+</span></span><br><span class="line">  <span class="comment">//|g02 |[[e3, 0.5263157894736842], [e1, 0.4736842105263158], [e1, 1.0]]                 |</span></span><br><span class="line">  <span class="comment">//|g01 |[[e1, 0.5263157894736842], [e3, 0.4736842105263158]]                            |</span></span><br><span class="line">  <span class="comment">//|g03 |[[e3, 0.36900369003690037], [e1, 0.33210332103321033], [e5, 0.2988929889298893]]|</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//位置归因</span></span><br><span class="line">  <span class="comment">//同理只要去除第一个和最后一个即可不再写了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//末次非触点归因分析,排除最后一个即可,例如:list.init.last取出第二个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="ODS-gt-DWD-业务数据分析"><a href="#ODS-gt-DWD-业务数据分析" class="headerlink" title="ODS-&gt;DWD(业务数据分析)"></a>ODS-&gt;DWD(业务数据分析)</h1><h3 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- sqoop安装流程略</span><br><span class="line">-- mysql表导入到hive表(可能报错将hive/lib目录下commonjar拷贝到sqoop下lib目录)</span><br><span class="line">bin/sqoop import -Dorg.apache.sqoop.splitter.allow_text_splitter=true \ -- 没有数字主键要添加此-D参数</span><br><span class="line">--connect jdbc:mysql://linux03/db_demo1 \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table TEST \</span><br><span class="line">--hive-import \</span><br><span class="line">--hive-table db_demo1.tb_mysql \ -- 直接指定数据库无需重新指定了</span><br><span class="line">--delete-target-dir \ -- 删除中间文件信息</span><br><span class="line">--as-textfile \   -- 指定hive表生成文件类型</span><br><span class="line">--fields-terminated-by &#x27;,&#x27; \ </span><br><span class="line">--compress   \</span><br><span class="line">--compression-codec gzip \ -- 指定压缩编码</span><br><span class="line">--null-string &#x27;\\N&#x27; \    -- 处理空值</span><br><span class="line">--null-non-string &#x27;\\N&#x27; \ </span><br><span class="line">--hive-overwrite \     -- 是否覆盖</span><br><span class="line">--split-by ITEM_CODE \ -- 按照某字段来分组</span><br><span class="line">-m 2 -- 两个map任务</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- query查询导入,先导入--target-dir 指定的 HDFS 的目录中</span><br><span class="line">-- 尽量不要使用复杂查询</span><br><span class="line">-- 要添加$CONDITIONS作为将来拼接条件的占位符</span><br><span class="line">-- 对于引号的问题,方案一外层使用双引号内层使用单引号方案二外层使用单引号,里层对$进行转义\$</span><br><span class="line"></span><br><span class="line">bin/sqoop import -Dorg.apache.sqoop.splitter.allow_text_splitter=true \</span><br><span class="line">--connect jdbc:mysql://linux03/db_demo1 \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--hive-import \</span><br><span class="line">--hive-table db_demo1.tb_geo1 \</span><br><span class="line">--target-dir /mydata/temporary \</span><br><span class="line">--as-textfile \</span><br><span class="line">--fields-terminated-by &#x27;,&#x27; \</span><br><span class="line">--compress   \</span><br><span class="line">--compression-codec gzip \</span><br><span class="line">--split-by geo \</span><br><span class="line">--null-string &#x27;\\N&#x27; \</span><br><span class="line">--null-non-string &#x27;\\N&#x27; \</span><br><span class="line">--hive-overwrite  \</span><br><span class="line">--query &quot; select * from geo   where  geo =&#x27;wx4g1n&#x27;  and  \$CONDITIONS&quot;  \</span><br><span class="line">-m 2</span><br><span class="line"></span><br><span class="line">-- 其他支持</span><br><span class="line">-- 条件导入: --columns  指定要导的字段</span><br><span class="line">-- 按字段的增量导入/界定时间戳</span><br><span class="line">--check-colum		-- 指定在确定要导入的行时要检查的列</span><br><span class="line">--incremental		-- 有两种类型一种是append一种是lastmodified。append是增加，lastmodified是根据</span><br><span class="line">					时间戳</span><br><span class="line">--last-value		-- 指定上一次导入的检查列的最大值</span><br><span class="line">--last-value        -- &#x27;2020-03-18 23:59:59&#x27; 通过修改时间戳来界定数据</span><br><span class="line">-- 导入到hive分区</span><br><span class="line">-- --target-dir &quot;...dt=&#x27;&#x27;&quot;  hive无法识别,添加hive的分区 alter table tablename partition(dt=&#x27;&#x27;) locatition &#x27;&#x27;</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 导入到hive分区,手动 alter table db_demo1.geo1 add  partition (dt=&#x27;2020-12-23&#x27;);</span><br><span class="line">-- target-dir -- 生成的结果保存在这个目录如果不在hive表下,要手动指定location hdfs文件地址</span><br><span class="line">bin/sqoop import -Dorg.apache.sqoop.splitter.allow_text_splitter=true \</span><br><span class="line">--connect jdbc:mysql://linux03/db_demo1 \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--target-dir /user/hive/warehouse/db_demo1.db/geo1/dt=2020-12-23 \ </span><br><span class="line">--delete-target-dir \</span><br><span class="line">--as-textfile \</span><br><span class="line">--fields-terminated-by &#x27;\001&#x27; \</span><br><span class="line">--compress   \</span><br><span class="line">--compression-codec gzip \</span><br><span class="line">--split-by geo \</span><br><span class="line">--null-string &#x27;\\N&#x27; \</span><br><span class="line">--null-non-string &#x27;\\N&#x27; \</span><br><span class="line">--query &quot; select * from geo   where  geo =&#x27;wx4g1n&#x27;  and  \$CONDITIONS&quot;  \</span><br><span class="line">-m 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="增量表和全量表"><a href="#增量表和全量表" class="headerlink" title="增量表和全量表"></a>增量表和全量表</h3><p>增量表<br>特征每个分区就是业务数据每天更新的数据<br>怎么从业务系统导入<br>方法一:取某个时间戳之后的数据(即为今天更新的数据)<br>方法二:递增字段,这个场景适用于递增数据库</p>
<p>全量表<br>为什么不直接从业务系统导出全部的数据?因为业务系统这张表可能数据过多,而数据系统是分布式的,对系统压力小<br>今天的增量数据 与全量表的数据  full join (能join上的就取增量表的,不能join上的就是新的用户/没有更新的数据,把join的结果添加到今天的分区,关于是否要保存全量表昨天分区的数据,可以保存相当于快照,可以采用类拉链表的方法来更新全增表,这样数据就会减少)</p>
<p>对全量表和增量表的论述在《大数据系统构建原理与最佳实践》有详细的解释</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 一个关于类拉链表的案例</span></span><br><span class="line"><span class="comment">-- 方案一:</span></span><br><span class="line"><span class="comment">-- 20号拉链</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dwd_append_zip(</span><br><span class="line"><span class="keyword">id</span>  <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="keyword">string</span>,</span><br><span class="line">age  <span class="built_in">int</span>,</span><br><span class="line">nick <span class="keyword">string</span>,</span><br><span class="line">start_dt  <span class="keyword">string</span>,</span><br><span class="line">end_dt    <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">partitioned <span class="keyword">by</span> (dt <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line"></span><br><span class="line">vi zip<span class="number">.20</span></span><br><span class="line"><span class="number">1</span>,zs,<span class="number">24</span>,ss,<span class="number">2020</span><span class="number">-12</span><span class="number">-20</span>,<span class="number">9999</span><span class="number">-12</span><span class="number">-31</span> </span><br><span class="line"><span class="number">2</span>,ww,<span class="number">25</span>,ww,<span class="number">2020</span><span class="number">-12</span><span class="number">-20</span>,<span class="number">9999</span><span class="number">-12</span><span class="number">-31</span> </span><br><span class="line"><span class="number">3</span>,tq,<span class="number">22</span>,qq,<span class="number">2020</span><span class="number">-12</span><span class="number">-20</span>,<span class="number">9999</span><span class="number">-12</span><span class="number">-31</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&#x27;/root/zip.20&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> dwd_append_zip <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-12-20&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 21号增量</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ods_append(</span><br><span class="line"><span class="keyword">id</span>  <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="keyword">string</span>,</span><br><span class="line">age  <span class="built_in">int</span>,</span><br><span class="line">nick <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">partitioned <span class="keyword">by</span> (dt <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vi append<span class="number">.21</span></span><br><span class="line"><span class="number">2</span>,ww,<span class="number">25</span>,zz</span><br><span class="line"><span class="number">4</span>,wb,<span class="number">24</span>,bb</span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&#x27;/root/append.21&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> ods_append <span class="keyword">partition</span>(dt=<span class="string">&#x27;2020-12-21&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- joi规则今天不存在昨天存在就修改end_dt为昨天的日期,如果没有匹配到且不存在就是新的行为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> y <span class="keyword">as</span> ( <span class="comment">-- 昨天的拉链表</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">dwd_append_zip </span><br><span class="line"><span class="keyword">where</span> dt=<span class="string">&#x27;2020-12-20&#x27;</span></span><br><span class="line"> )</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">nvl(x.id,y.id) <span class="keyword">as</span> <span class="keyword">id</span>,</span><br><span class="line">nvl(x.name,y.name) <span class="keyword">as</span> <span class="keyword">name</span>,</span><br><span class="line">nvl(x.nick,y.nick) <span class="keyword">as</span> nick,</span><br><span class="line">nvl(x.start_dt,y.start_dt) <span class="keyword">as</span> start_dt,</span><br><span class="line"><span class="keyword">case</span> </span><br><span class="line">   <span class="comment">-- 这种情况是已经封装的数据了</span></span><br><span class="line">   <span class="keyword">when</span> x.end_dt != <span class="string">&#x27;9999-12-31&#x27;</span>  <span class="keyword">then</span> x.end_dt</span><br><span class="line">   <span class="comment">-- 这种情况是昨天存在并且今天也在</span></span><br><span class="line">   <span class="keyword">when</span> x.end_dt = <span class="string">&#x27;9999-12-31&#x27;</span> <span class="keyword">and</span> y.end_dt <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>  <span class="keyword">then</span> <span class="string">&#x27;9999-21-31&#x27;</span></span><br><span class="line">   <span class="comment">-- 这种情况是昨天在,今天不在封装</span></span><br><span class="line">   <span class="keyword">when</span> x.end_dt = <span class="string">&#x27;9999-21-31&#x27;</span> <span class="keyword">and</span> y.end_dt <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">then</span> x.end_dt</span><br><span class="line">   <span class="comment">-- 这种情况是昨天没有,但是今天有</span></span><br><span class="line">   <span class="keyword">when</span> x.end_dt <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">and</span> y.end_dt <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">then</span> <span class="string">&#x27;2020-12-21&#x27;</span></span><br><span class="line">   <span class="keyword">end</span> </span><br><span class="line">   <span class="keyword">as</span> end_dt</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">ods_append x</span><br><span class="line"><span class="keyword">where</span> dt=<span class="string">&#x27;2020-12-21&#x27;</span></span><br><span class="line"><span class="keyword">full</span> <span class="keyword">join</span> </span><br><span class="line">x.id = y.id </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方案二:</span></span><br><span class="line"><span class="comment">-- 今天的新增数据全部添加到增量表</span></span><br><span class="line"><span class="comment">-- 今天有的end_dt全部为今天的时间,已经封装的全部是默认的end_dt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> a <span class="keyword">as</span> (</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">id</span>,</span><br><span class="line">    <span class="keyword">name</span>,</span><br><span class="line">    age,</span><br><span class="line">    nick,</span><br><span class="line">    start_dt,</span><br><span class="line">    end_dt,</span><br><span class="line">    dt</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    dwd_append_zip</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    (dt = <span class="string">&#x27;2020-12-20&#x27;</span>)</span><br><span class="line">),</span><br><span class="line">b <span class="keyword">as</span> (</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">id</span>,</span><br><span class="line">    <span class="keyword">name</span>,</span><br><span class="line">    age,</span><br><span class="line">    nick,</span><br><span class="line">    dt</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    ods_append</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    (dt = <span class="string">&#x27;2020-12-21&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  a.id,</span><br><span class="line">  a.name,</span><br><span class="line">  a.age,</span><br><span class="line">  a.nick,</span><br><span class="line">  a.start_dt,</span><br><span class="line">  <span class="keyword">if</span>(</span><br><span class="line">    b.id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">and</span> a.end_dt = <span class="string">&#x27;9999-12-31&#x27;</span>,</span><br><span class="line">    a.dt,</span><br><span class="line">    a.end_dt</span><br><span class="line">  ) <span class="keyword">as</span> end_dt</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  a</span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id = b.id</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">id</span>,</span><br><span class="line">  <span class="keyword">name</span>,</span><br><span class="line">  age,</span><br><span class="line">  nick,</span><br><span class="line">  dt <span class="keyword">as</span> start_dt,</span><br><span class="line">  <span class="string">&#x27;9999-12-31&#x27;</span> <span class="keyword">as</span> end_dt</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  b</span><br></pre></td></tr></table></figure>



<h1 id="DWD-gt-DWS-业务数据分析"><a href="#DWD-gt-DWS-业务数据分析" class="headerlink" title="DWD-&gt;DWS(业务数据分析)"></a>DWD-&gt;DWS(业务数据分析)</h1><h3 id="报表分析示例"><a href="#报表分析示例" class="headerlink" title="报表分析示例"></a>报表分析示例</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 复购率分析</span></span><br><span class="line"><span class="comment">-- 需要两张表 订单主要信息表 order 订单商品详情表 order_goods</span></span><br><span class="line"><span class="comment">-- 订单 用户id 商品 品类</span></span><br><span class="line"><span class="keyword">with</span> x <span class="keyword">as</span> (</span><br><span class="line">  <span class="keyword">select</span></span><br><span class="line">    t1.order_id,</span><br><span class="line">    t1.use_id,</span><br><span class="line">    t2.good_id,</span><br><span class="line">    t2.type_id</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">    (</span><br><span class="line">      <span class="keyword">select</span></span><br><span class="line">        order_id,</span><br><span class="line">        use_id</span><br><span class="line">      <span class="keyword">from</span></span><br><span class="line">        <span class="keyword">order</span></span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">        dy = <span class="string">&#x27;2020-12-12&#x27;</span></span><br><span class="line">    ) t1</span><br><span class="line">    <span class="keyword">join</span> order_goods t2 <span class="keyword">on</span> t1.order_id = t2.order_goods</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="string">&#x27;2020-12-12&#x27;</span> <span class="keyword">as</span> dy,</span><br><span class="line">  <span class="comment">--今日时间</span></span><br><span class="line">  type_id,</span><br><span class="line">  <span class="comment">-- 品类</span></span><br><span class="line">  <span class="keyword">count</span>(use_id) <span class="comment">-- 购买该品类多少人,已经对人进行了去重了,上一步group by use_id</span></span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">if</span>(user_cnt &gt;= <span class="number">2</span>, <span class="number">1</span>, <span class="literal">null</span>)) <span class="keyword">as</span> time_2,</span><br><span class="line">  <span class="comment">-- 统计购买次数大于2次的人的个数</span></span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">if</span>(user_cnt &gt;= <span class="number">3</span>, <span class="number">1</span>, <span class="literal">null</span>)) <span class="keyword">as</span> time_3,</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      <span class="comment">-- 一个用户购买多少该品类</span></span><br><span class="line">      type_id,</span><br><span class="line">      use_id,</span><br><span class="line">      <span class="keyword">count</span> (<span class="keyword">distinct</span> order_id) <span class="keyword">as</span> user_cnt </span><br><span class="line">      <span class="comment">-- 为什么要对order_id 去重因为一个品类一条数据,一个用户一次可能购买多个品类</span></span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      x</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">      use_id,</span><br><span class="line">      type_id</span><br><span class="line">  ) o</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">  o.type_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复杂报表分析</span></span><br><span class="line"><span class="comment">-- 表报分析</span></span><br><span class="line"><span class="comment">-- 店铺 地区 月份 月销售金额 同地区同月份所有店铺销售金额 该店铺到该月的累计金额</span></span><br><span class="line"><span class="comment">-- 数据</span></span><br><span class="line">shop  province    provincetable</span><br><span class="line">shop <span class="keyword">month</span> sale   shoptable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> y <span class="keyword">as</span> (</span><br><span class="line">  <span class="keyword">with</span> x <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      a.shop,</span><br><span class="line">      <span class="keyword">max</span>(b.province) <span class="keyword">as</span> province,</span><br><span class="line">      a.month,</span><br><span class="line">      <span class="keyword">sum</span>(a.sale) <span class="keyword">as</span> sale_cnt</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      shoptable a</span><br><span class="line">      <span class="keyword">join</span> provincetable b <span class="keyword">on</span> a.shop = b.shop</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">      a.shop,</span><br><span class="line">      a.month</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">select</span></span><br><span class="line">    <span class="comment">-- 增加字段累计金额</span></span><br><span class="line">    shop,</span><br><span class="line">    province,</span><br><span class="line">    <span class="keyword">month</span>,</span><br><span class="line">    sale_cnt,</span><br><span class="line">    <span class="keyword">sum</span>(sale_cnt) <span class="keyword">over</span>(</span><br><span class="line">      <span class="keyword">partition</span> <span class="keyword">by</span> shop</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">        <span class="keyword">month</span> <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span></span><br><span class="line">        <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span></span><br><span class="line">    ) <span class="keyword">as</span> shop_account_cnt</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">    x</span><br><span class="line">) <span class="comment">-- 按地区和月份进行分组,求同地区同月份下所有店铺的销售金额</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  y.shop,</span><br><span class="line">  y.province,</span><br><span class="line">  y.sale_cnt,</span><br><span class="line">  z.province_sale,</span><br><span class="line">  y.shop_account_cnt</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      province,</span><br><span class="line">      <span class="keyword">month</span>,</span><br><span class="line">      <span class="keyword">sum</span>(s.sale) <span class="keyword">as</span> province_sale</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      shoptable s</span><br><span class="line">      <span class="keyword">join</span> provincetable p <span class="keyword">on</span> s.shop = p.shop</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">      s.month,</span><br><span class="line">      p.province</span><br><span class="line">  ) z</span><br><span class="line">  <span class="keyword">join</span> y <span class="keyword">on</span> z.province = y.province</span><br><span class="line">  <span class="keyword">and</span> z.month = y.month</span><br><span class="line">  </span><br><span class="line">|c   |<span class="number">1</span>    |陕西    |<span class="number">100</span>     |<span class="number">100</span>          |<span class="number">100</span>             |</span><br><span class="line">|c   |<span class="number">2</span>    |陕西    |<span class="number">100</span>     |<span class="number">100</span>          |<span class="number">200</span>             |</span><br><span class="line">|c   |<span class="number">3</span>    |陕西    |<span class="number">100</span>     |<span class="number">100</span>          |<span class="number">300</span>             |</span><br><span class="line">|b   |<span class="number">1</span>    |湖北    |<span class="number">200</span>     |<span class="number">500</span>          |<span class="number">200</span>             |</span><br><span class="line">|b   |<span class="number">2</span>    |湖北    |<span class="number">200</span>     |<span class="number">1300</span>         |<span class="number">400</span>             |</span><br><span class="line">|b   |<span class="number">3</span>    |湖北    |<span class="number">300</span>     |<span class="number">400</span>          |<span class="number">700</span>             |</span><br><span class="line">|a   |<span class="number">1</span>    |湖北    |<span class="number">300</span>     |<span class="number">500</span>          |<span class="number">300</span>             |</span><br><span class="line">|a   |<span class="number">2</span>    |湖北    |<span class="number">1100</span>    |<span class="number">1300</span>         |<span class="number">1400</span>            |</span><br><span class="line">|a   |<span class="number">3</span>    |湖北    |<span class="number">100</span>     |<span class="number">400</span>          |<span class="number">1500</span>   </span><br></pre></td></tr></table></figure>



<h3 id="用户行为画像"><a href="#用户行为画像" class="headerlink" title="用户行为画像"></a>用户行为画像</h3><h5 id="订单标签"><a href="#订单标签" class="headerlink" title="订单标签"></a>订单标签</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 源表.订单主要信息表  订单签收人信息表</span></span><br><span class="line"><span class="comment">-- order order_desc</span></span><br><span class="line"><span class="comment">-- 重要的处理事项:是否要去重,where(分区字段),</span></span><br><span class="line"><span class="comment">-- 可以考虑把temp单独地做成一张表,这样方便计算</span></span><br><span class="line"><span class="keyword">with</span> temp <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  a.order_id   ,<span class="comment">-- 订单ID</span></span><br><span class="line">  a.order_date ,<span class="comment">-- 订单日期</span></span><br><span class="line">  a.user_id    , <span class="comment">-- 用户ID</span></span><br><span class="line">  a.order_money , <span class="comment">-- 订单金额(应付金额)</span></span><br><span class="line">  a.order.status , <span class="comment">-- 订单状态(6:退货,7:拒收)</span></span><br><span class="line">  a.pay_type , <span class="comment">-- 订单支付类型</span></span><br><span class="line">  b.area_name ,<span class="comment">-- 收货人地址</span></span><br><span class="line">  b.address ,<span class="comment">-- 手工地址</span></span><br><span class="line">  b.coupen_money <span class="comment">-- 代金券金额</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">  <span class="keyword">order</span> a <span class="keyword">join</span> order_desc b <span class="keyword">on</span> a.user_id = b.user_id</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模块一</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  user_id , <span class="comment">-- 用户</span></span><br><span class="line">  <span class="keyword">min</span>(order_date) , <span class="comment">-- 首单</span></span><br><span class="line">  <span class="keyword">max</span>(order_date) , <span class="comment">-- 末单日期</span></span><br><span class="line">  <span class="keyword">datediff</span>(<span class="string">&#x27;2020-12-12&#x27;</span>,<span class="keyword">min</span>(order_date)) , <span class="comment">-- 首单距今时间</span></span><br><span class="line">  <span class="keyword">datediff</span>(<span class="string">&#x27;2020-12-12&#x27;</span>,<span class="keyword">max</span>(order_date)) , <span class="comment">-- 末单距今时间</span></span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">if</span>(<span class="keyword">datediff</span>(<span class="string">&#x27;2020-12-12&#x27;</span>,order_date) &lt;=<span class="number">30</span>,<span class="number">1</span>,<span class="literal">null</span>)), <span class="comment">-- 最近三十天购买次数</span></span><br><span class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(<span class="keyword">datediff</span>(<span class="string">&#x27;2020-12-12&#x27;</span>,order_date) &lt;=<span class="number">30</span>,order_money,<span class="number">0</span>)), <span class="comment">-- 最近三十天购买的金额</span></span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">if</span>(<span class="keyword">datediff</span>(<span class="string">&#x27;2020-12-12&#x27;</span>,order_date) &lt;=<span class="number">60</span>,<span class="number">1</span>,<span class="literal">null</span>)), <span class="comment">-- 最近六十天购买次数</span></span><br><span class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(<span class="keyword">datediff</span>(<span class="string">&#x27;2020-12-12&#x27;</span>,order_date) &lt;=<span class="number">60</span>,order_money,<span class="number">0</span>)), <span class="comment">-- 最近六十天购买的金额</span></span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">if</span>(<span class="keyword">datediff</span>(<span class="string">&#x27;2020-12-12&#x27;</span>,order_date) &lt;=<span class="number">90</span>,<span class="number">1</span>,<span class="literal">null</span>)), <span class="comment">-- 最近九十天购买次数</span></span><br><span class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(<span class="keyword">datediff</span>(<span class="string">&#x27;2020-12-12&#x27;</span>,order_date) &lt;=<span class="number">90</span>,order_money,<span class="number">0</span>)), <span class="comment">-- 最近九十天购买的金额</span></span><br><span class="line">  <span class="keyword">min</span>(order_money) , <span class="comment">-- 最小的金额</span></span><br><span class="line">  <span class="keyword">max</span>(order_money) , <span class="comment">-- 最大的金额</span></span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">if</span>(order_status != <span class="string">&#x27;6&#x27;</span> <span class="keyword">and</span> order_status != <span class="string">&#x27;7&#x27;</span>,<span class="number">1</span>,<span class="literal">null</span>)) , <span class="comment">-- 累计消费次数(不含推拒),注意是6.7是字符串</span></span><br><span class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(order_status != <span class="string">&#x27;6&#x27;</span> <span class="keyword">and</span> order_status != <span class="string">&#x27;7&#x27;</span>,order_money,<span class="number">0</span>)) , <span class="comment">-- 累计代金券金额(不含推拒)</span></span><br><span class="line">  <span class="keyword">avg</span>(order_money) , <span class="comment">-- 平均订单金额</span></span><br><span class="line">  <span class="keyword">avg</span>(<span class="keyword">if</span>(<span class="keyword">datediff</span>(<span class="string">&#x27;2020-12-12&#x27;</span>,order_date) &lt;=<span class="number">90</span>,order_money,<span class="literal">null</span>)) <span class="comment">-- 最近九十天的平均的订单的金额           </span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  temp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id <span class="comment">-- 用户画像标签计算</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模块二:常用地址</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  user_id, </span><br><span class="line">  common_address <span class="comment">-- 常用地址</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  user_id  ,<span class="comment">-- 用户</span></span><br><span class="line">  <span class="keyword">concat_ws</span>(<span class="string">&#x27; &#x27;</span>,address,area_name ) <span class="keyword">as</span> common_address  ,<span class="comment">-- 常用地址(可能为null)</span></span><br><span class="line">  row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">desc</span> <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span>  <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span>) <span class="keyword">as</span> rn</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  temp </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id,<span class="keyword">concat_ws</span>(<span class="string">&#x27; &#x27;</span>,address,area_name )</span><br><span class="line">) o </span><br><span class="line"><span class="keyword">where</span> o.rn = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模块三:常用支付方式</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  user_id, <span class="comment">-- 用户ID</span></span><br><span class="line">  pay_type,<span class="comment">-- 常用支付方式</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  user_id,</span><br><span class="line">  pay_type,</span><br><span class="line">  row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> num_pay <span class="keyword">desc</span> <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span>  <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span> ) <span class="keyword">as</span> rn</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  user_id,</span><br><span class="line">  pay_type,</span><br><span class="line">  <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> num_pay</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  temp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id,pay_type</span><br><span class="line">) o </span><br><span class="line">) o1</span><br><span class="line"><span class="keyword">where</span> rn = <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模块四:购物车</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  user_id , <span class="comment">-- 用户ID</span></span><br><span class="line">  <span class="keyword">count</span>(<span class="number">1</span>),      <span class="comment">--最近30天加购次数</span></span><br><span class="line">  <span class="keyword">sum</span>(<span class="built_in">number</span>) ,<span class="comment">-- 最近30天加购商品件数</span></span><br><span class="line">  <span class="keyword">sum</span>(<span class="keyword">if</span>(submit_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> ,<span class="built_in">number</span> ,<span class="number">0</span>)) <span class="comment">-- 最近30天提交次数</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  cart <span class="comment">-- 购物车信息表</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">datediff</span>(<span class="string">&#x27;2020-12-12&#x27;</span>,add_time) &lt;= <span class="number">30</span> <span class="comment">-- 先过滤</span></span><br><span class="line"><span class="keyword">group</span>  <span class="keyword">by</span> user_id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模块五:可能有的用户订单购物车某一部分没有,考虑是否这两张表的uid作为数据链接的基础</span></span><br><span class="line"><span class="keyword">with</span> temp5 <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span>  user_id <span class="keyword">from</span> <span class="keyword">order</span> </span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line"><span class="keyword">select</span>  user_id <span class="keyword">from</span> cart</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 整合五个模块即可求出</span></span><br></pre></td></tr></table></figure>



<h5 id="偏好标签"><a href="#偏好标签" class="headerlink" title="偏好标签"></a>偏好标签</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用户购物偏好标签</span></span><br><span class="line"><span class="comment">-- 关联三张表</span></span><br><span class="line"><span class="comment">-- 订单表 order 订单商品详情表 orders_good 商品描述表 goods</span></span><br><span class="line"><span class="comment">-- 做一张中间表存储三张表关联的结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tag(</span><br><span class="line">user_id <span class="keyword">string</span> ,</span><br><span class="line">first_cat_name  <span class="keyword">string</span> ,</span><br><span class="line">second_cat_name <span class="keyword">string</span> ,</span><br><span class="line">third_cat_name <span class="keyword">string</span>,</span><br><span class="line">brand_id_name  <span class="keyword">string</span>,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> parquet tblproperties(<span class="string">&quot;parquet.compress&quot;</span> = <span class="string">&quot;snappy&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span>  tag </span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  order.user_id, <span class="comment">-- 用户ID</span></span><br><span class="line">  goods.first_cat_name, <span class="comment">-- 一类标签</span></span><br><span class="line">  goods.second_cat_name,</span><br><span class="line">  goods.third_cat_name,</span><br><span class="line">  goods.brand_id_name <span class="comment">-- 商品标签</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">  <span class="keyword">order</span> </span><br><span class="line"><span class="keyword">join</span> orders_good <span class="keyword">on</span> order.order_id = orders_good.order_id</span><br><span class="line"><span class="keyword">join</span> goods <span class="keyword">on</span>  orders_good.goods_id = goods.sku_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  user_id,</span><br><span class="line">  first_cat_name</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  user_id,</span><br><span class="line">  first_cat_name,</span><br><span class="line">  row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">count</span>(<span class="number">1</span>)) <span class="keyword">as</span> rn<span class="comment">-- 标签数</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  tag</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id,first_cat_name</span><br><span class="line">)</span><br><span class="line"><span class="keyword">where</span> rn = <span class="number">1</span></span><br><span class="line">),</span><br><span class="line">tmp2 <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  user_id,</span><br><span class="line">  second_cat_name</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  user_id,</span><br><span class="line">  second_cat_name,</span><br><span class="line">  row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">count</span>(<span class="number">1</span>)) <span class="keyword">as</span> rn </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  tag</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id,second_cat_name</span><br><span class="line">)</span><br><span class="line"><span class="keyword">where</span> rn = <span class="number">1</span></span><br><span class="line">),</span><br><span class="line">tmp3 <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  user_id,</span><br><span class="line">  third_cat_name</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  user_id,</span><br><span class="line">  third_cat_name,</span><br><span class="line">  row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">count</span>(<span class="number">1</span>)) <span class="keyword">as</span> rn </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  tag</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id,third_cat_name</span><br><span class="line">)</span><br><span class="line"><span class="keyword">where</span> rn = <span class="number">1</span></span><br><span class="line">),</span><br><span class="line">tmp4 <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  user_id,</span><br><span class="line">  brand_id_name</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  user_id,</span><br><span class="line">  brand_id_name,</span><br><span class="line">  row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">count</span>(<span class="number">1</span>)) <span class="keyword">as</span> rn </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  tag</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id,brand_id_name</span><br><span class="line">)</span><br><span class="line"><span class="keyword">where</span> rn = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  tmp1.user_id, <span class="comment">-- 用户ID</span></span><br><span class="line">  tmp1.first_cat_name <span class="keyword">as</span> common_first_cat, <span class="comment">-- 最常购买的一类标签</span></span><br><span class="line">  tmp2.second_cat_name <span class="keyword">as</span> common_second_cat,</span><br><span class="line">  tmp3.third_cat_name <span class="keyword">as</span> common_third_cat, <span class="comment">-- 最常购买的三类标签</span></span><br><span class="line">  tmp4.brand_id_name <span class="keyword">as</span> common_brand_id <span class="comment">-- 最常购买的标签</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">  tmp </span><br><span class="line"><span class="keyword">join</span>  tmp2 <span class="keyword">on</span> tmp1.user_id = tmp2.user_id</span><br><span class="line"><span class="keyword">join</span>  tmp3 <span class="keyword">on</span> tmp1.user_id = tmp3.user_id</span><br><span class="line"><span class="keyword">join</span>  tmp4 <span class="keyword">on</span> tmp1.user_id = tmp4.user_id</span><br></pre></td></tr></table></figure>



<h1 id="Task-Scheduling"><a href="#Task-Scheduling" class="headerlink" title="Task Scheduling"></a>Task Scheduling</h1><h3 id="Azkaban"><a href="#Azkaban" class="headerlink" title="Azkaban"></a>Azkaban</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 安装略</span><br><span class="line">--job文件内容如下</span><br><span class="line">type=command</span><br><span class="line">command=/home/atguigu/bin/dwd_to_dws.sh $&#123;dt&#125;</span><br><span class="line">dependencies=ods_to_dwd_db,ods_to_dwd_start_log</span><br><span class="line"></span><br><span class="line">-- 状况的处理</span><br><span class="line">schedule定时调度对于参数dt的value值设置为空</span><br><span class="line">在任务执行中断.对执行脚本进行修正,在web页面点击prepareexecutor接着执行</span><br></pre></td></tr></table></figure>



<h1 id="Metadata-Management"><a href="#Metadata-Management" class="headerlink" title="Metadata Management"></a>Metadata Management</h1><h3 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">安装略</span><br><span class="line">对于 hive sql 任务，我们可以完美的通过 atlas 的 hive hook 来实现表、以及字段的血缘，而对于 spark sql 任务，使用 spark-atlas-connector 只能实现表级别的血缘</span><br></pre></td></tr></table></figure>



<h1 id="User-Profile"><a href="#User-Profile" class="headerlink" title="User Profile"></a>User Profile</h1><h3 id="朴素贝叶斯算法示例"><a href="#朴素贝叶斯算法示例" class="headerlink" title="朴素贝叶斯算法示例"></a>朴素贝叶斯算法示例</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">-- 示例一:图像的简单识别:构建特征工程(矩阵) 略</span><br><span class="line"></span><br><span class="line">-- 示例二:预测出轨率:依据原始数据特征,加工成数值特征</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CheatPredict</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder()</span><br><span class="line">      .appName(<span class="string">&quot;出轨预测&quot;</span>)</span><br><span class="line">      .master(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">      .getOrCreate()</span><br><span class="line">    <span class="comment">//加载原始样本数据</span></span><br><span class="line">    spark.read.option(<span class="string">&quot;header&quot;</span>, <span class="string">&quot;true&quot;</span>).csv(<span class="string">&quot;C:\\Users\\hp\\IdeaProjects\\TiTan\\userprofile\\src\\main\\resources\\sample.csv&quot;</span>).selectExpr(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;job&quot;</span>, <span class="string">&quot;cast(income as double) as income&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;sex&quot;</span>, <span class="string">&quot;label&quot;</span>).createTempView(<span class="string">&quot;simple&quot;</span>)</span><br><span class="line">    <span class="comment">//加载测试数据</span></span><br><span class="line">    spark.read.option(<span class="string">&quot;header&quot;</span>, <span class="string">&quot;true&quot;</span>).csv(<span class="string">&quot;C:\\Users\\hp\\IdeaProjects\\TiTan\\userprofile\\src\\main\\resources\\test.csv&quot;</span>).selectExpr(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;job&quot;</span>, <span class="string">&quot;cast(income as double) as income&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;sex&quot;</span>).createTempView(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    <span class="comment">//原始数据的特征，加工成数值特征</span></span><br><span class="line">   spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |name as name ,</span></span><br><span class="line"><span class="string">        |cast(</span></span><br><span class="line"><span class="string">        |case job</span></span><br><span class="line"><span class="string">        |     when &#x27;程序员&#x27;  then 0.0</span></span><br><span class="line"><span class="string">        |     when &#x27;老师&#x27;    then 1.0</span></span><br><span class="line"><span class="string">        |     when &#x27;公务员&#x27;  then 2.0</span></span><br><span class="line"><span class="string">        |     end as double ) as job,</span></span><br><span class="line"><span class="string">        |</span></span><br><span class="line"><span class="string">        |cast(</span></span><br><span class="line"><span class="string">        |case</span></span><br><span class="line"><span class="string">        |  when income&lt;10000                   then  0.0</span></span><br><span class="line"><span class="string">        |  when income&gt;=10000 and income&lt;20000 then  1.0</span></span><br><span class="line"><span class="string">        |  when income&gt;=20000 and income&lt;30000 then  2.0</span></span><br><span class="line"><span class="string">        |  when income&gt;=30000 and income&lt;40000 then  3.0</span></span><br><span class="line"><span class="string">        |  else 4.0</span></span><br><span class="line"><span class="string">        |end as double) as income,</span></span><br><span class="line"><span class="string">        |</span></span><br><span class="line"><span class="string">        |cast(</span></span><br><span class="line"><span class="string">        |case</span></span><br><span class="line"><span class="string">        |  when  age=&#x27;青年&#x27; then 0.0</span></span><br><span class="line"><span class="string">        |  when  age=&#x27;中年&#x27; then 1.0</span></span><br><span class="line"><span class="string">        |  when  age=&#x27;老年&#x27; then 2.0</span></span><br><span class="line"><span class="string">        |  end as double ) as age,</span></span><br><span class="line"><span class="string">        |</span></span><br><span class="line"><span class="string">        |cast(if(sex=&#x27;男&#x27;,1,0) as double) as sex,</span></span><br><span class="line"><span class="string">        |cast(if(label=&#x27;出轨&#x27;,0.0,1.0)  as double) as label  -- 标签</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |simple</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line">    .createTempView(<span class="string">&quot;simpledata&quot;</span>)</span><br><span class="line"></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |name as name ,</span></span><br><span class="line"><span class="string">        |cast(</span></span><br><span class="line"><span class="string">        |case  job</span></span><br><span class="line"><span class="string">        |   when  &#x27;老师&#x27; then 0.0</span></span><br><span class="line"><span class="string">        |   when &#x27;程序员&#x27; then 1.0</span></span><br><span class="line"><span class="string">        |   when &#x27;公务员&#x27; then 2.0</span></span><br><span class="line"><span class="string">        |   end as double</span></span><br><span class="line"><span class="string">        |) as job ,</span></span><br><span class="line"><span class="string">        |</span></span><br><span class="line"><span class="string">        |cast(</span></span><br><span class="line"><span class="string">        |case</span></span><br><span class="line"><span class="string">        |  when income&lt;10000                   then  0.0</span></span><br><span class="line"><span class="string">        |  when income&gt;=10000 and income&lt;20000 then  1.0</span></span><br><span class="line"><span class="string">        |  when income&gt;=20000 and income&lt;30000 then  2.0</span></span><br><span class="line"><span class="string">        |  when income&gt;=30000 and income&lt;40000 then  3.0</span></span><br><span class="line"><span class="string">        |  else 4.0</span></span><br><span class="line"><span class="string">        |end as double) as income ,</span></span><br><span class="line"><span class="string">        |cast(</span></span><br><span class="line"><span class="string">        |case</span></span><br><span class="line"><span class="string">        |  when  age=&#x27;青年&#x27; then 0.0</span></span><br><span class="line"><span class="string">        |  when  age=&#x27;中年&#x27; then 1.0</span></span><br><span class="line"><span class="string">        |  when  age=&#x27;老年&#x27; then 2.0</span></span><br><span class="line"><span class="string">        |  end as double ) as age,</span></span><br><span class="line"><span class="string">        |</span></span><br><span class="line"><span class="string">        |cast(if(sex=&#x27;男&#x27;,1,0) as double) as sex</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |test</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line">    .createTempView(<span class="string">&quot;testdata&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数值化的特征数据，向量化！（把特征转成特征向量 Vector=&gt;DenseVector密集型向量 , SparseVector 稀疏型向量)</span></span><br><span class="line">    <span class="keyword">val</span> arr_Vector = (arr: mutable.<span class="type">WrappedArray</span>[<span class="type">Double</span>]) =&gt; &#123;</span><br><span class="line">      <span class="type">Vectors</span>.dense(arr.toArray)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spark.udf.register(<span class="string">&quot;arr_vector&quot;</span>, arr_Vector)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> simple = spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |name,</span></span><br><span class="line"><span class="string">        |arr_vector(array(job,income,age,sex)) as features,</span></span><br><span class="line"><span class="string">        |label</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |simpledata</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> test = spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |name,</span></span><br><span class="line"><span class="string">        |arr_vector(array(job,income,age,sex)) as features</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |testdata</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//算法</span></span><br><span class="line">    <span class="comment">// 构建对象</span></span><br><span class="line">    <span class="keyword">val</span> bayes = <span class="keyword">new</span> <span class="type">NaiveBayes</span>()</span><br><span class="line">      .setLabelCol(<span class="string">&quot;label&quot;</span>)</span><br><span class="line">      .setFeaturesCol(<span class="string">&quot;features&quot;</span>)</span><br><span class="line">      .setSmoothing(<span class="number">0.01</span>) <span class="comment">// 拉普拉斯平滑系数</span></span><br><span class="line">      .setPredictionCol(<span class="string">&quot;cheat&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> model = bayes.fit(simple)</span><br><span class="line">    <span class="comment">//持久化训练集</span></span><br><span class="line">    model.save(<span class="string">&quot;C:\\Users\\hp\\IdeaProjects\\TiTan\\userprofile\\src\\main\\resources\\mode&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> naiveBayesModel = <span class="type">NaiveBayesModel</span>.load(<span class="string">&quot;C:\\Users\\hp\\IdeaProjects\\TiTan\\userprofile\\src\\main\\resources\\mode&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> frame = naiveBayesModel.transform(test)</span><br><span class="line">    frame.show(<span class="number">10</span>, <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="KNN算法示例"><a href="#KNN算法示例" class="headerlink" title="KNN算法示例"></a>KNN算法示例</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//label,f1,f2,f3,f4,f5 simple</span></span><br><span class="line"><span class="comment">//id,f1,f2,f3,f4,f5 test</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KNNdemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().master(<span class="string">&quot;local[*]&quot;</span>).appName(<span class="keyword">this</span>.getClass.getSimpleName).getOrCreate()</span><br><span class="line">    <span class="keyword">val</span> schema = <span class="keyword">new</span> <span class="type">StructType</span>()</span><br><span class="line">      .add(<span class="string">&quot;label&quot;</span>, <span class="type">DataTypes</span>.<span class="type">DoubleType</span>)</span><br><span class="line">      .add(<span class="string">&quot;f1&quot;</span>, <span class="type">DataTypes</span>.<span class="type">DoubleType</span>)</span><br><span class="line">      .add(<span class="string">&quot;f2&quot;</span>, <span class="type">DataTypes</span>.<span class="type">DoubleType</span>)</span><br><span class="line">      .add(<span class="string">&quot;f3&quot;</span>, <span class="type">DataTypes</span>.<span class="type">DoubleType</span>)</span><br><span class="line">      .add(<span class="string">&quot;f4&quot;</span>, <span class="type">DataTypes</span>.<span class="type">DoubleType</span>)</span><br><span class="line">      .add(<span class="string">&quot;f5&quot;</span>, <span class="type">DataTypes</span>.<span class="type">DoubleType</span>)</span><br><span class="line">    <span class="comment">//测试数据</span></span><br><span class="line">    <span class="keyword">val</span> simpleframe = spark.read.schema(schema).option(<span class="string">&quot;header&quot;</span>, <span class="literal">true</span>.toString).csv(<span class="string">&quot;userprofile/src/main/resources/KNN/simple.csv&quot;</span>)</span><br><span class="line">    simpleframe.createTempView(<span class="string">&quot;simple&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> schema1 = <span class="keyword">new</span> <span class="type">StructType</span>()</span><br><span class="line">      .add(<span class="string">&quot;id&quot;</span>, <span class="type">DataTypes</span>.<span class="type">DoubleType</span>)</span><br><span class="line">      .add(<span class="string">&quot;f1&quot;</span>, <span class="type">DataTypes</span>.<span class="type">DoubleType</span>)</span><br><span class="line">      .add(<span class="string">&quot;f2&quot;</span>, <span class="type">DataTypes</span>.<span class="type">DoubleType</span>)</span><br><span class="line">      .add(<span class="string">&quot;f3&quot;</span>, <span class="type">DataTypes</span>.<span class="type">DoubleType</span>)</span><br><span class="line">      .add(<span class="string">&quot;f4&quot;</span>, <span class="type">DataTypes</span>.<span class="type">DoubleType</span>)</span><br><span class="line">      .add(<span class="string">&quot;f5&quot;</span>, <span class="type">DataTypes</span>.<span class="type">DoubleType</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> testframe = spark.read.schema(schema1).option(<span class="string">&quot;header&quot;</span>, <span class="literal">true</span>.toString).csv(<span class="string">&quot;userprofile/src/main/resources/KNN/test.csv&quot;</span>)</span><br><span class="line">    testframe.createTempView(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line">    <span class="comment">//计算欧氏距离的函数</span></span><br><span class="line">    <span class="keyword">val</span> eudi: <span class="type">UserDefinedFunction</span> = udf(</span><br><span class="line">      (arr1: mutable.<span class="type">WrappedArray</span>[<span class="type">Double</span>], arr2: mutable.<span class="type">WrappedArray</span>[<span class="type">Double</span>]) =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> v1 = <span class="type">Vectors</span>.dense(arr1.toArray)</span><br><span class="line">        <span class="keyword">val</span> v2 = <span class="type">Vectors</span>.dense(arr2.toArray)</span><br><span class="line">        <span class="type">Vectors</span>.sqdist(v1, v2)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">//计算欧氏距离的函数</span></span><br><span class="line">    <span class="keyword">val</span> eudi1 = (arr1: mutable.<span class="type">WrappedArray</span>[<span class="type">Double</span>], arr2: mutable.<span class="type">WrappedArray</span>[<span class="type">Double</span>]) =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> data: <span class="type">Double</span> = arr1.zip(arr2).map(it =&gt; <span class="type">Math</span>.pow((it._2 - it._1), <span class="number">2</span>)).sum</span><br><span class="line">      <span class="number">1</span> / (<span class="type">Math</span>.pow(data, <span class="number">0.5</span>) + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    spark.udf.register(<span class="string">&quot;eudi1&quot;</span>, eudi1)</span><br><span class="line">    <span class="comment">//笛卡尔积</span></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |a.id,</span></span><br><span class="line"><span class="string">        |b.label,</span></span><br><span class="line"><span class="string">        |eudi1(array(a.f1,a.f2,a.f3,a.f4,a.f5),array(b.f1,b.f2,b.f3,b.f4,b.f5)) as dist</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |test  a cross join simple b</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin).createTempView(<span class="string">&quot;tmp&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//|id |label|dist                |</span></span><br><span class="line">    <span class="comment">//+---+-----+--------------------+</span></span><br><span class="line">    <span class="comment">//|1.0|0.0  |0.17253779651421453 |</span></span><br><span class="line">    <span class="comment">//|2.0|0.0  |0.11696132920126338 |</span></span><br><span class="line">    <span class="comment">//|3.0|0.0  |0.0389439561817535  |</span></span><br><span class="line">    <span class="comment">//|4.0|0.0  |0.03583298491583323 |</span></span><br><span class="line">    <span class="comment">//|5.0|0.0  |0.03583298491583323 |</span></span><br><span class="line">    <span class="comment">//|1.0|0.0  |0.18660549686337075 |</span></span><br><span class="line">    <span class="comment">//|2.0|0.0  |0.11189119247086728 |</span></span><br><span class="line">    spark.sql(</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |id,label</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |(</span></span><br><span class="line"><span class="string">        |select</span></span><br><span class="line"><span class="string">        |id,label,</span></span><br><span class="line"><span class="string">        |row_number() over(partition by id order by dist desc  ) as rn</span></span><br><span class="line"><span class="string">        |from</span></span><br><span class="line"><span class="string">        |tmp</span></span><br><span class="line"><span class="string">        |) o</span></span><br><span class="line"><span class="string">        |where rn = 1</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin).show(<span class="number">100</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//|id |label|</span></span><br><span class="line">    <span class="comment">//+---+-----+</span></span><br><span class="line">    <span class="comment">//|1.0|1.0  |</span></span><br><span class="line">    <span class="comment">//|4.0|0.0  |</span></span><br><span class="line">    <span class="comment">//|3.0|0.0  |</span></span><br><span class="line">    <span class="comment">//|2.0|1.0  |</span></span><br><span class="line">    <span class="comment">//|5.0|0.0  |</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="TF-IDF算法示例"><a href="#TF-IDF算法示例" class="headerlink" title="TF-IDF算法示例"></a>TF-IDF算法示例</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TF 词频</span></span><br><span class="line"><span class="comment">//IDF 逆文档频率 lg(文档总数/(1+出现这个词的文档数))</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TFIDFdemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().master(<span class="string">&quot;local[*]&quot;</span>).appName(<span class="keyword">this</span>.getClass.getSimpleName).getOrCreate()</span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line">    <span class="comment">//分别读取三类评价数据</span></span><br><span class="line">    <span class="comment">//添加标签</span></span><br><span class="line">    <span class="keyword">val</span> frame0 = spark.read.textFile(<span class="string">&quot;userprofile/src/main/resources/TFIDF/good.txt&quot;</span>).selectExpr(<span class="string">&quot;value as cmt&quot;</span>, <span class="string">&quot;cast(0.0 as double) as label&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> frame1 = spark.read.textFile(<span class="string">&quot;userprofile/src/main/resources/TFIDF/general.txt&quot;</span>).selectExpr(<span class="string">&quot;value as cmt&quot;</span>, <span class="string">&quot;cast(1.0 as double) as label&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> frame2 = spark.read.textFile(<span class="string">&quot;userprofile/src/main/resources/TFIDF/poor.txt&quot;</span>).selectExpr(<span class="string">&quot;value as cmt&quot;</span>, <span class="string">&quot;cast(2.0 as double) as label&quot;</span>)</span><br><span class="line">    <span class="comment">//读取停止数据</span></span><br><span class="line">    <span class="keyword">val</span> framestop: <span class="type">Array</span>[<span class="type">String</span>] = spark.read.textFile(<span class="string">&quot;userprofile/src/main/resources/TFIDF/poor.txt&quot;</span>).collect()</span><br><span class="line">    <span class="comment">//广播停止数据</span></span><br><span class="line">    <span class="keyword">val</span> broadcastvalue = spark.sparkContext.broadcast(framestop)</span><br><span class="line">    <span class="keyword">val</span> frame3 = frame0.union(frame1).union(frame2)</span><br><span class="line">    <span class="comment">//持久化</span></span><br><span class="line">    frame3.cache()</span><br><span class="line">    <span class="keyword">val</span> hanrdd: <span class="type">Dataset</span>[(mutable.<span class="type">Seq</span>[<span class="type">String</span>], <span class="type">Double</span>)] = frame3.map(row =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> str = row.getAs[<span class="type">String</span>](<span class="string">&quot;cmt&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> label = row.getAs[<span class="type">Double</span>](<span class="string">&quot;label&quot;</span>)</span><br><span class="line">      (str, label)</span><br><span class="line">      <span class="comment">//一个分区的数据</span></span><br><span class="line">    &#125;).mapPartitions(data =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> value = broadcastvalue.value</span><br><span class="line">      <span class="comment">//一个分区的一行数据</span></span><br><span class="line">      data.map(txt =&gt; &#123;</span><br><span class="line">        <span class="keyword">import</span> scala.collection.<span class="type">JavaConversions</span>._</span><br><span class="line">        <span class="comment">//HanLP中文分词器</span></span><br><span class="line">        <span class="keyword">val</span> words: mutable.<span class="type">Seq</span>[<span class="type">String</span>] = <span class="type">HanLP</span>.segment(txt._1).map(_.word).filter(st =&gt; (!value.contains(st)) &amp;&amp; st.length &gt;= <span class="number">2</span>)</span><br><span class="line">        (words, txt._2)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">val</span> dataFrame = hanrdd.toDF(<span class="string">&quot;words&quot;</span>, <span class="string">&quot;label&quot;</span>)</span><br><span class="line">    <span class="comment">//hash映射</span></span><br><span class="line">    <span class="keyword">val</span> tf = <span class="keyword">new</span> <span class="type">HashingTF</span>()</span><br><span class="line">      .setInputCol(<span class="string">&quot;words&quot;</span>)</span><br><span class="line">      .setNumFeatures(<span class="number">100000</span>)</span><br><span class="line">      <span class="comment">//输出字段</span></span><br><span class="line">      .setOutputCol(<span class="string">&quot;tf_vec&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> dataFrame1 = tf.transform(dataFrame)</span><br><span class="line">    <span class="comment">// 用idf算法，将上面tf特征向量集合变成 TF-IDF特征值向量集合</span></span><br><span class="line">    <span class="keyword">val</span> idf = <span class="keyword">new</span> <span class="type">IDF</span>()</span><br><span class="line">      .setInputCol(<span class="string">&quot;tf_vec&quot;</span>)</span><br><span class="line">      .setOutputCol(<span class="string">&quot;tf_idf_vec&quot;</span>)</span><br><span class="line">    <span class="comment">//fit得到一个模型</span></span><br><span class="line">    <span class="keyword">val</span> iDFModel = idf.fit(dataFrame1)</span><br><span class="line">    <span class="keyword">val</span> tfidfVecs = iDFModel.transform(dataFrame1)</span><br><span class="line">   tfidfVecs.show(<span class="number">100</span>,<span class="literal">false</span>)</span><br><span class="line">       <span class="comment">//|[好评]            |0.0  |(100000,[10695],[1.0])                    |(100000,[10695],[1.791759469228055])                                                  |</span></span><br><span class="line">    <span class="comment">//|[不错, ....]      |0.0  |(100000,[42521,70545],[1.0,1.0])          |(100000,[42521,70545],[2.1972245773362196,2.1972245773362196])                        |</span></span><br><span class="line">    <span class="comment">//|[红包]            |0.0  |(100000,[10970],[1.0])                    |(100000,[10970],[2.1972245773362196]) </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//将总的数据分区测试集合样本集</span></span><br><span class="line">    <span class="keyword">val</span> array = tfidfVecs.randomSplit(<span class="type">Array</span>(<span class="number">0.8</span>, <span class="number">0.2</span>))</span><br><span class="line">    <span class="keyword">val</span> train = array(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> test = array(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//训练</span></span><br><span class="line">    <span class="comment">// 训练朴素贝叶斯模型</span></span><br><span class="line">    <span class="keyword">val</span> bayes = <span class="keyword">new</span> <span class="type">NaiveBayes</span>()</span><br><span class="line">      .setLabelCol(<span class="string">&quot;label&quot;</span>)</span><br><span class="line">      .setFeaturesCol(<span class="string">&quot;tf_idf_vec&quot;</span>)</span><br><span class="line">      .setSmoothing(<span class="number">1.0</span>)</span><br><span class="line">      .setModelType(<span class="string">&quot;multinomial&quot;</span>)</span><br><span class="line">    <span class="comment">//模型</span></span><br><span class="line">    <span class="keyword">val</span> model = bayes.fit(train)</span><br><span class="line">    <span class="comment">//测试模型的效果</span></span><br><span class="line">    <span class="keyword">val</span> frame = model.transform(test)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="逻辑回归算法示例"><a href="#逻辑回归算法示例" class="headerlink" title="逻辑回归算法示例"></a>逻辑回归算法示例</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//流失率预测</span></span><br><span class="line"><span class="comment">//逻辑回归算法与朴素贝叶斯算法的一点区别在于逻辑回归的特征向量有数量含义,而朴素贝叶斯的特征向量就是简单的离散标签没有数量特征</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Logistic</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">Logger</span>.getLogger(<span class="string">&quot;org.apache.spark&quot;</span>).setLevel(<span class="type">Level</span>.<span class="type">WARN</span>)</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="keyword">this</span>.getClass.getSimpleName).master(<span class="string">&quot;local[*]&quot;</span>).getOrCreate()</span><br><span class="line">    <span class="keyword">val</span> simple = spark.read.option(<span class="string">&quot;header&quot;</span>, <span class="string">&quot;true&quot;</span>).option(<span class="string">&quot;inferSchema&quot;</span>, <span class="literal">true</span>).csv(<span class="string">&quot;userprofile/src/main/resources/Logistic/ loss_predict.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数组转为向量</span></span><br><span class="line">    <span class="keyword">val</span> arr2Vec = (arr: mutable.<span class="type">WrappedArray</span>[<span class="type">Double</span>]) =&gt; <span class="type">Vectors</span>.dense(arr.toArray)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//label,gid,3_cs,15_cs,3_xf,15_xf,3_th,15_th,3_hp,15_hp,3_cp,15_cp,last_dl,last_xf</span></span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    spark.udf.register(<span class="string">&quot;arr2Vec&quot;</span>, arr2Vec)</span><br><span class="line">    <span class="comment">//将样本数据向量化</span></span><br><span class="line">    <span class="keyword">val</span> frame = simple.selectExpr(<span class="string">&quot;label&quot;</span>, <span class="string">&quot;arr2Vec(array(3_cs,15_cs,3_xf,15_xf,3_th,15_th,3_hp,15_hp,3_cp,15_cp,last_dl,last_xf)) as vec&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> minMaxScaler = <span class="keyword">new</span> <span class="type">MinMaxScaler</span>()</span><br><span class="line">      .setInputCol(<span class="string">&quot;vec&quot;</span>)</span><br><span class="line">      .setOutputCol(<span class="string">&quot;features&quot;</span>)</span><br><span class="line">    <span class="comment">//生成模型.训练样本</span></span><br><span class="line">    <span class="keyword">val</span> maxScalerModel = minMaxScaler.fit(frame)</span><br><span class="line">    <span class="keyword">val</span> minMaxFrame = maxScalerModel.transform(frame).drop(<span class="string">&quot;vec&quot;</span>)</span><br><span class="line">    minMaxFrame.show(<span class="number">100</span>, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">//|0.0 |[0.6666666666666666,0.9354838709677419,0.3333333333333333,0.7692307692307693,0.0,0.3333333333333333,0.7142857142857142,0.7894736842105263,0.3333333333333333,0.5,0.0,0.0]                  |</span></span><br><span class="line">    <span class="comment">//|0.0 |[0.7777777777777777,0.967741935483871,0.4444444444444444,0.7692307692307693,0.5,0.6666666666666666,0.7857142857142857,0.8421052631578947,0.6666666666666666,0.75,0.0,0.0]                  |</span></span><br><span class="line">    <span class="comment">//|0.0 |[0.8888888888888888,0.9032258064516129,0.6666666666666666,0.8461538461538463,1.0,0.6666666666666666,0.8571428571428571,0.894736842105263,0.3333333333333333,0.25,0.0,0.07692307692307693]  |</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建逻辑回归算法</span></span><br><span class="line">    <span class="keyword">val</span> logisticRegression = <span class="keyword">new</span> <span class="type">LogisticRegression</span>()</span><br><span class="line">      .setFeaturesCol(<span class="string">&quot;features&quot;</span>)</span><br><span class="line">      .setLabelCol(<span class="string">&quot;label&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span>  <span class="type">Array</span>(train,test) = minMaxFrame.randomSplit(<span class="type">Array</span>(<span class="number">0.8</span>, <span class="number">0.2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> logisticRegressionModel = logisticRegression.fit(train)</span><br><span class="line">    <span class="keyword">val</span> frame1: <span class="type">DataFrame</span> = logisticRegressionModel.transform(test)</span><br><span class="line">    frame1.select(<span class="string">&quot;label&quot;</span>,<span class="string">&quot;prediction&quot;</span>).show(<span class="number">100</span>,<span class="literal">false</span>)</span><br><span class="line">    <span class="comment">//|label|prediction|</span></span><br><span class="line">    <span class="comment">//+-----+----------+</span></span><br><span class="line">    <span class="comment">//|0.0  |0.0       |</span></span><br><span class="line">    <span class="comment">//|0.0  |0.0       |</span></span><br><span class="line">    <span class="comment">//|1.0  |1.0       |</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算准确率select count(*)  from where label = prediction / select from count(*)</span></span><br></pre></td></tr></table></figure>



<h3 id="模型评估示例"><a href="#模型评估示例" class="headerlink" title="模型评估示例"></a>模型评估示例</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 混淆矩阵（Confusion Matrix):</span><br><span class="line">以分类模型中最简单的二分类为例,对于这种问题,我们的模型最终需要判断样本的结果是0还是1,或者说是positive还是negative</span><br><span class="line">我们通过样本的采集,能够直接知道真实情况下,哪些数据结果是positive,哪些结果是negative.同时,我们通过用样本数据跑出分类型模型的结果,也可以知道模型认为这些数据哪些是positive,哪些是negative</span><br><span class="line">因此,我们就能得到这样四个基础指标,我称他们是一级指标（最底层的）</span><br><span class="line">真实值是positive,模型认为是positive的数量（True Positive=TP）</span><br><span class="line">真实值是positive,模型认为是negative的数量（False Negative=FN)</span><br><span class="line">统计学上的第一类错误（Type I Error）</span><br><span class="line">真实值是negative,模型认为是positive的数量（False Positive=FP）</span><br><span class="line">统计学上的第二类错误（Type II Error）</span><br><span class="line">真实值是negative,模型认为是negative的数量（True Negative=TN）</span><br><span class="line">将这四个指标一起呈现在表格中,就能得到一个矩阵，我们称它为混淆矩阵（Confusion Matrix)</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> ROC曲线 </span><br><span class="line">精确率（precision）的定义为：P = TP / (TP + FP)，是指正样本被预测正确的比例</span><br><span class="line">召回率（recall）定义为：R = TP / (TP + FN)，是指预测为正样本的样本中,正确的比例</span><br><span class="line">灵敏度（True Positive Rate,TPR）的定义为：TPR = TP / (TP + FN),实际上与召回率的定义相同</span><br><span class="line">1-特异度（False Positive Rate,FPR）的定义为： FPR = FP / (FP + TN)</span><br><span class="line">以 TPR 为 y 轴,以 FPR 为 x 轴,调整不同的阈值得到 TPR,FPR,就可以得到 ROC 曲线</span><br><span class="line">ROC 曲线下的面积称为 AUC(Area Under Curve),从几何的角度讲,ROC 曲线下方的面积越大越大,则模型越优</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 回归分析评估指标</span><br><span class="line">RMSE（Root Mean Square Error）均方根误差</span><br><span class="line">衡量观测值与真实值之间的偏差</span><br><span class="line">常用来作为机器学习模型预测结果衡量的标准</span><br><span class="line"></span><br><span class="line">MSE（Mean Square Error）均方误差</span><br><span class="line">MSE是真实值与预测值的差值的平方然后求和平均</span><br><span class="line">通过平方的形式便于求导，所以常被用作线性回归的损失函数</span><br><span class="line"></span><br><span class="line">MAE（Mean Absolute Error）平均绝对误差</span><br><span class="line">是绝对误差的平均值</span><br><span class="line">可以更好地反映预测值误差的实际情况</span><br><span class="line"></span><br><span class="line">SD（Standard Deviation）标准差</span><br><span class="line">方差的算术平均根</span><br><span class="line">用于衡量一组数值的离散程度</span><br></pre></td></tr></table></figure>



<h1 id="OLAP"><a href="#OLAP" class="headerlink" title="OLAP"></a>OLAP</h1><h3 id="Hbase-row-key设计"><a href="#Hbase-row-key设计" class="headerlink" title="Hbase row key设计"></a>Hbase row key设计</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> Region热点问题的解决</span><br><span class="line">Reverse反转:针对固定长度的Rowkey反转后存储,这样可以使Rowkey中经常改变的部分放在最前面,可以有效的随机Rowkey</span><br><span class="line">Salt加盐:Salt是将每一个Rowkey加一个前缀,前缀使用一些随机字符,使得数据分散在多个不同的Region,达到Region负载均衡的目标</span><br><span class="line">Hash散列或者Mod:用Hash散列来替代随机Salt前缀的好处是能让一个给定的行有相同的前缀,这在分散了Region负载的同时,使读操作也能够推断</span><br></pre></td></tr></table></figure>



<h3 id="Kylin"><a href="#Kylin" class="headerlink" title="Kylin"></a>Kylin</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> cube的构建流程</span><br><span class="line">构建一个中间平表(Hive Table)：将Model中的fact表和look up表构建成一个大的Flat Hive Table</span><br><span class="line">重新分配Flat Hive Tables</span><br><span class="line">从事实表中抽取维度的Distinct值</span><br><span class="line">对所有维度表进行压缩编码，生成维度字典</span><br><span class="line">计算和统计所有的维度组合，并保存，其中，每一种维度组合，称为一个Cuboid</span><br><span class="line">创建HTable</span><br><span class="line">构建最基础的Cuboid数据</span><br><span class="line">利用算法构建N维到0维的Cuboid数据</span><br><span class="line">构建Cube</span><br><span class="line">将Cuboid数据转换成HFile</span><br><span class="line">将HFile直接加载到HBase Table中</span><br><span class="line">更新Cube信息</span><br><span class="line">清理Hive</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> Kylin中bitmap</span><br></pre></td></tr></table></figure>



<h3 id="Presto"><a href="#Presto" class="headerlink" title="Presto"></a>Presto</h3><h3 id="SuperSet"><a href="#SuperSet" class="headerlink" title="SuperSet"></a>SuperSet</h3><blockquote>
<p>安装与使用教程: <a href="https://www.jianshu.com/p/36a7e1cf97b5">https://www.jianshu.com/p/36a7e1cf97b5</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Project practice results</category>
        <category>Data Warehouse System</category>
      </categories>
      <tags>
        <tag>Work Systematically</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache-Hive实践</title>
    <url>/2020/11/14/Hive-principle-reinforcement/</url>
    <content><![CDATA[<h1 id="Apache-Hive实践"><a href="#Apache-Hive实践" class="headerlink" title="Apache-Hive实践"></a>Apache-Hive实践</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><h4 id="集合数据类型"><a href="#集合数据类型" class="headerlink" title="集合数据类型"></a>集合数据类型</h4><ul>
<li><p><strong>STRUCT:例如: address  struct&lt;street:string, city:string&gt; 可以通过address.street 来访问</strong></p>
</li>
<li><p><strong>ARRAY:例如:friends array<string>  可以通过 friend[index] 来访问</strong></p>
</li>
<li><p><strong>MAP:例如:children map&lt;string, int&gt;, 可以通过children[key]来访问</strong></p>
</li>
</ul>
<h4 id="类型的转换"><a href="#类型的转换" class="headerlink" title="类型的转换"></a>类型的转换</h4><ul>
<li><p>INT不会自动转换为TINYINT类型，它会返回错误，除非使用CAST操作</p>
</li>
<li><p>任何整数类型都可以隐式地转换为一个范围更广的类型，如TINYINT可以转换成INT，INT可以转换成BIGINT。</p>
</li>
<li><p>所有整数类型、FLOAT和STRING类型都可以隐式地转换成DOUBLE。</p>
</li>
<li><p>TINYINT、SMALLINT、INT都可以转换为FLOAT。</p>
</li>
<li><p>BOOLEAN类型不可以转换为任何其它的类型</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一行数据如下</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;MobilePlatform&quot;</span>:<span class="string">&quot;apple&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;APP&quot;</span>:[<span class="string">&quot;jianshu&quot;</span>,<span class="string">&quot;csdn&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>:&#123;</span><br><span class="line">              <span class="attr">&quot;xiaoming&quot;</span>:<span class="number">19</span>,</span><br><span class="line">              <span class="attr">&quot;xioahuang&quot;</span>:<span class="number">17</span></span><br><span class="line">         &#125;,</span><br><span class="line">     <span class="attr">&quot;address&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;street&quot;</span>:<span class="string">&quot;1000A&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;city&quot;</span>:<span class="string">&quot;zhongguo&quot;</span></span><br><span class="line">             &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建表语句</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(</span><br><span class="line">    MobilePlatform <span class="keyword">string</span>,</span><br><span class="line">    APP <span class="built_in">array</span>&lt;<span class="keyword">string</span>&gt;,</span><br><span class="line">    <span class="keyword">name</span> <span class="keyword">map</span>&lt;<span class="keyword">string</span>,<span class="built_in">int</span>&gt;,</span><br><span class="line">    address  <span class="keyword">struct</span>&lt;street:<span class="keyword">string</span>, city:<span class="keyword">string</span>&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">collection items <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;_&#x27;</span></span><br><span class="line"><span class="keyword">map</span> <span class="keyword">keys</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;:&#x27;</span></span><br><span class="line"><span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">#语句的解释</span></span><br><span class="line">1.行列分隔符</span><br><span class="line">2.MAP STRUCT 和 ARRAY 的分隔符(数据分割符号)</span><br><span class="line">3.MAP中的key与value的分隔符</span><br><span class="line">4.行分隔符</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">txt数据与导入hive的语句</span><br><span class="line">apple,jianshu<span class="emphasis">_weibo,xiaoming:19_</span>xiaohua:17,1000A<span class="emphasis">_zhongguo</span></span><br><span class="line"><span class="emphasis">songsong,bingbing_</span>lili,xiao song:18<span class="emphasis">_xiaoxiao song:19,hui long guan_</span>beijing</span><br><span class="line"></span><br><span class="line">load data local inpath &quot;/root/test.txt&quot; into table test</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询语句和结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line">apple	[&quot;jianshu&quot;,&quot;weibo&quot;]	&#123;&quot;xiaoming&quot;:19,&quot;xiaohua&quot;:17&#125;	&#123;&quot;street&quot;:&quot;1000A&quot;,&quot;city&quot;:&quot;zhongguo&quot;&#125;</span><br><span class="line">songsong	[&quot;bingbing&quot;,&quot;lili&quot;]	&#123;&quot;xiao song&quot;:18,&quot;xiaoxiao song&quot;:19&#125;	&#123;&quot;street&quot;:&quot;hui long guan&quot;,&quot;city&quot;:&quot;beijing&quot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> APP[<span class="number">1</span>],<span class="keyword">name</span>[<span class="string">&quot;xiaoming&quot;</span>], address.city <span class="keyword">from</span>  <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line">weibo	19	    zhongguo</span><br><span class="line">lili	null	beijing</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="DDL-数据定义语言详解"><a href="#DDL-数据定义语言详解" class="headerlink" title="DDL  数据定义语言详解"></a>DDL  数据定义语言详解</h2><h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><ol>
<li>数据库创建的标准语法</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>  db_demo1; </span><br><span class="line"><span class="comment">#创建一个数据库指定在HDFS位置</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>  db_demo1  <span class="string">&quot;/path&quot;</span>;</span><br></pre></td></tr></table></figure>



<ol>
<li>查询数据库的语法</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.显示 支持模糊查询</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span> <span class="keyword">like</span> <span class="string">&quot;db_*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.查询 显示数据库详细信息 extended </span></span><br><span class="line"><span class="keyword">desc</span> <span class="keyword">database</span> db_demo1;</span><br><span class="line">desc database extended db_demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.切换</span></span><br><span class="line"><span class="keyword">use</span> db_demo1</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><p>修改数据库的语法与注意事项</p>
<p>用户可以使用<code>ALTER DATABASE</code>命令为某个数据库的<code>DBPROPERTIES</code>设置键-值对属性值，来描述这个数据库的属性信息。数据库的其他元数据信息都是不可更改的，包括数据库名和数据库所在的目录位置。</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> db_demo1 <span class="keyword">set</span> dbproperties(<span class="string">&#x27;createtime&#x27;</span>=<span class="string">&#x27;20201114&#x27;</span>);</span><br></pre></td></tr></table></figure>



<ol>
<li>删除数据库的标准语法</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> db_demo1 ;</span><br><span class="line"><span class="comment">#强制删除</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> db_demo1  <span class="keyword">cascade</span>;</span><br></pre></td></tr></table></figure>



<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><ol>
<li><p>建表语法的描述</p>
<p>CREATE TABLE:建表</p>
<p>EXTERNA:外部表</p>
<p>COMMENT:为表和列添加注释</p>
<p>PARTITIONED BY:分区</p>
<p>CLUSTERED BY:分桶</p>
<p>SORTED BY:</p>
<p>ROW FORMAT:在建表的时候可以自定义SerDe或者使用自带的SerDe</p>
<p>STORED AS :设置存储的类型</p>
<p>LOCATION :指定表在HDFS上的存储位置</p>
<p>LIKE:复制现有表的结构,但不复制内容</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#普通建表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查询建表(查询结果添加到新表中)</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> student1 <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="comment">#根据已经存在的表结构建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> student2 <span class="keyword">like</span> student;</span><br><span class="line"><span class="comment">#查询类型</span></span><br><span class="line">desc formatted student2;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>内部表和外部表</strong></li>
</ol>
<ul>
<li><p>默认创建的表都是所谓的管理表，有时也被称为内部表,当我们删除一个管理表时，Hive也会删除这个表中数据。管理表不适合和其他工具共享数据</p>
</li>
<li><p>表是外部表，所以Hive并非认为其完全拥有这份数据。删除该表并不会删除掉这份数据，不过描述表的元数据信息会被删除掉</p>
</li>
<li><p><strong>删除内部表会直接删除元数据（metadata）及存储数据；删除外部表仅仅会删除元数据，HDFS上的文件并不会被删除；</strong></p>
</li>
<li><p>对内部表的修改会将修改直接同步给元数据，而对外部表的表结构和分区进行修改，则需要修复（MSCK REPAIR TABLE<br>table_name;）</p>
</li>
<li><p>适用的场合:每天将收集到的网站日志定期流入HDFS文本文件。在外部表（原始日志表）的基础上做大量的统计分析，用到的中间表、结果表使用内部表存储，数据通过SELECT+INSERT进入内部表。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#内部表和外部表的转换</span></span><br><span class="line"><span class="comment">#把内部表转换为外部表</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student2 <span class="keyword">set</span> tblproperties(<span class="string">&#x27;EXTERNAL&#x27;</span>=<span class="string">&#x27;TRUE&#x27;</span>);</span><br><span class="line"><span class="comment">##把外部表转换为内部表</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student2 <span class="keyword">set</span> tblproperties(<span class="string">&#x27;EXTERNAL&#x27;</span>=<span class="string">&#x27;FALSE&#x27;</span>);</span><br><span class="line"><span class="comment">##注意 &#x27;EXTERNAL&#x27;=&#x27;TRUE&#x27;  &#x27;EXTERNAL&#x27;=&#x27;FALSE&#x27; 是固定写法区分大小写</span></span><br></pre></td></tr></table></figure>



<ol start="3">
<li><p><strong>分区表</strong></p>
<ul>
<li><p>概念</p>
<ul>
<li><p>分区表实际上就是对应一个HDFS文件系统上的独立的文件夹，该文件夹下是该分区所有的数据文件。Hive中的分区就是分目录，把一个大的数据集根据业务需要分割成小的数据集。在查询时通过<strong>WHERE子句</strong>中的表达式选择查询所需要的指定的分区，这样的查询效率会提高很多。</p>
</li>
<li><p>查询时Hive自动过滤掉不用于提高性能的分区</p>
</li>
<li><p>分为静态分区和动态分区</p>
</li>
</ul>
</li>
<li><p>操作 (<strong>一级分区、二级分区、</strong>)</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#没有分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>  tb_order2(</span><br><span class="line"> <span class="keyword">oid</span> <span class="built_in">int</span> ,</span><br><span class="line">dt <span class="keyword">string</span> ,</span><br><span class="line"><span class="keyword">cost</span> <span class="keyword">double</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;,&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&quot;/root/6.18.txt&quot;</span> <span class="keyword">into</span> <span class="keyword">table</span>  tb_order2 ;</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&quot;/root/6.19.txt&quot;</span> <span class="keyword">into</span> <span class="keyword">table</span>  tb_order2 ;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_order2 <span class="keyword">where</span> dt=<span class="string">&#x27;2020-06-18&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#一级分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>  tb_p_order(</span><br><span class="line"><span class="keyword">oid</span> <span class="built_in">int</span> ,</span><br><span class="line">dt <span class="keyword">string</span> ,</span><br><span class="line"><span class="keyword">cost</span> <span class="keyword">double</span></span><br><span class="line">)</span><br><span class="line">partitioned  <span class="keyword">by</span> (dy <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;,&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&quot;/root/6.18.txt&quot;</span> <span class="keyword">into</span> <span class="keyword">table</span>  tb_p_order  <span class="keyword">partition</span>(dy=<span class="string">&quot;06-18&quot;</span>);</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&quot;/root/6.19.txt&quot;</span> <span class="keyword">into</span> <span class="keyword">table</span>  tb_p_order  <span class="keyword">partition</span>(dy=<span class="string">&quot;06-19&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_p_order <span class="keyword">where</span>  dy=<span class="string">&quot;06-18&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_p_order <span class="keyword">drop</span>  <span class="keyword">partition</span> (dy = <span class="string">&quot;06-18&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#二级分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_partition2(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> ,</span><br><span class="line"><span class="keyword">name</span> <span class="keyword">string</span> ,</span><br><span class="line">gender <span class="keyword">string</span> ,</span><br><span class="line">birthday <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">partitioned  <span class="keyword">by</span> (y <span class="keyword">string</span> , m <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;,&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span>  inpath <span class="string">&quot;/root/a.txt&quot;</span>  <span class="keyword">into</span>  <span class="keyword">table</span> tb_partition2 <span class="keyword">partition</span>(y=<span class="string">&#x27;90&#x27;</span>,m=<span class="string">&#x27;01&#x27;</span>);</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span>  inpath <span class="string">&quot;/root/b.txt&quot;</span>  <span class="keyword">into</span>  <span class="keyword">table</span> tb_partition2 <span class="keyword">partition</span>(y=<span class="string">&#x27;90&#x27;</span>,m=<span class="string">&#x27;02&#x27;</span>);</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span>  inpath <span class="string">&quot;/root/c.txt&quot;</span>  <span class="keyword">into</span>  <span class="keyword">table</span> tb_partition2 <span class="keyword">partition</span>(y=<span class="string">&#x27;95&#x27;</span>,m=<span class="string">&#x27;02&#x27;</span>);</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span>  inpath <span class="string">&quot;/root/d.txt&quot;</span>  <span class="keyword">into</span>  <span class="keyword">table</span> tb_partition2 <span class="keyword">partition</span>(y=<span class="string">&#x27;95&#x27;</span>,m=<span class="string">&#x27;03&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_partition2  <span class="keyword">where</span> y=<span class="string">&#x27;90&#x27;</span> <span class="keyword">and</span> m=<span class="string">&#x27;01&#x27;</span>;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>修改表和删除表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#重命名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">RENAME</span> <span class="keyword">TO</span> new_table_name</span><br><span class="line"><span class="comment">#删除表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> dept_partition;</span><br></pre></td></tr></table></figure>



<h2 id="DML-数据操纵语言详解"><a href="#DML-数据操纵语言详解" class="headerlink" title="DML 数据操纵语言详解"></a>DML 数据操纵语言详解</h2><h4 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#向表中装载数据</span><br><span class="line"></span><br><span class="line">#语法</span><br><span class="line">hive&gt; load data [local] inpath &#39;&#x2F;opt&#x2F;module&#x2F;datas&#x2F;student.txt&#39; overwrite | into table student [partition (partcol1&#x3D;val1,…)];</span><br><span class="line">#字段的解释</span><br><span class="line"></span><br><span class="line">load data:表示加载数据</span><br><span class="line">local:表示从本地加载数据到hive表；否则从HDFS加载数据到hive表</span><br><span class="line">inpath:表示加载数据的路径</span><br><span class="line">overwrite:表示覆盖表中已有数据，否则表示追加</span><br><span class="line">into table:表示加载到哪张表</span><br><span class="line">student:表示具体的表</span><br><span class="line">partition:表示上传到指定分区</span><br><span class="line"></span><br><span class="line">#通过查询语句向表中插入数据</span><br><span class="line">insert overwrite table student partition(month&#x3D;&#39;201708&#39;) select id, name from student where month&#x3D;&#39;201709&#39;;</span><br><span class="line"></span><br><span class="line">#查询语句中创建表并加载数据</span><br><span class="line">create table if not exists student3 as select id, name from student;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询结果导入到本地</span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> <span class="keyword">directory</span> <span class="string">&#x27;/opt/module/datas/export/student&#x27;</span> <span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询结果格式化导入本地</span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> <span class="keyword">directory</span> <span class="string">&#x27;/opt/module/datas/export/student1&#x27;</span></span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span>             </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询结果导入到HDFS</span></span><br><span class="line"><span class="keyword">insert</span> overwrite  <span class="keyword">directory</span> <span class="string">&#x27;/opt/module/datas/export/student1&#x27;</span></span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span>             </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="comment">#Truncate只能删除管理表，不能删除外部表中数据</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> student;</span><br></pre></td></tr></table></figure>



<h2 id="DQL-数据查询语言详解"><a href="#DQL-数据查询语言详解" class="headerlink" title="DQL 数据查询语言详解"></a>DQL 数据查询语言详解</h2><h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><ul>
<li><p>常用函数</p>
</li>
<li><p>算术运算符</p>
</li>
<li><p>Limit</p>
</li>
<li><p><strong>空值的处理</strong></p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># count( ) count(*) 区别</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>( ) <span class="keyword">from</span> Company <span class="comment">--包括空值</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> Company <span class="comment">--不包括空值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有count不忽略空值,例如avg函数把空值设置为0</span></span><br><span class="line"> <span class="keyword">avg</span>(<span class="keyword">IsNull</span>(score，<span class="number">0</span>)） <span class="keyword">as</span> ’Average Score‘</span><br></pre></td></tr></table></figure>



<h4 id="where语句"><a href="#where语句" class="headerlink" title="where语句"></a>where语句</h4><ul>
<li><p>between and</p>
</li>
<li><p>in is null   exist</p>
</li>
<li><p>like rlike</p>
<ul>
<li>% 代表零个或多个字符(任意个字符)。</li>
<li>_ 代表一个字符。</li>
<li>rlike支持正则表达式</li>
</ul>
</li>
<li><p>逻辑运算符</p>
</li>
</ul>
<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><ul>
<li><p>group by</p>
</li>
<li><p>having </p>
</li>
</ul>
<h4 id="join连接"><a href="#join连接" class="headerlink" title="join连接"></a>join连接</h4><ul>
<li><p>Hive支持通常的SQL JOIN语句，但是只支持等值连接，不支持非等值连接</p>
</li>
<li><p>join连接谓词中不支持or</p>
</li>
</ul>
<h4 id="基础SQL案例"><a href="#基础SQL案例" class="headerlink" title="基础SQL案例"></a>基础SQL案例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SQL互联网50题hive实现</span></span><br></pre></td></tr></table></figure>



<h4 id="排序语法"><a href="#排序语法" class="headerlink" title="排序语法"></a>排序语法</h4><ul>
<li><p>全局排序(order by )</p>
<ol>
<li><p>Order By：全局排序，一个Reducer</p>
</li>
<li><p>ASC（ascend）: 升序（默认）</p>
</li>
<li><p>DESC（descend）: 降序</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>每个MapReduce内部排序（Sort By）</p>
<ol>
<li><p>set mapreduce.job.reduces=3;(设置reduce数目)</p>
</li>
<li><p>set mapreduce.job.reduces;(查看reduce数目)</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>分区排序（Distribute By）</p>
<ol>
<li><p>类似MR中partition，进行分区，结合sort by使用</p>
</li>
<li><p>Hive要求DISTRIBUTE BY语句要写在SORT BY语句之前</p>
</li>
<li><p>要分配多reduce进行处理，否则无法看到distribute by的效果。</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>Cluster By</p>
<ol>
<li><p>当distribute by和sorts by字段相同时，可以使用cluster by方式。</p>
</li>
<li><p>cluster by除了具有distribute by的功能外还兼具sort by的功能。但是排序只能是升序排序，不能指定排序规则为ASC或者DESC。</p>
</li>
</ol>
</li>
</ul>
<h4 id="分桶与抽样查询"><a href="#分桶与抽样查询" class="headerlink" title="分桶与抽样查询"></a>分桶与抽样查询</h4><ul>
<li><p>概念:</p>
<ol>
<li><p><strong>分区针对的是数据的存储路径；分桶针对的是数据文件,</strong></p>
</li>
<li><p>分区提供一个隔离数据和优化查询的便利方式。不过，并非所有的数据集都可形成合理的分区，特别是之前所提到过的要确定合适的划分大小这个疑虑</p>
</li>
<li><p>分桶对数据的处理比分区更加细粒度化；</p>
</li>
<li><p>分桶和分区两者不干扰，可以把分区表进一步分桶；</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">create table stu_buck(id int, name string)</span><br><span class="line">clustered by(id)</span><br><span class="line">into 4 buckets</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br><span class="line"></span><br><span class="line">set hive.enforce.bucketing &#x3D; true;</span><br><span class="line"></span><br><span class="line">load data local inpath &#39;&#x2F;root&#x2F;e.txt&#39; into table</span><br><span class="line">stu_buck;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>分桶抽样查询</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#示例</span><br><span class="line">select * from stu_buck tablesample(bucket 1 out of 4 on id);</span><br><span class="line"></span><br><span class="line">#含义的说明</span><br><span class="line"></span><br><span class="line">tablesample是抽样语句，语法：TABLESAMPLE(BUCKET x OUT OF y) </span><br><span class="line">y必须是table总bucket数的倍数或者因子,例如:例如，table总共分了4份，当y&#x3D;2时，抽取(4&#x2F;2&#x3D;)2个bucket的数据，当y&#x3D;8时，抽取(4&#x2F;8&#x3D;)1&#x2F;2个bucket的数据。</span><br><span class="line">x表示从哪个bucket开始抽取，如果需要取多个分区，以后的分区号为当前分区号加上y,例如:table总bucket数为4，tablesample(bucket 1 out of 2)，表示总共抽取（4&#x2F;2&#x3D;）2个bucket的数据，抽取第1(x)个和第3(x y)个bucket的数据。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="动态分区和静态分区详解"><a href="#动态分区和静态分区详解" class="headerlink" title="动态分区和静态分区详解"></a>动态分区和静态分区详解</h2><p>首先是要创建静态分区表；然后将表设置为非严格模式；再次创建动态分区表，并加载数据。</p>
<p>加载数据的时候，是按照静态分区的模式，将数据加载到动态分区中去。</p>
<p><strong>注意事项要开启yarn不然报错:org.apache.hadoop.hive.ql.exec.mr.MapRedTask</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#案例</span></span><br><span class="line"><span class="comment">#数据user.txt</span></span><br><span class="line">u001 ZSS 23 M beijing</span><br><span class="line">u002 YMM 33 F nanjing</span><br><span class="line">u003 LSS 43 M beijing</span><br><span class="line">u004 ZY 23 F beijing</span><br><span class="line">u005 ZM 23 M beijing</span><br><span class="line">u006 CL 23 M dongjing</span><br><span class="line">u007 LX 23 F beijing</span><br><span class="line">u008 YZ 23 M beijing</span><br><span class="line">u009 YM 23 F nanjing</span><br><span class="line">u010 XM 23 M beijing</span><br><span class="line">u011 XD 23 F beijing</span><br><span class="line">u012 LH 23 M dongjing</span><br><span class="line"></span><br><span class="line"><span class="comment">#建普通表语句</span></span><br><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span>  <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>  tb_user(</span><br><span class="line">uid <span class="keyword">string</span> ,</span><br><span class="line"><span class="keyword">name</span>  <span class="keyword">string</span> ,</span><br><span class="line">age <span class="built_in">int</span> ,</span><br><span class="line">gender <span class="keyword">string</span> ,</span><br><span class="line">address <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span>  <span class="keyword">terminated</span> <span class="keyword">by</span>  <span class="string">&quot; &quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">##加载数据</span></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span>  inpath  <span class="string">&quot;/root/user.txt&quot;</span>  <span class="keyword">into</span> <span class="keyword">table</span>  tb_user ;</span><br><span class="line"></span><br><span class="line"><span class="comment">##创建目标表</span></span><br><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span>  <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>  tb_p_user(</span><br><span class="line">uid <span class="keyword">string</span> ,</span><br><span class="line"><span class="keyword">name</span>  <span class="keyword">string</span> ,</span><br><span class="line">age <span class="built_in">int</span> ,</span><br><span class="line">gender <span class="keyword">string</span> ,</span><br><span class="line">address <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">partitioned  <span class="keyword">by</span> (addr <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span>  <span class="keyword">terminated</span> <span class="keyword">by</span>  <span class="string">&quot; &quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启动态分区设置</span></span><br><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition=<span class="literal">true</span> ;</span><br><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition.mode= nonstrict;  可以从普通表中导入数据</span><br><span class="line"></span><br><span class="line"><span class="comment">#插入数据(这里是全部插入,也可以插入普通表的部分字段)</span></span><br><span class="line">普通表5个字段</span><br><span class="line">分区表 5个主字段 1 个分区字段</span><br><span class="line">插入数据的时候字段个数类型一致  最后一个字段就是分区字段 </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_p_user <span class="keyword">partition</span>(addr) <span class="keyword">select</span> uid , <span class="keyword">name</span> , age , gender , address,address  <span class="keyword">from</span>  tb_user ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="窗口函数总结"><a href="#窗口函数总结" class="headerlink" title="窗口函数总结"></a>窗口函数总结</h2><h4 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#窗口函数的语法</span></span><br><span class="line"></span><br><span class="line">over关键字用来指定函数执行的窗口范围，若后面括号中什么都不写，则意味着窗口包含满足WHERE条件的所有行，窗口函数基于所有行进行计算；如果不为空，则支持以下4中语法来设置窗口。</span><br><span class="line">①window_name：给窗口指定一个别名。如果SQL中涉及的窗口较多，采用别名可以看起来更清晰易读；</span><br><span class="line">②PARTITION BY 子句：窗口按照哪些字段进行分组，窗口函数在不同的分组上分别执行；</span><br><span class="line">③ORDER BY子句：按照哪些字段进行排序，窗口函数将按照排序后的记录顺序进行编号；</span><br><span class="line">④FRAME子句：FRAME是当前分区的一个子集，子句用来定义子集的规则，通常用来作为滑动窗口使用</span><br></pre></td></tr></table></figure>



<ol>
<li> 偏移量函数:lag lead</li>
</ol>
<p>​           lag(列名,往前的行数,[行数为null时的默认值，不指定为null])，可以计算用户上次购买时间，或者用户下次购买时间。</p>
<p>​           lead(列名,往后的行数,[行数为null时的默认值，不指定为null])</p>
<ol start="2">
<li>first_value 和 last_value</li>
</ol>
<p>​           first_value取分组内排序后，截止到当前行，第一个值<br>​           last_value取分组内排序后，截止到当前行，最后一个值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sql</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line"><span class="keyword">first_value</span>(orderdate) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) <span class="keyword">as</span> time1,</span><br><span class="line"><span class="keyword">last_value</span>(orderdate) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) <span class="keyword">as</span> time2</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">order</span></span><br><span class="line"><span class="comment">#展示</span></span><br><span class="line"><span class="keyword">name</span>    orderdate   <span class="keyword">cost</span>    time1   time2</span><br><span class="line">jack    <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">10</span>  <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span></span><br><span class="line">jack    <span class="number">2015</span><span class="number">-01</span><span class="number">-05</span>  <span class="number">46</span>  <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">2015</span><span class="number">-01</span><span class="number">-05</span></span><br><span class="line">jack    <span class="number">2015</span><span class="number">-01</span><span class="number">-08</span>  <span class="number">55</span>  <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">2015</span><span class="number">-01</span><span class="number">-08</span></span><br><span class="line">jack    <span class="number">2015</span><span class="number">-02</span><span class="number">-03</span>  <span class="number">23</span>  <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">2015</span><span class="number">-02</span><span class="number">-03</span></span><br><span class="line">jack    <span class="number">2015</span><span class="number">-04</span><span class="number">-06</span>  <span class="number">42</span>  <span class="number">2015</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">2015</span><span class="number">-04</span><span class="number">-06</span></span><br><span class="line">mart    <span class="number">2015</span><span class="number">-04</span><span class="number">-08</span>  <span class="number">62</span>  <span class="number">2015</span><span class="number">-04</span><span class="number">-08</span>  <span class="number">2015</span><span class="number">-04</span><span class="number">-08</span></span><br><span class="line">mart    <span class="number">2015</span><span class="number">-04</span><span class="number">-09</span>  <span class="number">68</span>  <span class="number">2015</span><span class="number">-04</span><span class="number">-08</span>  <span class="number">2015</span><span class="number">-04</span><span class="number">-09</span></span><br><span class="line">mart    <span class="number">2015</span><span class="number">-04</span><span class="number">-11</span>  <span class="number">75</span>  <span class="number">2015</span><span class="number">-04</span><span class="number">-08</span>  <span class="number">2015</span><span class="number">-04</span><span class="number">-11</span></span><br><span class="line">mart    <span class="number">2015</span><span class="number">-04</span><span class="number">-13</span>  <span class="number">94</span>  <span class="number">2015</span><span class="number">-04</span><span class="number">-08</span>  <span class="number">2015</span><span class="number">-04</span><span class="number">-13</span></span><br><span class="line">neil    <span class="number">2015</span><span class="number">-05</span><span class="number">-10</span>  <span class="number">12</span>  <span class="number">2015</span><span class="number">-05</span><span class="number">-10</span>  <span class="number">2015</span><span class="number">-05</span><span class="number">-10</span></span><br><span class="line">neil    <span class="number">2015</span><span class="number">-06</span><span class="number">-12</span>  <span class="number">80</span>  <span class="number">2015</span><span class="number">-05</span><span class="number">-10</span>  <span class="number">2015</span><span class="number">-06</span><span class="number">-12</span></span><br><span class="line">tony    <span class="number">2015</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">15</span>  <span class="number">2015</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">2015</span><span class="number">-01</span><span class="number">-02</span></span><br><span class="line">tony    <span class="number">2015</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">29</span>  <span class="number">2015</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">2015</span><span class="number">-01</span><span class="number">-04</span></span><br><span class="line">tony    <span class="number">2015</span><span class="number">-01</span><span class="number">-07</span>  <span class="number">50</span>  <span class="number">2015</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">2015</span><span class="number">-01</span><span class="number">-07</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="序列函数"><a href="#序列函数" class="headerlink" title="序列函数"></a><strong>序列函数</strong></h4><ul>
<li><p>rank():1,2,2,2,5,6</p>
</li>
<li><p>dense_rank():1,2,2,3,4,4,5</p>
</li>
<li><p>row_number():1,2,3,4,5,6</p>
</li>
<li><p>ntile(n):用于将分组数据按照顺序切分成n片，返回当前切片值</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ntile(n) 支持over()</span><br></pre></td></tr></table></figure>



<h4 id="控制窗口大小的使用"><a href="#控制窗口大小的使用" class="headerlink" title="控制窗口大小的使用"></a>控制窗口大小的使用</h4><p><strong>PRECEDING：往前<br>FOLLOWING：往后<br>CURRENT ROW：当前行<br>UNBOUNDED：起点，UNBOUNDED PRECEDING 表示从前面的起点， UNBOUNDED FOLLOWING：表示到后面的终点</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例如</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>() <span class="keyword">as</span> fullagg, <span class="comment">--所有行相加</span></span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span>) <span class="keyword">as</span> fullaggbyname, <span class="comment">--按name分组，组内数据相加</span></span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) <span class="keyword">as</span> fabno, <span class="comment">--按name分组，组内数据累加 </span></span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span>) <span class="keyword">as</span> mw1   <span class="comment">--和fabno一样,由最前面的起点到当前行的聚合 </span></span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span>) <span class="keyword">as</span> mw2,   <span class="comment">--当前行和前面一行做聚合 </span></span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">following</span>) <span class="keyword">as</span> mw3,   <span class="comment">--当前行和前边一行及后面一行 </span></span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">current</span> <span class="keyword">row</span> <span class="keyword">and</span> <span class="keyword">unbounded</span> <span class="keyword">following</span>) <span class="keyword">as</span> mw4  <span class="comment">--当前行及后面所有行 </span></span><br><span class="line"><span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">range</span> <span class="keyword">between</span> <span class="number">2</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="number">2</span> <span class="keyword">following</span>) 窗口范围为当前行的数据幅度减<span class="number">2</span>加<span class="number">2</span>后的范围内的数据求和。</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">order</span>; </span><br></pre></td></tr></table></figure>



<h4 id="SQL习题-窗口函数"><a href="#SQL习题-窗口函数" class="headerlink" title="SQL习题-窗口函数"></a>SQL习题-窗口函数</h4><h5 id="topN案例"><a href="#topN案例" class="headerlink" title="topN案例"></a>topN案例</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SQL</span></span><br><span class="line">有表score</span><br><span class="line">想知道学生成绩排名前几的科目</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">*</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">*,</span><br><span class="line">row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> subject <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) rmp</span><br><span class="line"><span class="keyword">from</span> score</span><br><span class="line">) t</span><br><span class="line"><span class="keyword">where</span> t.rmp&lt;=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h5 id="连续登陆案例"><a href="#连续登陆案例" class="headerlink" title="连续登陆案例"></a>连续登陆案例</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sql</span></span><br><span class="line"><span class="comment">#数据</span></span><br><span class="line">1,2020-01-01</span><br><span class="line">1,2020-01-02</span><br><span class="line">1,2020-01-03</span><br><span class="line">1,2020-01-04</span><br><span class="line">1,2020-01-07</span><br><span class="line">1,2020-01-08</span><br><span class="line">9,2020-01-08</span><br><span class="line">7,2020-01-15</span><br><span class="line">3,2020-01-09</span><br><span class="line">4,2020-01-12</span><br><span class="line">1,2020-01-09</span><br><span class="line">2,2020-02-09</span><br><span class="line">2,2020-02-10</span><br><span class="line">2,2020-02-11</span><br><span class="line">2,2020-02-12</span><br><span class="line">2,2020-02-14</span><br><span class="line">2,2020-02-15</span><br><span class="line">4,2020-01-11</span><br><span class="line">4,2020-01-13</span><br><span class="line">4,2020-01-15</span><br><span class="line"></span><br><span class="line"><span class="comment">#建表与SQL</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sigin1(</span><br><span class="line">userid <span class="built_in">int</span>,</span><br><span class="line">sigindate <span class="keyword">string</span></span><br><span class="line">)<span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span></span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&#x27;/root/user.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> sigin1;</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法一,使用序列函数,date_sub()查询连续登陆天数大于三天的用户(没有去重,假设同一个用户在同一天登陆俩次,分组解决此问题)</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">userid,<span class="keyword">result</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">userid,sigindate,<span class="keyword">date_sub</span>(sigindate,<span class="built_in">number</span>) <span class="keyword">as</span> <span class="keyword">result</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">userid,sigindate,</span><br><span class="line"><span class="keyword">dense_rank</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> userid <span class="keyword">order</span> <span class="keyword">by</span> sigindate) <span class="keyword">as</span> <span class="built_in">number</span></span><br><span class="line"><span class="keyword">from</span> sigin1</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span>  userid,sigindate )t1)t2</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">result</span>,userid</span><br><span class="line"><span class="keyword">having</span>  <span class="keyword">count</span>(<span class="keyword">result</span>) &gt;=<span class="number">3</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> userid;</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二,使用偏移函数,lag函数 偏移3个单位如果  date_sub()日期偏移3相等那么用户登录的天数就是连续3天</span></span><br><span class="line"><span class="comment">#这个方法可以求但是在这个题目中是不行的,因为lag是偏移函数,开始的三个日期前面没有日期,得到的结果偏移为0</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">* ,<span class="keyword">date_sub</span>(sigindate,<span class="number">3</span>) <span class="keyword">as</span> <span class="string">`date`</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">userid,sigindate,lag(sigindate,<span class="number">3</span>,<span class="number">0</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> userid <span class="keyword">order</span> <span class="keyword">by</span> sigindate) <span class="keyword">as</span> <span class="string">`date`</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">userid,sigindate</span><br><span class="line"><span class="keyword">from</span> sigin1</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> userid, sigindate)t1)t2</span><br><span class="line"><span class="keyword">where</span> sigindate <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>  <span class="keyword">and</span> <span class="keyword">date_sub</span>(sigindate,<span class="number">3</span>) = <span class="string">`date`</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="基础SQL案例-1"><a href="#基础SQL案例-1" class="headerlink" title="基础SQL案例"></a>基础SQL案例</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SQL</span></span><br><span class="line"><span class="comment">#测试数据</span></span><br><span class="line">jack,2017-01-01,10</span><br><span class="line">tony,2017-01-02,15</span><br><span class="line">jack,2017-02-03,23</span><br><span class="line">tony,2017-01-04,29</span><br><span class="line">jack,2017-01-05,46</span><br><span class="line">jack,2017-04-06,42</span><br><span class="line">tony,2017-01-07,50</span><br><span class="line">jack,2017-01-08,55</span><br><span class="line">mart,2017-04-08,62</span><br><span class="line">mart,2017-04-09,68</span><br><span class="line">neil,2017-05-10,12</span><br><span class="line">mart,2017-04-11,75</span><br><span class="line">neil,2017-06-12,80</span><br><span class="line">mart,2017-04-13,94</span><br><span class="line"></span><br><span class="line"><span class="comment">#建表与需求</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> business</span><br><span class="line">(</span><br><span class="line"><span class="keyword">name</span> <span class="keyword">string</span>, </span><br><span class="line">orderdate <span class="keyword">string</span>,</span><br><span class="line"><span class="keyword">cost</span> <span class="built_in">int</span></span><br><span class="line">)<span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载数据</span></span><br><span class="line"><span class="keyword">load</span>  <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&quot;/root/business.txt&quot;</span> <span class="keyword">into</span> <span class="keyword">table</span> business;</span><br><span class="line"></span><br><span class="line">1、查询在2017年4月份购买过的顾客及总人数</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">collect_set(<span class="keyword">name</span>) <span class="keyword">as</span> people,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">name</span>) <span class="keyword">as</span> <span class="built_in">number</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">name</span>,<span class="keyword">substr</span>(orderdate,<span class="number">1</span>,<span class="number">7</span>) <span class="keyword">as</span> <span class="keyword">result</span></span><br><span class="line"><span class="keyword">from</span> business</span><br><span class="line"><span class="keyword">where</span>  <span class="keyword">substr</span>(orderdate,<span class="number">1</span>,<span class="number">7</span>) = <span class="string">&#x27;2017-04&#x27;</span></span><br><span class="line">) t1</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t1.result;</span><br><span class="line"></span><br><span class="line">2、查询顾客的月购买总额,查询月购买明细</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">name</span>,total_amount</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">*,</span><br><span class="line">row_number() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> ,<span class="keyword">substr</span>(orderdate,<span class="number">1</span>,<span class="number">7</span>)) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">*,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span>,<span class="keyword">substr</span>(orderdate,<span class="number">1</span>,<span class="number">7</span>) ) total_amount</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">business) t1 )t2</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">rank</span> =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#月购买明细</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">*,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span>,<span class="keyword">substr</span>(orderdate,<span class="number">1</span>,<span class="number">7</span>)) <span class="keyword">as</span> total_amount</span><br><span class="line"><span class="keyword">from</span> business;</span><br><span class="line"></span><br><span class="line">3、查询顾客的购买明细及到目前为止每个顾客购买总金额</span><br><span class="line"><span class="keyword">select</span> *,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span>  <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span> )</span><br><span class="line"><span class="keyword">from</span> business;</span><br><span class="line"></span><br><span class="line">4、查询顾客上次的购买时间<span class="comment">----lag()over()偏移量分析函数的运用</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">*,</span><br><span class="line">lag(orderdate,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) <span class="keyword">as</span> Thelastimetobuy</span><br><span class="line"><span class="keyword">from</span> business;</span><br><span class="line"></span><br><span class="line">5、查询前20%时间的订单信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">name</span>,orderdate,<span class="keyword">cost</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">*,</span><br><span class="line">ntile(<span class="number">5</span>) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span>  orderdate) <span class="keyword">as</span> portion</span><br><span class="line"><span class="keyword">from</span> business) t1</span><br><span class="line"><span class="keyword">where</span> portion =<span class="number">1</span>;</span><br></pre></td></tr></table></figure>





<h2 id="列转行、行转列"><a href="#列转行、行转列" class="headerlink" title="列转行、行转列"></a>列转行、行转列</h2><h4 id="列转行"><a href="#列转行" class="headerlink" title="列转行"></a>列转行</h4><ul>
<li>函数的说明:<ul>
<li><strong>CONCAT(STRING A ,STRINFG B):返回字符串的连接后的结果</strong></li>
<li><strong>CONCAT_WS(separator, str1, str2,…):这是一个特殊的CONCAT(),第一个参数是分隔符</strong></li>
<li><strong>COLLECT_SET():函数只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生array类型字段</strong></li>
<li><strong>CONCAT_WS(SEPARATOR ,COLLECT_SET(column)) ===&gt;GROUP_CONCAT（）函数</strong></li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SQL</span></span><br><span class="line"><span class="comment">#数据</span></span><br><span class="line">孙尚香,白羊座,A</span><br><span class="line">司马懿,射手座,A</span><br><span class="line">吕布,白羊座,B</span><br><span class="line">貂蝉,白羊座,A</span><br><span class="line">许褚,射手座,A</span><br><span class="line"></span><br><span class="line"><span class="comment">#需求</span></span><br><span class="line">射手座,A    司马懿|许褚</span><br><span class="line">白羊座,A    孙尚香|貂蝉</span><br><span class="line">白羊座,B    吕布</span><br><span class="line"></span><br><span class="line"><span class="comment">#建表和SQL</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> person_info(</span><br><span class="line"><span class="keyword">name</span> <span class="keyword">string</span>,</span><br><span class="line">constellation <span class="keyword">string</span>,</span><br><span class="line">blood_type <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&quot;/root/f.txt&quot;</span> <span class="keyword">into</span> <span class="keyword">table</span> person_info;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">//<span class="keyword">concat</span>(constellation,<span class="string">&quot;,&quot;</span>,blood_type),</span><br><span class="line"><span class="keyword">concat_ws</span>(<span class="string">&quot;,&quot;</span>,constellation,blood_type) <span class="keyword">as</span> <span class="keyword">list</span>,</span><br><span class="line"><span class="keyword">concat_ws</span>(<span class="string">&quot;|&quot;</span>,collect_set(<span class="keyword">name</span>)) <span class="keyword">as</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">person_info</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>  constellation,blood_type;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h4><ul>
<li>函数的说明<ul>
<li>EXPLODE(col)：将hive一列中复杂的array或者map结构拆分成多行。</li>
<li>LATERAL VIEW:用于和split, explode等UDTF一起使用，它能够将一列数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合</li>
<li>split(str , 分隔符):返回一个数组</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SQL</span></span><br><span class="line"><span class="comment">#数据</span></span><br><span class="line">《疑犯追踪》 悬疑,动作,科幻,剧情</span><br><span class="line">《Lie to me》	悬疑,警匪,动作,心理,剧情</span><br><span class="line">《战狼2》 战争,动作,灾难</span><br><span class="line"></span><br><span class="line"><span class="comment">#需求</span></span><br><span class="line">《疑犯追踪》      悬疑</span><br><span class="line">《疑犯追踪》      动作</span><br><span class="line">《疑犯追踪》      科幻</span><br><span class="line">《疑犯追踪》      剧情</span><br><span class="line">《Lie to me》   悬疑</span><br><span class="line">《Lie to me》   警匪</span><br><span class="line">《Lie to me》   动作</span><br><span class="line">《Lie to me》   心理</span><br><span class="line">《Lie to me》   剧情</span><br><span class="line">《战狼2》        战争</span><br><span class="line">《战狼2》        动作</span><br><span class="line">《战狼2》        灾难</span><br><span class="line"></span><br><span class="line"><span class="comment">#建表与SQL</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> movie_info(</span><br><span class="line">movie <span class="keyword">string</span>,</span><br><span class="line"><span class="keyword">category</span> <span class="built_in">array</span>&lt;<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;|&quot;</span></span><br><span class="line">collection items <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&quot;/root/g.txt&quot;</span> <span class="keyword">into</span> <span class="keyword">table</span> movie_info;</span><br><span class="line"></span><br><span class="line"><span class="comment">#lateral view explode(category) table_emp相当于一个虚拟表</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">movie</span><br><span class="line"><span class="keyword">result</span></span><br><span class="line"><span class="keyword">from</span> movie_info</span><br><span class="line"><span class="keyword">lateral</span> <span class="keyword">view</span></span><br><span class="line"><span class="keyword">explode</span>(<span class="keyword">category</span>) <span class="keyword">result</span> <span class="keyword">as</span> <span class="keyword">result</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#另一种建表,使用split()切分为数组形式</span></span><br></pre></td></tr></table></figure>



<h2 id="case-when语法、if语法"><a href="#case-when语法、if语法" class="headerlink" title="case when语法、if语法"></a>case when语法、if语法</h2><h4 id="case-when的语法"><a href="#case-when的语法" class="headerlink" title="case when的语法"></a>case when的语法</h4><ul>
<li>CASE 字段  WHEN 值1 THEN 值1 [WHEN 值2 THEN 值2]  [ELSE 值]  END </li>
<li>CASE WHEN 条件表达式 THEN 值1 [WHEN 条件表达式 [and or] 条件表达式THEN 值2]  [ELSE 值]  END</li>
</ul>
<h4 id="if的语法"><a href="#if的语法" class="headerlink" title="if的语法"></a>if的语法</h4><ul>
<li>if( , , )</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SQL</span></span><br><span class="line"><span class="comment">#数据</span></span><br><span class="line">悟空,A,男</span><br><span class="line">娜娜,A,男</span><br><span class="line">宋宋,B,男</span><br><span class="line">凤姐,A,女</span><br><span class="line">热巴,B,女</span><br><span class="line">慧慧,B,女</span><br><span class="line"></span><br><span class="line"><span class="comment">#需求</span></span><br><span class="line">dpt   男      女</span><br><span class="line">A     2       1</span><br><span class="line">B     1       2</span><br><span class="line"></span><br><span class="line"><span class="comment">#建表与SQL(一)</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_case_when_demo(</span><br><span class="line"><span class="keyword">name</span> <span class="keyword">string</span> ,</span><br><span class="line">dname <span class="keyword">string</span> ,</span><br><span class="line">gender <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;,&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&quot;/root/h.txt&quot;</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_case_when_demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">dname,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> gender <span class="keyword">when</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span>  <span class="keyword">nan</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> gender <span class="keyword">when</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span> ) <span class="keyword">as</span> nv</span><br><span class="line"><span class="keyword">from</span> tb_case_when_demo</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>  dname;</span><br><span class="line"></span><br><span class="line"><span class="comment">#SQL(二)</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">dname,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> gender =<span class="string">&#x27;男&#x27;</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="keyword">nan</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> gender = <span class="string">&#x27;女&#x27;</span> <span class="keyword">then</span>  <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span> ) <span class="keyword">as</span> nv</span><br><span class="line"><span class="keyword">from</span> tb_case_when_demo</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dname;</span><br><span class="line"></span><br><span class="line"><span class="comment">#SQL(三)</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">dname,</span><br><span class="line"><span class="keyword">sum</span>(<span class="string">`if`</span>(gender=<span class="string">&#x27;男&#x27;</span>,<span class="number">1</span>,<span class="number">0</span>)) <span class="keyword">as</span> <span class="keyword">nan</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="string">`if`</span>(gender = <span class="string">&#x27;女&#x27;</span>,<span class="number">1</span>,<span class="number">0</span>)) <span class="keyword">as</span> nv</span><br><span class="line"><span class="keyword">from</span> tb_case_when_demo</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>  dname;</span><br><span class="line"></span><br><span class="line"><span class="comment">#SQL练习题</span></span><br><span class="line"><span class="comment">#数据与需求</span></span><br><span class="line">https://blog.csdn.net/qq_37933018/article/details/106878128</span><br><span class="line"><span class="comment">#一个SQL项目</span></span><br><span class="line">https://blog.csdn.net/BeiisBei/article/details/103672522</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="基础SQL案例-2"><a href="#基础SQL案例-2" class="headerlink" title="基础SQL案例"></a>基础SQL案例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SQL</span></span><br><span class="line"><span class="comment">#数据与需求</span></span><br><span class="line">(用户工资组成表,基本工资,基金,提成)</span><br><span class="line">1,2000,3000,1500,1</span><br><span class="line">2,5000,500,1000,2</span><br><span class="line">3,1500,1000,3000,2</span><br><span class="line">4,3000,6000,8000,3</span><br><span class="line">5,1500,2000,1800,1</span><br><span class="line">6,2500,1000,1900,1</span><br><span class="line">(部门表)</span><br><span class="line">1,销售</span><br><span class="line">2,技术</span><br><span class="line">3,行政</span><br><span class="line">(员工信息表)</span><br><span class="line">1,zs,M,28</span><br><span class="line">2,ww,F,36</span><br><span class="line">3,zl,F,48</span><br><span class="line">4,pp,M,44</span><br><span class="line">5,wb,M,32</span><br><span class="line">6,TQ,F,32</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> gz(</span><br><span class="line">uid <span class="built_in">int</span>,</span><br><span class="line">jb <span class="built_in">int</span>,</span><br><span class="line">jj <span class="built_in">int</span>,</span><br><span class="line">tc <span class="built_in">int</span>,</span><br><span class="line">deptno <span class="built_in">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&quot;/root/gz.txt&quot;</span> <span class="keyword">into</span> <span class="keyword">table</span> gz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bm(</span><br><span class="line">deptno <span class="keyword">string</span> ,</span><br><span class="line"><span class="keyword">name</span> <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&quot;/root/bm.txt&quot;</span> <span class="keyword">into</span> <span class="keyword">table</span> bm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> yg(</span><br><span class="line">uid <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="keyword">string</span>,</span><br><span class="line">gender <span class="keyword">string</span>,</span><br><span class="line">age <span class="built_in">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&quot;/root/yg.txt&quot;</span> <span class="keyword">into</span> <span class="keyword">table</span> yg;</span><br><span class="line"></span><br><span class="line">1.求出公司中每个员工的姓名 和 三类收入中最高的那种收入的类型(greatest()函数)</span><br><span class="line"><span class="keyword">with</span> x <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">uid, <span class="keyword">greatest</span>(jb, jj, tc)<span class="keyword">as</span> <span class="string">`max`</span>,</span><br><span class="line">//<span class="keyword">case</span>  <span class="keyword">when</span>   <span class="keyword">greatest</span>(jb, jj, tc) = jb <span class="keyword">then</span> <span class="string">&#x27;jb&#x27;</span>  <span class="keyword">when</span> <span class="keyword">greatest</span>(jb, jj, tc) = jj <span class="keyword">then</span> <span class="string">&#x27;jj&#x27;</span> <span class="keyword">when</span>  <span class="keyword">greatest</span>(jb, jj, tc) = tc <span class="keyword">then</span> <span class="string">&#x27;tc&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;_&#x27;</span> <span class="keyword">end</span>  <span class="keyword">as</span>  gz_category,</span><br><span class="line"><span class="keyword">case</span>   <span class="keyword">greatest</span>(jb, jj, tc)  <span class="keyword">when</span> jb <span class="keyword">then</span> <span class="string">&#x27;jb&#x27;</span> <span class="keyword">when</span>  jj <span class="keyword">then</span> <span class="string">&#x27;jj&#x27;</span> <span class="keyword">when</span> tc <span class="keyword">then</span> <span class="string">&#x27;tc&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;_&#x27;</span> <span class="keyword">end</span>  <span class="keyword">as</span> gz_category1</span><br><span class="line"><span class="keyword">from</span> gz )</span><br><span class="line"><span class="keyword">select</span>  yg.uid,<span class="keyword">max</span>,gz_category1</span><br><span class="line"><span class="keyword">from</span>  yg  <span class="keyword">join</span>  x <span class="keyword">on</span> yg.uid = x.uid;</span><br><span class="line"></span><br><span class="line">2.求出公司中每个岗位的薪资总和</span><br><span class="line"><span class="keyword">with</span> x <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">deptno,</span><br><span class="line"><span class="keyword">sum</span>(jj+tc+jb)  sum_gz</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">gz</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">bm.name,x.sum_gz</span><br><span class="line"><span class="keyword">from</span> bm</span><br><span class="line"><span class="keyword">join</span>  x <span class="keyword">on</span> x.deptno = bm.deptno;</span><br><span class="line"></span><br><span class="line">3.求出公司中不同性别、不同年龄阶段（20-30,31-40,41-50）的员工薪资总和</span><br><span class="line"><span class="keyword">with</span> x <span class="keyword">as</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">uid,</span><br><span class="line">gender,</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">when</span> age&gt;<span class="number">20</span> <span class="keyword">and</span> age &lt;=<span class="number">30</span> <span class="keyword">then</span> <span class="string">&#x27;20-30&#x27;</span> <span class="keyword">when</span> age&gt;<span class="number">30</span> <span class="keyword">and</span> age&lt;=<span class="number">40</span> <span class="keyword">then</span> <span class="string">&#x27;31-40&#x27;</span> <span class="keyword">when</span> age &gt; <span class="number">41</span> <span class="keyword">and</span> age &lt;=<span class="number">50</span> <span class="keyword">then</span> <span class="string">&#x27;41-50&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;_&#x27;</span> <span class="keyword">end</span>  <span class="keyword">as</span> stage</span><br><span class="line"><span class="keyword">from</span> yg )</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">gender,stage,<span class="keyword">sum</span>(jb+jj+tc) <span class="keyword">as</span> <span class="string">`max`</span></span><br><span class="line"><span class="keyword">from</span>  gz  <span class="keyword">join</span>  x  <span class="keyword">on</span> gz.uid = x.uid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>  x.gender,x.stage</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> stage <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure>



<h2 id="内置函数集合"><a href="#内置函数集合" class="headerlink" title="内置函数集合"></a>内置函数集合</h2><h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><ul>
<li><p>substr()</p>
<p><strong>substr(a,b)：从字符串a中，第b位开始取，取右边所有的字符</strong></p>
<p><strong>substr(a,b,c)：从字符串a中，第b为开始取，取c个字符,b可为负数从后面数</strong></p>
</li>
<li><p>填充</p>
<p><strong>lpad（左填充）rpad（右填充）</strong></p>
<p>例如:select lpad(‘abc’,10,’<em>‘); 往左填充10个\</em></p>
</li>
</ul>
<h4 id="集合函数"><a href="#集合函数" class="headerlink" title="集合函数"></a>集合函数</h4><ul>
<li>str_to_map(‘a:1,b:2,c:3’);字符串转map</li>
<li>select size(str_to_map(‘a:1,b:2,c:3’));返回map的元素个数</li>
<li>map_keys(str_to_map(‘a:1,b:2’));返回key</li>
</ul>
<h4 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h4><ul>
<li>cast():select cast(‘2018-06-28’ as date);字符串转日期类型</li>
</ul>
<h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><ul>
<li><strong>unix_timestamp()</strong> 日期转换为当前时间戳</li>
<li>from_unixtime(t1,yyyy-MM-dd HH:mm:ss)时间戳转变为日期格式</li>
<li>from_unixtime(unix_timestamp(date_created),yyyy-MM-dd HH:mm:ss)来规范时间的格式</li>
</ul>
<h2 id="Hive自定义函数详解"><a href="#Hive自定义函数详解" class="headerlink" title="Hive自定义函数详解"></a>Hive自定义函数详解</h2><p>（UDF、UDAF、UDTF）</p>
<h2 id="MACRO-宏-的使用"><a href="#MACRO-宏-的使用" class="headerlink" title="MACRO (宏) 的使用"></a>MACRO (宏) 的使用</h2><h2 id="执行流程分析"><a href="#执行流程分析" class="headerlink" title="执行流程分析"></a>执行流程分析</h2><h2 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h2><h4 id="常用优化策略"><a href="#常用优化策略" class="headerlink" title="常用优化策略"></a>常用优化策略</h4><ul>
<li>减少job数量</li>
<li>数据量较大的情况下，慎用 count(distinct)，group by 容易产生倾斜问题</li>
<li>合并小文件</li>
<li>解决数据倾斜</li>
</ul>
<h4 id="笛卡尔积与MapJoin的使用"><a href="#笛卡尔积与MapJoin的使用" class="headerlink" title="笛卡尔积与MapJoin的使用"></a>笛卡尔积与MapJoin的使用</h4><h4 id="怎么写in、exists"><a href="#怎么写in、exists" class="headerlink" title="怎么写in、exists"></a>怎么写in、exists</h4><ul>
<li>hive 的一个高效替代方案：left semi join</li>
</ul>
<h4 id="小文件的合并"><a href="#小文件的合并" class="headerlink" title="小文件的合并"></a>小文件的合并</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#常用设置</span></span><br><span class="line"><span class="keyword">set</span> hive.merge.mapfiles = <span class="literal">true</span> <span class="comment">##在 map only 的任务结束时合并小文件</span></span><br><span class="line"><span class="keyword">set</span> hive.merge.mapredfiles = <span class="literal">false</span> <span class="comment">## true 时在 MapReduce 的任务结束时合并小文件</span></span><br><span class="line"><span class="keyword">set</span> hive.merge.size.per.task = <span class="number">256</span>*<span class="number">1000</span>*<span class="number">1000</span> <span class="comment">##合并文件的大小</span></span><br><span class="line"><span class="keyword">set</span> mapred.max.split.size=<span class="number">256000000</span>; <span class="comment">##每个 Map 最大分割大小</span></span><br><span class="line"><span class="keyword">set</span> mapred.min.split.size.per.node=<span class="number">1</span>; <span class="comment">##一个节点上 split 的最少值</span></span><br><span class="line"><span class="keyword">set</span> hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat; <span class="comment">##执行 Map 前进行小文件合并</span></span><br></pre></td></tr></table></figure>



<h2 id="解决小文件过多的方案"><a href="#解决小文件过多的方案" class="headerlink" title="解决小文件过多的方案"></a>解决小文件过多的方案</h2><h4 id="产生小文件的来源和影响"><a href="#产生小文件的来源和影响" class="headerlink" title="产生小文件的来源和影响"></a>产生小文件的来源和影响</h4><ul>
<li>来源<ul>
<li>源数据本身有很多小文件</li>
<li>动态分区会产生大量小文件</li>
<li>reduce个数越多, 小文件越多</li>
<li>按分区插入数据的时候会产生大量的小文件, 文件个数 = maptask个数 * 分区数</li>
</ul>
</li>
<li>影响<ul>
<li>从Hive的角度看，小文件会开很多map，一个map开一个JVM去执行，所以这些任务的初始化，启动，执行会浪费大量的资源，严重影响性能。</li>
<li>HDFS存储太多小文件, 会导致namenode元数据特别大, 占用太多内存, 制约了集群的扩展。</li>
</ul>
</li>
</ul>
<h4 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h4><ul>
<li>调参进行合并</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#每个Map最大输入大小(这个值决定了合并后文件的数量)</span></span><br><span class="line"><span class="keyword">set</span> mapred.max.split.size=<span class="number">256000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#一个节点上split的至少的大小(这个值决定了多个DataNode上的文件是否需要合并)</span></span><br><span class="line"><span class="keyword">set</span> mapred.min.split.size.per.node=<span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#一个交换机下split的至少的大小(这个值决定了多个交换机上的文件是否需要合并)</span></span><br><span class="line"><span class="keyword">set</span> mapred.min.split.size.per.rack=<span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行Map前进行小文件合并</span></span><br><span class="line"><span class="keyword">set</span> hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">#===设置map输出和reduce输出进行合并的相关参数：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置map端输出进行合并，默认为true</span></span><br><span class="line"><span class="keyword">set</span> hive.merge.mapfiles = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置reduce端输出进行合并，默认为false</span></span><br><span class="line"><span class="keyword">set</span> hive.merge.mapredfiles = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置合并文件的大小</span></span><br><span class="line"><span class="keyword">set</span> hive.merge.size.per.task = <span class="number">256</span>*<span class="number">1000</span>*<span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当输出文件的平均大小小于该值时，启动一个独立的MapReduce任务进行文件merge。</span></span><br><span class="line"><span class="keyword">set</span> hive.merge.smallfiles.avgsize=<span class="number">16000000</span></span><br></pre></td></tr></table></figure>



<ul>
<li>distribute by rand() 将数据随机分配给 reduce</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置每个reducer处理的大小为5个G</span></span><br><span class="line"><span class="keyword">set</span> hive.exec.reducers.bytes.per.reducer=<span class="number">5120000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用distribute by rand()将数据随机分配给reduce, 避免出现有的文件特别大, 有的文件特别小</span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">partition</span>(dt)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> iteblog_tmp</span><br><span class="line"><span class="keyword">DISTRIBUTE</span> <span class="keyword">BY</span> <span class="keyword">rand</span>();</span><br></pre></td></tr></table></figure>



<ul>
<li> sequencefile 作为表存储格式，不要用 textfile，在一定程度上可以减少小文件</li>
<li>使用hadoop的archive归档</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用来控制归档是否可用</span></span><br><span class="line"><span class="keyword">set</span> hive.archive.enabled=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">#通知Hive在创建归档时是否可以设置父目录</span></span><br><span class="line"><span class="keyword">set</span> hive.archive.har.parentdir.settable=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">#控制需要归档文件的大小</span></span><br><span class="line"><span class="keyword">set</span> har.partfile.size=<span class="number">1099511627776</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用以下命令进行归档</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> srcpart <span class="keyword">ARCHIVE</span> <span class="keyword">PARTITION</span>(ds=<span class="string">&#x27;2020-04-08&#x27;</span>, hr=<span class="string">&#x27;12&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#对已归档的分区恢复为原文件</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> srcpart UNARCHIVE <span class="keyword">PARTITION</span>(ds=<span class="string">&#x27;2020-04-08&#x27;</span>, hr=<span class="string">&#x27;12&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意，归档的分区不能够INSERT OVERWRITE，必须先unarchive</span></span><br></pre></td></tr></table></figure>



<ul>
<li>hadoop自带的三种小文件处理方案</li>
</ul>
<h2 id="电子商务消费行为分析-未找到数据"><a href="#电子商务消费行为分析-未找到数据" class="headerlink" title="电子商务消费行为分析(未找到数据)"></a>电子商务消费行为分析(未找到数据)</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据与需求</span></span><br></pre></td></tr></table></figure>

<h2 id="textfile、sequencefile-和-rcfile"><a href="#textfile、sequencefile-和-rcfile" class="headerlink" title="textfile、sequencefile 和 rcfile"></a>textfile、sequencefile 和 rcfile</h2><table>
<thead>
<tr>
<th align="left"></th>
<th>文件存储编码格式</th>
<th align="left">建表时如何指定</th>
<th align="left">优点弊端</th>
</tr>
</thead>
<tbody><tr>
<td align="left">textfile</td>
<td>文件存储就是正常的文本格式，将表中的数据在hdfs上 以文本的格式存储，下载后可以直接查看，也可以使用cat命令查看</td>
<td align="left">1.无需指定，默认2.显示指定stored as textfile</td>
<td align="left">1. 行存储使用textfile存储文件默认每一行就是一条记录，2.可以使用任意的分隔符进行分割。3.但无压缩，所以造成存储空间大。可结合Gzip、Bzip2、Snappy等使用（系统自动检查，执行查询时自动解压），但使用这种方式，hive不会对数据进行切分，从而无法对数据进行并行操作。3.但无压缩，所以造成存储空间大。可结合Gzip、Bzip2、Snappy等使用（系统自动检查，执行查询时自动解压），但使用这种方式，hive不会对数据进行切分，从而无法对数据进行并行操作。</td>
</tr>
<tr>
<td align="left">sequencefile</td>
<td>在hdfs上将表中的数据以二进制格式编码，并且将数据压缩了，下载数据以后是二进制格式，不可以直接查看，无法可视化。</td>
<td align="left">1.stored as sequecefile</td>
<td align="left">1.sequencefile存储格有压缩，存储空间小，有利于优化磁盘和I/O性能2.同时支持文件切割分片，提供了三种压缩方式：none,record,block（块级别压缩效率跟高）.默认是record(记录)</td>
</tr>
<tr>
<td align="left">rcfile</td>
<td>在hdfs上将表中的数据以二进制格式编码，并且支持压缩。下载后的数据不可以直接可视化。</td>
<td align="left">1.stored as rcfile</td>
<td align="left">1.行列混合的存储格式，基于列存储。</td>
</tr>
</tbody></table>
<h2 id="面试题摘要"><a href="#面试题摘要" class="headerlink" title="面试题摘要"></a>面试题摘要</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SQL</span></span><br><span class="line"><span class="comment">#数据与需求</span></span><br><span class="line">现有这么一批数据，现要求出：  </span><br><span class="line">每个用户截止到每月为止的最大单月访问次数和累计到该月的总访问次数  </span><br><span class="line">三个字段的意思：  </span><br><span class="line">用户名，月份，访问次数 </span><br><span class="line">A,2015-01,5</span><br><span class="line">A,2015-01,15</span><br><span class="line">B,2015-01,5</span><br><span class="line">A,2015-01,8</span><br><span class="line">B,2015-01,25</span><br><span class="line">A,2015-01,5</span><br><span class="line">A,2015-02,4</span><br><span class="line">A,2015-02,6</span><br><span class="line">B,2015-02,10</span><br><span class="line">B,2015-02,5</span><br><span class="line">A,2015-03,16</span><br><span class="line">A,2015-03,22</span><br><span class="line">B,2015-03,23</span><br><span class="line">B,2015-03,10</span><br><span class="line">B,2015-03,11</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> infos(<span class="keyword">name</span> <span class="keyword">string</span>, <span class="built_in">date</span> <span class="keyword">string</span>, ftime <span class="built_in">int</span>) </span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">&quot;/root/j.txt&quot;</span> <span class="keyword">into</span> <span class="keyword">table</span> infos;</span><br><span class="line"></span><br><span class="line"><span class="comment">#sql(窗口写法)</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">name</span>,mydate,</span><br><span class="line"><span class="keyword">max</span>(t1.ints) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> mydate),</span><br><span class="line">t1.ints,</span><br><span class="line"><span class="keyword">sum</span>(ints) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> mydate <span class="keyword">rows</span>  <span class="keyword">between</span>  <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span>  <span class="keyword">current</span> <span class="keyword">row</span> )</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">name</span>,mydate,<span class="keyword">sum</span>(ints) <span class="keyword">as</span> ints</span><br><span class="line"><span class="keyword">from</span> infos1</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>  <span class="keyword">name</span>,mydate) t1;</span><br><span class="line"></span><br><span class="line">sql(考虑使用自连接实现)</span><br><span class="line">//核心where datea &lt;= dateb</span><br><span class="line"><span class="keyword">select</span> nameb, dateb, visitb,</span><br><span class="line"><span class="keyword">max</span>(visita) <span class="keyword">as</span> max_visit,</span><br><span class="line"><span class="keyword">sum</span>(visita) <span class="keyword">as</span> sum_visit</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">a.name <span class="keyword">as</span> namea,</span><br><span class="line">a.mydate <span class="keyword">as</span> datea,</span><br><span class="line">a.visit <span class="keyword">as</span> visita,</span><br><span class="line">b.name <span class="keyword">as</span> nameb,</span><br><span class="line">b.mydate <span class="keyword">as</span> dateb,</span><br><span class="line">b.visit <span class="keyword">as</span> visitb</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">name</span>,mydate,<span class="keyword">sum</span>(ints) <span class="keyword">as</span> visit <span class="keyword">from</span> infos1 <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>,mydate) a <span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">name</span>,mydate,<span class="keyword">sum</span>(ints) <span class="keyword">as</span> visit <span class="keyword">from</span> infos1 <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>,mydate)  b</span><br><span class="line"><span class="keyword">on</span> a.name = b.name</span><br><span class="line"> ) t1</span><br><span class="line"><span class="keyword">where</span> datea &lt;= dateb</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> nameb, dateb, visitb;</span><br></pre></td></tr></table></figure>



<p>//SQL实现dense_rank()排序,sum()的窗口的实现</p>
]]></content>
      <categories>
        <category>The Hadoop Ecosystem</category>
      </categories>
      <tags>
        <tag>Work Systematically</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce实践</title>
    <url>/2020/08/23/MapReduce-API/</url>
    <content><![CDATA[<h1 id="MapReduce-API"><a href="#MapReduce-API" class="headerlink" title="MapReduce API"></a>MapReduce API</h1><p>Mapreduce 是一个分布式运算程序的编程框架，是用户开发“基于 hadoop 的数据分析 应用”的核心框架。Mapreduce 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的 分布式运算程序，并发运行在一个hadoop 集群上</p>
<h2 id="FileInputformatCase"><a href="#FileInputformatCase" class="headerlink" title="FileInputformatCase"></a>FileInputformatCase</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-08</span></span><br><span class="line"><span class="comment"> * Time: 20:29</span></span><br><span class="line"><span class="comment"> * 对FileInputformatCase中TestInputformatCase的简单实现(默认)</span></span><br><span class="line"><span class="comment"> * 案例统计字母出现的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MR_WordCount1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Configuration con;</span><br><span class="line">    <span class="keyword">static</span> IntWritable wordtimes = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> Text text = <span class="keyword">new</span> Text();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;C:\\Users\\hp\\IdeaProjects\\GitHub_Maven\\src\\main\\resources\\a.txt&quot;</span>, <span class="string">&quot;C:\\MapReduce3&quot;</span>&#125;;</span><br><span class="line">        con = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(con, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        job.setMapperClass(Map_MR_WordCount1.class);</span><br><span class="line">        job.setReducerClass(Reduce_MR_WordCount1.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        job.setNumReduceTasks(<span class="number">1</span>);</span><br><span class="line">        System.out.println(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="string">&quot;正确&quot;</span> : <span class="string">&quot;错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map_MR_WordCount1</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (String word : value.toString().split(<span class="string">&quot;\\s+&quot;</span>)) &#123;</span><br><span class="line">                text.set(word);</span><br><span class="line">                context.write(text, wordtimes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce_MR_WordCount1</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key, <span class="keyword">new</span> IntWritable(num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tongyongtao.BigData.MapReduce.FileInputformatCase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapred.lib.CombineTextInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-08</span></span><br><span class="line"><span class="comment"> * Time: 21:02</span></span><br><span class="line"><span class="comment"> * 处理小文件的一个方法 ComnineTextInputformat</span></span><br><span class="line"><span class="comment"> * 案例统计字母出现个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MR_WordCount2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Configuration con;</span><br><span class="line">    <span class="keyword">static</span> IntWritable wordtimes = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> Text text = <span class="keyword">new</span> Text();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;C:\\Users\\hp\\Desktop\\wordcount&quot;</span>, <span class="string">&quot;C:\\MapReduce&quot;</span>&#125;;</span><br><span class="line">        con = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(con, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        job.setMapperClass(MR_WordCount1.Map_MR_WordCount1.class);</span><br><span class="line">        job.setReducerClass(MR_WordCount1.Reduce_MR_WordCount1.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        <span class="comment">//ComnineTextInputformat 方法不设置就就是默认的text</span></span><br><span class="line">        job.setInputFormatClass(CombineTextInputFormat.class);</span><br><span class="line">        <span class="comment">//设置大小</span></span><br><span class="line">        CombineTextInputFormat.setMaxInputSplitSize(job,<span class="number">4192304</span>);</span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        job.setNumReduceTasks(<span class="number">1</span>);</span><br><span class="line">        System.out.println(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="string">&quot;正确&quot;</span> : <span class="string">&quot;错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map_MR_WordCount1</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (String word : value.toString().split(<span class="string">&quot;\\s+&quot;</span>)) &#123;</span><br><span class="line">                text.set(word);</span><br><span class="line">                context.write(text, wordtimes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce_MR_WordCount1</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key, <span class="keyword">new</span> IntWritable(num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tongyongtao.BigData.MapReduce.FileInputformatCase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.KeyValueLineRecordReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.KeyValueTextInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-08</span></span><br><span class="line"><span class="comment"> * Time: 21:49</span></span><br><span class="line"><span class="comment"> * keyvalues形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MR_WordCount3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Configuration con;</span><br><span class="line">    <span class="keyword">static</span> IntWritable wordtimes = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> Text text = <span class="keyword">new</span> Text();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;C:\\Users\\hp\\IdeaProjects\\GitHub_Maven\\src\\main\\resources\\word_keyvalue.txt&quot;</span>, <span class="string">&quot;C:\\MapReduce5&quot;</span>&#125;;</span><br><span class="line">        con = <span class="keyword">new</span> Configuration();</span><br><span class="line">        <span class="comment">//设置</span></span><br><span class="line">        con.set(KeyValueLineRecordReader.KEY_VALUE_SEPARATOR,<span class="string">&quot; &quot;</span>);</span><br><span class="line">        Job job = Job.getInstance(con, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        job.setMapperClass(Map_MR_WordCount1.class);</span><br><span class="line">        job.setReducerClass(Reduce_MR_WordCount1.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        <span class="comment">//设置</span></span><br><span class="line">        job.setInputFormatClass(KeyValueTextInputFormat.class);</span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        job.setNumReduceTasks(<span class="number">1</span>);</span><br><span class="line">        System.out.println(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="string">&quot;正确&quot;</span> : <span class="string">&quot;错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map_MR_WordCount1</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Text key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (String word : value.toString().split(<span class="string">&quot;\\s+&quot;</span>)) &#123;</span><br><span class="line">                text.set(word);</span><br><span class="line">                context.write(key, wordtimes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce_MR_WordCount1</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key, <span class="keyword">new</span> IntWritable(num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tongyongtao.BigData.MapReduce.FileInputformatCase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.NLineInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User:</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-08</span></span><br><span class="line"><span class="comment"> * Time: 22:23</span></span><br><span class="line"><span class="comment"> *  NLineInputFormat 按照行来切片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MR_WordCount4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Configuration con;</span><br><span class="line">    <span class="keyword">static</span> IntWritable wordtimes = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> Text text = <span class="keyword">new</span> Text();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;C:\\Users\\hp\\IdeaProjects\\GitHub_Maven\\src\\main\\resources\\word.nl.txt&quot;</span>, <span class="string">&quot;C:\\MapReduce3&quot;</span>&#125;;</span><br><span class="line">        con = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(con, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//设置  三行一切</span></span><br><span class="line">        NLineInputFormat.setNumLinesPerSplit(job,<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置</span></span><br><span class="line">        job.setInputFormatClass(NLineInputFormat.class);</span><br><span class="line">        job.setMapperClass(MR_WordCount1.Map_MR_WordCount1.class);</span><br><span class="line">        job.setReducerClass(MR_WordCount1.Reduce_MR_WordCount1.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        job.setNumReduceTasks(<span class="number">1</span>);</span><br><span class="line">        System.out.println(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="string">&quot;正确&quot;</span> : <span class="string">&quot;错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map_MR_WordCount1</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (String word : value.toString().split(<span class="string">&quot;\\s+&quot;</span>)) &#123;</span><br><span class="line">                text.set(word);</span><br><span class="line">                context.write(text, wordtimes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce_MR_WordCount1</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key, <span class="keyword">new</span> IntWritable(num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tongyongtao.BigData.MapReduce.FileInputformatCase;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-08</span></span><br><span class="line"><span class="comment"> * Time: 22:31</span></span><br><span class="line"><span class="comment"> * 自定义切片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MR_WordCount5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="CombinerCase"><a href="#CombinerCase" class="headerlink" title="CombinerCase"></a>CombinerCase</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MR_Combiner</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description: </span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-08</span></span><br><span class="line"><span class="comment"> * Time: 10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JoinCase"><a href="#JoinCase" class="headerlink" title="JoinCase"></a>JoinCase</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tongyongtao.BigData.MapReduce.JoinCase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Writable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInput;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutput;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-08</span></span><br><span class="line"><span class="comment"> * Time: 22:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableBean1</span> <span class="keyword">implements</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ID;</span><br><span class="line">    <span class="keyword">private</span> String Pid;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> amount;</span><br><span class="line">    <span class="keyword">private</span> String Pname;</span><br><span class="line">    <span class="keyword">private</span> String Flog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">                <span class="string">&quot;ID=&quot;</span> + ID +</span><br><span class="line">                        <span class="string">&quot; Pid=&quot;</span> + Pid +</span><br><span class="line">                        <span class="string">&quot; amount=&quot;</span> + amount +</span><br><span class="line">                        <span class="string">&quot; Pname=&quot;</span> + Pname +</span><br><span class="line">                        <span class="string">&quot; Flog=&quot;</span> + Flog;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> ID)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ID = ID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPid</span><span class="params">(String pid)</span> </span>&#123;</span><br><span class="line">        Pid = pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAmount</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Pname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPname</span><span class="params">(String pname)</span> </span>&#123;</span><br><span class="line">        Pname = pname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFlog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Flog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlog</span><span class="params">(String flog)</span> </span>&#123;</span><br><span class="line">        Flog = flog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TableBean1</span><span class="params">(<span class="keyword">int</span> ID, String pid, <span class="keyword">int</span> amount, String pname, String flog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ID = ID;</span><br><span class="line">        Pid = pid;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">        Pname = pname;</span><br><span class="line">        Flog = flog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TableBean1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        dataOutput.writeInt(ID);</span><br><span class="line">        dataOutput.writeUTF(Pid);</span><br><span class="line">        dataOutput.writeInt(amount);</span><br><span class="line">        dataOutput.writeUTF(Pname);</span><br><span class="line">        dataOutput.writeUTF(Flog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ID = dataInput.readInt();</span><br><span class="line">        <span class="keyword">this</span>.Pid = dataInput.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.amount = dataInput.readInt();</span><br><span class="line">        <span class="keyword">this</span>.Pname = dataInput.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.Flog = dataInput.readUTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TableBean1(getID(), getPid(), getAmount(), getPname(), getFlog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tongyongtao.BigData.MapReduce.JoinCase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileSplit;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-08</span></span><br><span class="line"><span class="comment"> * Time: 22:32</span></span><br><span class="line"><span class="comment"> * 简单join的实现 两张表  实现在reduce端的join</span></span><br><span class="line"><span class="comment"> * 首先在setup方法中获取文件的名字 比如 order.txt 和 pd.txt</span></span><br><span class="line"><span class="comment"> * key 和 value 的设置,两张表有重合部分作为key 这样排序后在同一个迭代器中</span></span><br><span class="line"><span class="comment"> * 集合遍历取代原来的</span></span><br><span class="line"><span class="comment"> * order.txt  id pid amount</span></span><br><span class="line"><span class="comment"> * pd.txt   pid pname</span></span><br><span class="line"><span class="comment"> * ...这个案例检查了好久 出现如下bug :dataInput和 dataOutput写入读取的顺序不一致,spilt[]的顺序不一致</span></span><br><span class="line"><span class="comment"> * 没有往集合中添加数据........</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MR_Join1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Configuration con;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;C:\\Users\\hp\\IdeaProjects\\GitHub_Maven\\src\\main\\resources\\jointask&quot;</span>, <span class="string">&quot;C:\\MAPREDYCE1&quot;</span>&#125;;</span><br><span class="line">        con = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(con, <span class="string">&quot;MR_Join1&quot;</span>);</span><br><span class="line">        job.setMapperClass(Map_Join1.class);</span><br><span class="line">        job.setReducerClass(Reduce_Join1.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(TableBean1.class);</span><br><span class="line">        job.setOutputKeyClass(TableBean1.class);</span><br><span class="line">        job.setOutputValueClass(NullWritable.class);</span><br><span class="line">        job.setNumReduceTasks(<span class="number">1</span>);</span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        System.out.println(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="string">&quot;zq&quot;</span> : <span class="string">&quot;cw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map_Join1</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">TableBean1</span>&gt; </span>&#123;</span><br><span class="line">        String name = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">//获取读取的文件的名字</span></span><br><span class="line">            FileSplit inputSplit = (FileSplit) context.getInputSplit();</span><br><span class="line">            name = inputSplit.getPath().getName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">//按行切</span></span><br><span class="line">            TableBean1 tableBean = <span class="keyword">new</span> TableBean1();</span><br><span class="line">            Text text = <span class="keyword">new</span> Text();</span><br><span class="line">            String[] split = value.toString().split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;order&quot;</span>)) &#123;</span><br><span class="line">                tableBean.setID(Integer.parseInt(split[<span class="number">0</span>]));</span><br><span class="line">                tableBean.setPid(split[<span class="number">1</span>]);</span><br><span class="line">                tableBean.setAmount(Integer.parseInt(split[<span class="number">2</span>]));</span><br><span class="line">                tableBean.setPname(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                tableBean.setFlog(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">                text.set(split[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tableBean.setID(<span class="number">0</span>);</span><br><span class="line">                tableBean.setPid(split[<span class="number">0</span>]);</span><br><span class="line">                tableBean.setAmount(<span class="number">0</span>);</span><br><span class="line">                tableBean.setPname(split[<span class="number">1</span>]);</span><br><span class="line">                tableBean.setFlog(<span class="string">&quot;pd&quot;</span>);</span><br><span class="line">                text.set(split[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(text, tableBean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce_Join1</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">TableBean1</span>, <span class="title">TableBean1</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;TableBean1&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">//存放订单表</span></span><br><span class="line">            List&lt;TableBean1&gt; tableBean1s = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//存放pd表</span></span><br><span class="line">            TableBean1 tableBeanPD = <span class="keyword">new</span> TableBean1();</span><br><span class="line">            <span class="keyword">for</span> (TableBean1 value : values) &#123;</span><br><span class="line">                TableBean1 clone = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;order&quot;</span>.equals(value.getFlog())) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        clone = (TableBean1) value.clone();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    tableBean1s.add(clone);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        tableBeanPD = (TableBean1) value.clone();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (TableBean1 tableBean1 : tableBean1s) &#123;</span><br><span class="line">                tableBean1.setPid(tableBeanPD.getPname());</span><br><span class="line">                context.write(tableBean1, NullWritable.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="PartitionAndGroupingCase"><a href="#PartitionAndGroupingCase" class="headerlink" title="PartitionAndGroupingCase"></a>PartitionAndGroupingCase</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tongyongtao.BigData.MapReduce.OutputformatCase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Writable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInput;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutput;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HbaseBean1</span> <span class="keyword">implements</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String movie;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> rate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HbaseBean1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMovie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> movie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovie</span><span class="params">(String movie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movie = movie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRate</span><span class="params">(<span class="keyword">double</span> rate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rate = rate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeStamp</span><span class="params">(<span class="keyword">long</span> timeStamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeStamp = timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HbaseBean1</span><span class="params">(String movie, <span class="keyword">double</span> rate, <span class="keyword">long</span> timeStamp, String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movie = movie;</span><br><span class="line">        <span class="keyword">this</span>.rate = rate;</span><br><span class="line">        <span class="keyword">this</span>.timeStamp = timeStamp;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Movie&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;movie=&#x27;&quot;</span> + movie + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, rate=&quot;</span> + rate +</span><br><span class="line">                <span class="string">&quot;, timeStamp=&quot;</span> + timeStamp +</span><br><span class="line">                <span class="string">&quot;, uid=&#x27;&quot;</span> + uid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        dataOutput.writeUTF(movie);</span><br><span class="line">        dataOutput.writeDouble(rate);</span><br><span class="line">        dataOutput.writeLong(timeStamp);</span><br><span class="line">        dataOutput.writeUTF(uid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movie = dataInput.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.rate = dataInput.readDouble();</span><br><span class="line">        <span class="keyword">this</span>.timeStamp = dataInput.readLong();</span><br><span class="line">        <span class="keyword">this</span>.uid = dataInput.readUTF();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tongyongtao.BigData.MapReduce.OutputformatCase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Scan;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableReducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-12</span></span><br><span class="line"><span class="comment"> * Time: 22:19</span></span><br><span class="line"><span class="comment"> * Hbase与MR的交互</span></span><br><span class="line"><span class="comment"> * 案例:电影案例 分析:设计rowkey  ImmutableBytesWritable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MR_Hbase1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;C:\\Users\\hp\\IdeaProjects\\GitHub_Maven\\src\\main\\resources\\hbase.json&quot;</span>&#125;;</span><br><span class="line">        Configuration con = HBaseConfiguration.create();</span><br><span class="line">        con.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="string">&quot;linux03,linux04,linux05&quot;</span>);</span><br><span class="line">        Job job = Job.getInstance(con, <span class="string">&quot;MR_Hbase&quot;</span>);</span><br><span class="line">        job.setMapperClass(MAP_Hbase1.class);</span><br><span class="line">        job.setReducerClass(Reduce_Hbase1.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(HbaseBean1.class);</span><br><span class="line">        <span class="comment">// 穿件扫描对象用来扫描源hbase中的所有的数据</span></span><br><span class="line">        Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">        <span class="comment">// 接收的扫描的数据的行数</span></span><br><span class="line">        scan.setCaching(<span class="number">200</span>);</span><br><span class="line">        scan.setCacheBlocks(<span class="keyword">false</span>);</span><br><span class="line">        job.setJarByClass(HbaseBean1.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入数据的路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// 插入数据的表要存在</span></span><br><span class="line">        TableMapReduceUtil.initTableReducerJob(<span class="string">&quot;movie1&quot;</span>, Reduce_Hbase1.class, job);</span><br><span class="line">        System.out.println(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="string">&quot;zq&quot;</span> : <span class="string">&quot;cw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MAP_Hbase1</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">HbaseBean1</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">static</span>  Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">                    <span class="comment">//电影名字和时间龊构成一个rowkey</span></span><br><span class="line">            HbaseBean1 hbaseBean = <span class="keyword">null</span>;</span><br><span class="line">            Text text = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                hbaseBean = gson.fromJson(value.toString(), HbaseBean1.class);</span><br><span class="line">                String movie = StringUtils.leftPad(hbaseBean.getMovie(), <span class="number">4</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                String movieStamp = StringUtils.leftPad( String.valueOf(hbaseBean.getTimeStamp()),<span class="number">9</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                text = <span class="keyword">new</span> Text();</span><br><span class="line">                text.set(movie+<span class="string">&quot;_&quot;</span>+movieStamp);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            context.write(text,hbaseBean);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce_Hbase1</span> <span class="keyword">extends</span> <span class="title">TableReducer</span>&lt;<span class="title">Text</span>, <span class="title">HbaseBean1</span>, <span class="title">ImmutableBytesWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;HbaseBean1&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">//key是rowkey values,迭代器只存储了一个</span></span><br><span class="line">            Put put = <span class="keyword">new</span> Put(key.toString().getBytes());</span><br><span class="line">            <span class="keyword">for</span> (HbaseBean1 value : values) &#123;</span><br><span class="line">                put.addColumn(<span class="string">&quot;cf&quot;</span>.getBytes(),<span class="string">&quot;moviename&quot;</span>.getBytes(),value.getMovie().getBytes());</span><br><span class="line">                put.addColumn(<span class="string">&quot;cf&quot;</span>.getBytes(),<span class="string">&quot;movierate&quot;</span>.getBytes(),String.valueOf(value.getRate()).getBytes());</span><br><span class="line">                put.addColumn(<span class="string">&quot;cf&quot;</span>.getBytes(),<span class="string">&quot;moviestamp&quot;</span>.getBytes(),String.valueOf(value.getTimeStamp()).getBytes());</span><br><span class="line">                put.addColumn(<span class="string">&quot;cf&quot;</span>.getBytes(),<span class="string">&quot;movieuid&quot;</span>.getBytes(),value.getUid().getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(<span class="keyword">null</span>,put);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="OutputformatCase"><a href="#OutputformatCase" class="headerlink" title="OutputformatCase"></a>OutputformatCase</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tongyongtao.BigData.MapReduce.PartitionAndGrouping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.WritableComparable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInput;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutput;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-08</span></span><br><span class="line"><span class="comment"> * Time: 14:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> <span class="keyword">implements</span> <span class="title">WritableComparable</span>&lt;<span class="title">Movie</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String movie;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> rate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMovie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> movie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovie</span><span class="params">(String movie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movie = movie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRate</span><span class="params">(<span class="keyword">double</span> rate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rate = rate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeStamp</span><span class="params">(<span class="keyword">long</span> timeStamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeStamp = timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">(String movie, <span class="keyword">double</span> rate, <span class="keyword">long</span> timeStamp, String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movie = movie;</span><br><span class="line">        <span class="keyword">this</span>.rate = rate;</span><br><span class="line">        <span class="keyword">this</span>.timeStamp = timeStamp;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Movie&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;movie=&#x27;&quot;</span> + movie + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, rate=&quot;</span> + rate +</span><br><span class="line">                <span class="string">&quot;, timeStamp=&quot;</span> + timeStamp +</span><br><span class="line">                <span class="string">&quot;, uid=&#x27;&quot;</span> + uid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Movie movie)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重写排序规则  用户名字相同按rate排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.uid.equals(movie.uid) ? Double.compare(movie.rate, <span class="keyword">this</span>.rate) : <span class="keyword">this</span>.uid.compareTo(movie.uid);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        dataOutput.writeUTF(movie);</span><br><span class="line">        dataOutput.writeDouble(rate);</span><br><span class="line">        dataOutput.writeLong(timeStamp);</span><br><span class="line">        dataOutput.writeUTF(uid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movie = dataInput.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.rate = dataInput.readDouble();</span><br><span class="line">        <span class="keyword">this</span>.timeStamp = dataInput.readLong();</span><br><span class="line">        <span class="keyword">this</span>.uid = dataInput.readUTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tongyongtao.BigData.MapReduce.PartitionAndGrouping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.WritableComparable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInput;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutput;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-08</span></span><br><span class="line"><span class="comment"> * Time: 16:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie1</span> <span class="keyword">implements</span> <span class="title">WritableComparable</span>&lt;<span class="title">Movie1</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String movie;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> rate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Movie_TOPN&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;movie=&#x27;&quot;</span> + movie + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, rate=&quot;</span> + rate +</span><br><span class="line">                <span class="string">&quot;, timeStamp=&quot;</span> + timeStamp +</span><br><span class="line">                <span class="string">&quot;, uid=&#x27;&quot;</span> + uid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Movie1</span><span class="params">(String movie, <span class="keyword">double</span> rate, <span class="keyword">long</span> timeStamp, String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movie = movie;</span><br><span class="line">        <span class="keyword">this</span>.rate = rate;</span><br><span class="line">        <span class="keyword">this</span>.timeStamp = timeStamp;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMovie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> movie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovie</span><span class="params">(String movie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movie = movie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRate</span><span class="params">(<span class="keyword">double</span> rate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rate = rate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeStamp</span><span class="params">(<span class="keyword">long</span> timeStamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeStamp = timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Movie1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        dataOutput.writeUTF(movie);</span><br><span class="line">        dataOutput.writeDouble(rate);</span><br><span class="line">        dataOutput.writeLong(timeStamp);</span><br><span class="line">        dataOutput.writeUTF(uid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movie = dataInput.readUTF();</span><br><span class="line">        <span class="keyword">this</span>.rate = dataInput.readDouble();</span><br><span class="line">        <span class="keyword">this</span>.timeStamp = dataInput.readLong();</span><br><span class="line">        <span class="keyword">this</span>.uid = dataInput.readUTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Movie1 movie1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.movie.equals(movie1.movie) ? Double.compare(movie1.rate, <span class="keyword">this</span>.rate) : <span class="keyword">this</span>.movie.compareTo(movie1.movie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>   <span class="keyword">new</span> Movie1(getMovie(),getRate(),getTimeStamp(),getUid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tongyongtao.BigData.MapReduce.PartitionAndGrouping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User:tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-08</span></span><br><span class="line"><span class="comment"> * Time: 10:52</span></span><br><span class="line"><span class="comment"> * 重写分区分组方法</span></span><br><span class="line"><span class="comment"> * 案例:从众多的电影评论中获取每个用户评分排名全三的电影,按电影名排序,电影名相同采用评分排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MR_PartitionAndGroup</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Configuration con;</span><br><span class="line">    <span class="keyword">static</span> Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;C:\\Users\\hp\\IdeaProjects\\GitHub_Maven\\src\\main\\resources\\test.json&quot;</span>, <span class="string">&quot;C:\\MapReduce&quot;</span>&#125;;</span><br><span class="line">        con = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(con, <span class="string">&quot;MR_PartitionAndGroup&quot;</span>);</span><br><span class="line">        <span class="comment">//设置来源</span></span><br><span class="line">        job.setMapperClass(Map_PartitionAndGroup.class);</span><br><span class="line">        job.setReducerClass(Reduce_PartitionAndGroup.class);</span><br><span class="line">        <span class="comment">//设置输入 输出类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Movie.class);</span><br><span class="line">        job.setMapOutputValueClass(NullWritable.class);</span><br><span class="line">        job.setOutputKeyClass(Movie.class);</span><br><span class="line">        job.setOutputValueClass(NullWritable.class);</span><br><span class="line">        <span class="comment">//设置分区标准</span></span><br><span class="line">        job.setPartitionerClass(MyPartion.class);</span><br><span class="line">        <span class="comment">//设置分组标准</span></span><br><span class="line">        job.setGroupingComparatorClass(MyComparator.class);</span><br><span class="line">        <span class="comment">//设置数据 输入 输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        <span class="comment">//设置reduce的个数</span></span><br><span class="line">        job.setNumReduceTasks(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        System.out.println(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map_PartitionAndGroup</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Movie</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Movie movie = gson.fromJson(value.toString(), Movie.class);</span><br><span class="line">                context.write(movie, NullWritable.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//捕捉异常,不处理异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce_PartitionAndGroup</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Movie</span>, <span class="title">NullWritable</span>, <span class="title">Movie</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Movie key, Iterable&lt;NullWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (NullWritable value : values) &#123;</span><br><span class="line">                context.write(key, NullWritable.get());</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写分区方法,按uid分区</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPartion</span> <span class="keyword">extends</span> <span class="title">Partitioner</span>&lt;<span class="title">Movie</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(Movie movie, NullWritable nullWritable, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//按原码来,其实可自定义</span></span><br><span class="line">            <span class="keyword">return</span> (movie.getUid().hashCode() &amp; Integer.MAX_VALUE) % i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写分组方法 按uid来排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">extends</span> <span class="title">WritableComparator</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(Movie.class, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(WritableComparable a, WritableComparable b)</span> </span>&#123;</span><br><span class="line">            Movie A = (Movie) a;</span><br><span class="line">            Movie B = (Movie) b;</span><br><span class="line">            <span class="keyword">return</span> A.getUid().compareTo(B.getUid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tongyongtao.BigData.MapReduce.PartitionAndGrouping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.JsonSyntaxException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Partitioner;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: tongyongtao</span></span><br><span class="line"><span class="comment"> * Date: 2020-10-08</span></span><br><span class="line"><span class="comment"> * Time: 16:30</span></span><br><span class="line"><span class="comment"> * 使用set方法在处理reduce之后的工作</span></span><br><span class="line"><span class="comment"> * 案例:获取电影评论数排名前10的电影</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MR_PartitionAndGroup1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Configuration con;</span><br><span class="line">    <span class="keyword">static</span> Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        args = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;C:\\Users\\hp\\IdeaProjects\\GitHub_Maven\\src\\main\\resources\\test.json&quot;</span>, <span class="string">&quot;C:\\MapReduce2&quot;</span>&#125;;</span><br><span class="line">        con = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(con, <span class="string">&quot;MR_PartitionAndGroup1&quot;</span>);</span><br><span class="line">        job.setMapperClass(Map_PartitionAndGroup1.class);</span><br><span class="line">        job.setReducerClass(Reduce_PartitionAndGroup1.class);</span><br><span class="line">        job.setMapOutputKeyClass(Movie1.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        job.setOutputKeyClass(Movie1.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        job.setPartitionerClass(MyPartion.class);</span><br><span class="line">        job.setGroupingComparatorClass(MyComparator.class);</span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        <span class="comment">//设置reduce数量最好为1</span></span><br><span class="line">        job.setNumReduceTasks(<span class="number">2</span>);</span><br><span class="line">        System.out.println(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map_PartitionAndGroup1</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Movie1</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//  IntWritable intWritable = new IntWritable(1);</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Movie1 movie = gson.fromJson(value.toString(), Movie1.class);</span><br><span class="line">                context.write(movie, <span class="keyword">new</span> IntWritable(<span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Movie1, Integer&gt; movie_topn = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce_PartitionAndGroup1</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Movie1</span>, <span class="title">IntWritable</span>, <span class="title">Movie1</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Movie1 key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">//reducetask拉取maptask端 聚合排序每一组相同的key在一个迭代器中</span></span><br><span class="line">            <span class="comment">//这里注意迭代器只有一个对象,采用赋值或者克隆的方法</span></span><br><span class="line">            <span class="comment">// BeanUtils.copyProperties();同样也可</span></span><br><span class="line">            Movie1 movie = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                movie = (Movie1) key.clone();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// context.write(key,new IntWritable(sum));</span></span><br><span class="line">            movie_topn.put(movie, sum);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">//set方法最终执行 有且执行一次,采取构建一个集合存储</span></span><br><span class="line">            <span class="comment">//hashmap集合中存储 key是movie 值是数量  进行排序取值</span></span><br><span class="line">            List&lt;Map.Entry&lt;Movie1, Integer&gt;&gt; TopNmovies = <span class="keyword">new</span> ArrayList&lt;&gt;(movie_topn.entrySet());</span><br><span class="line">            TopNmovies.sort((t1, t2) -&gt; Integer.compare(t2.getValue(), t1.getValue()));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.min(<span class="number">3</span>, TopNmovies.size()); i++) &#123;</span><br><span class="line">                context.write(TopNmovies.get(i).getKey(), <span class="keyword">new</span> IntWritable(TopNmovies.get(i).getValue()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按movie来分区</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPartion</span> <span class="keyword">extends</span> <span class="title">Partitioner</span>&lt;<span class="title">Movie1</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(Movie1 movie_topn, IntWritable intWritable, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (movie_topn.getMovie().hashCode() &amp; Integer.MAX_VALUE) % i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按movie来排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">extends</span> <span class="title">WritableComparator</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(Movie1.class, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(WritableComparable a, WritableComparable b)</span> </span>&#123;</span><br><span class="line">            Movie1 A = (Movie1) a;</span><br><span class="line">            Movie1 B = (Movie1) b;</span><br><span class="line">            <span class="keyword">return</span> A.getMovie().compareTo(B.getMovie());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>The Hadoop Ecosystem</category>
      </categories>
      <tags>
        <tag>Work Systematically</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/10/20/Sort/</url>
    <content><![CDATA[<h2 id="内排"><a href="#内排" class="headerlink" title="内排"></a>内排</h2><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quicksort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// “挖坑填数+分治</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">55</span>, <span class="number">12</span>, <span class="number">33</span>,<span class="number">12</span>,<span class="number">44</span>,<span class="number">56</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">88</span>&#125;;</span><br><span class="line">        Quicksort1(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        Quicksort2(nums1, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">        System.out.println(Arrays.toString(nums1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种写法 没有优化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quicksort1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> stop)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代表索引</span></span><br><span class="line">        <span class="keyword">if</span> (start&gt;stop) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = stop;</span><br><span class="line">        <span class="comment">//优化方法一:基点的随机</span></span><br><span class="line">        <span class="keyword">int</span> index = start + (<span class="keyword">int</span>)(Math.random()*(stop-start+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span>  tmp = nums[index];</span><br><span class="line">        <span class="comment">//优化方法二:基点为中间数</span></span><br><span class="line">       <span class="comment">// int tmp = nums[start +(stop-start) &gt;&gt; 1];</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; tmp &lt; nums[j])</span><br><span class="line">                j--;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; tmp &gt;= nums[i])</span><br><span class="line">                i++;</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* nums[start] = nums[start] ^ nums[stop];</span></span><br><span class="line"><span class="comment">            nums[stop] = nums[start] ^ nums[stop];</span></span><br><span class="line"><span class="comment">            nums[start] = nums[start] ^ nums[stop];*/</span></span><br><span class="line">        &#125;</span><br><span class="line">         nums[i] = tmp;</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line"></span><br><span class="line">        Quicksort1(nums, start, i - <span class="number">1</span>);</span><br><span class="line">        Quicksort1(nums, i + <span class="number">1</span>, stop);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quicksort2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[begin]; <span class="comment">//将区间的第一个数作为基准数</span></span><br><span class="line">            <span class="keyword">int</span> i = begin; <span class="comment">//从左到右进行查找时的“指针”，指示当前左位置</span></span><br><span class="line">            <span class="keyword">int</span> j = end; <span class="comment">//从右到左进行查找时的“指针”，指示当前右位置</span></span><br><span class="line">            <span class="comment">//不重复遍历</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="comment">//当右边的数大于基准数时，略过，继续向左查找</span></span><br><span class="line">                <span class="comment">//不满足条件时跳出循环，此时的j对应的元素是小于基准元素的</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; temp)</span><br><span class="line">                    j--;</span><br><span class="line">                <span class="comment">//将右边小于等于基准元素的数填入右边相应位置</span></span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                <span class="comment">//当左边的数小于等于基准数时，略过，继续向右查找</span></span><br><span class="line">                <span class="comment">//(重复的基准元素集合到左区间)</span></span><br><span class="line">                <span class="comment">//不满足条件时跳出循环，此时的i对应的元素是大于等于基准元素的</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= temp)</span><br><span class="line">                    i++;</span><br><span class="line">                <span class="comment">//将左边大于基准元素的数填入左边相应位置</span></span><br><span class="line">                arr[j] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将基准元素填入相应位置</span></span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            <span class="comment">//此时的i即为基准元素的位置</span></span><br><span class="line">            <span class="comment">//对基准元素的左边子区间进行相似的快速排序</span></span><br><span class="line">            Quicksort2(arr, begin, i - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//对基准元素的右边子区间进行相似的快速排序</span></span><br><span class="line">            Quicksort2(arr, i + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果区间只有一个数，则返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment">     * Description:</span></span><br><span class="line"><span class="comment">     * User:</span></span><br><span class="line"><span class="comment">     * Date: 2020-12-29</span></span><br><span class="line"><span class="comment">     * Time: 23:08</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分解与合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//向左分解</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右分解</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            <span class="comment">//栈</span></span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并的方法</span></span><br><span class="line">    <span class="comment">//mid为中间的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">//j是第二个数组的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//t 为temp的索引</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="comment">//这里一定要加 + ?</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把左右边剩余的数据全部填充到临时的数组中</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//并不是每次都拷贝....这是一个难点</span></span><br><span class="line">        <span class="comment">//把temp数组的元素拷贝到arr数组</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> templeft = left;</span><br><span class="line">        System.out.println(templeft + <span class="string">&quot;  &quot;</span> + right);</span><br><span class="line">        <span class="keyword">while</span> (templeft &lt;= right) &#123;</span><br><span class="line"></span><br><span class="line">            arr[templeft] = temp[t];</span><br><span class="line">            templeft += <span class="number">1</span>;</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">2</span>, <span class="number">67</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//获取最大的数,并且求取位数</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; i) &#123;</span><br><span class="line">                max = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line">        sort(arr, len);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义桶的大小</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="comment">//定义一个计数器来统计桶中数据的多少</span></span><br><span class="line">        <span class="keyword">int</span>[] bucketElentCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//例如 bucketElentCount[0] = ? 为桶 0 的数据的多少,用来表示数据的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//把arr中的数据放入到桶中</span></span><br><span class="line">        <span class="comment">//这是对个位的处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环一次处理个位 十位 百位 ......</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>, n = <span class="number">1</span>; i1 &lt; len; i1++, n *= <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">                <span class="comment">//表示个位</span></span><br><span class="line">                <span class="comment">// int count = (i / 1) % 10;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//表示十 百.....</span></span><br><span class="line">                <span class="keyword">int</span> count = (i / n) % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//bucketElentCount[count]用来统计桶的数据的多少</span></span><br><span class="line">                bucket[count][bucketElentCount[count]] = i;</span><br><span class="line">                <span class="comment">//这个桶的计数加一</span></span><br><span class="line">                bucketElentCount[count] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把桶的数据拷贝到arr数组中,完成个位数的排序</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucket.length; k++) &#123;</span><br><span class="line">                <span class="comment">//遍历桶</span></span><br><span class="line">                <span class="comment">//某个桶有数据才把数据放置到arr数组中</span></span><br><span class="line">                <span class="comment">//桶里的数据仍然是存在的</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这里为什么是0 ,为什么不能是bucket?因为bucket中数据没有清空</span></span><br><span class="line">                <span class="keyword">if</span> (bucketElentCount[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketElentCount[k]; j++) &#123;</span><br><span class="line">                        arr[index] = bucket[k][j];</span><br><span class="line">                        index += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把数据放置到arr之后,把计数器清0,重新开始计数</span></span><br><span class="line">                bucketElentCount[k] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a>堆排</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="外排"><a href="#外排" class="headerlink" title="外排"></a>外排</h2>]]></content>
      <categories>
        <category>Computer engineering</category>
        <category>Arithmetic</category>
      </categories>
      <tags>
        <tag>Reading Books</tag>
        <tag>Sorting and Searching Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper数据一致性</title>
    <url>/2021/01/03/Zookeeper-Consistency/</url>
    <content><![CDATA[<p>在分布式的环境中,存在多个值,需要从中选定出一个值,达成共识</p>
<h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><h5 id="Prepare-阶段"><a href="#Prepare-阶段" class="headerlink" title="Prepare 阶段"></a>Prepare 阶段</h5><p>proposer 在提出议案 N 之前,N 是该议案的编号,需要向至少多数的 acceptor 发送 Prepare（N）请求</p>
<p>acceptor 收到 Prepare（N）请求后</p>
<ol>
<li>如果之前已经接受了其他议案，那么返回接受过的议案。</li>
<li>如果之前收到过Prepare（M）请求,并且 M &gt; N,那么可以忽略此次请求,也可以返回一个错误</li>
<li>如果之前收到过Prepare（M）请求,并且 M &lt; N,那么 acceptor 会保证以后不会响应议案编号小于 N 的任何请求,并且返回成功响应</li>
</ol>
<h5 id="Accept-阶段"><a href="#Accept-阶段" class="headerlink" title="Accept 阶段"></a>Accept 阶段</h5><p>proposer 在收到多数 acceptor 的成功响应后,,如果这些acceptor中有返回议案,那么就从中选出那个编号最大的议案的值,作为接下来要提</p>
<p>交的.如果没有返回议案,那么将本身的议案作为提交议案</p>
<p>在确定好提交议案后,proposer 会向至少多数的 acceptor 发起 ACCEPT 请求,提交议案.注意下这里的多数 acceptor 可以不和 prepare 阶</p>
<p>段的多数 acceptor 相同</p>
<p>acceptor 当收到 ACCEPT 请求后,会检查议案编号.因为acceptor 在 prepare 阶段,已经承诺过不会议案编号小于 N 的请求,如果 ACCEPT </p>
<p>请求的议案编号小于 N,那么就会拒绝接受此议案.否则,就会接受该议案</p>
<p>当 proposer 收到多数 acceptor 的成功接收议案的响应后,就会认为该议案被选定了</p>
<h5 id="Learn-阶段"><a href="#Learn-阶段" class="headerlink" title="Learn 阶段"></a>Learn 阶段</h5><p>每当 acceptor 接受了一个议案,就会立即通知 learner。learner 会记录每个 acceptor 接收的议案,如果一个议案被多数 acceptor 接受了</p>
<p>那么就决定选定该议案.(假设有两个 proposer , proposer 2的议案被接收但是 proposer 1 不能保证 proposer 2 能够正常完成提交议</p>
<p>案,因为 proposer 2 有可能中途会挂掉,所以 proposer 1 只能继续提交议案,直到确认有一个议案被选定)</p>
<p>每个议案的编号都是唯一的,但是存在着多个 proposer,如何能保证它们提出的议案编号都不相同</p>
<p>质数算法：每个 proposer 对应着唯一的质数,每个新增议案,就是该质数的倍数.比如有两个 proposer 对应着 2,3 两个质数,第一个 </p>
<p>proposer 提出第 i 个议案时,它的编号时 2 * i </p>
<p>等差算法：假设有 n 个 proposer,那么第 m 个 proposer第 i 次新增的议案编号是 m + i * n </p>
<h2 id="Zab"><a href="#Zab" class="headerlink" title="Zab"></a>Zab</h2><p>Zab 协议保证了集群在任何时刻,要么只有一个 leader,要么没有 leader.这两种情况称为广播模式和恢复模式：</p>
<ol>
<li>处于广播模式的集群,能够正常对外提供服务,客户端可以正常的读写</li>
<li>处于恢复模式的集群,不能对外提供服务，这时节点有可能处于选举过程,同步过程</li>
</ol>
<p>广播模式比较简单,就是和二阶段提交类型,但是允许不超过半数的服务挂掉.客户端的写入请求都会转发给 leader,然后 leader 将消息发送给 follower,如果超过半数的follower响应成功,那么就提交 commit 操作,将数据持久化到磁盘</p>
<p><strong>消息广播过程</strong>:</p>
<ol>
<li>客户端发起写请求</li>
<li>Leader将客户端请求信息转化为事务Proposal,同时为每个Proposal分配一个事务ID（Zxid）</li>
<li>Leader为每个Follower单独分配一个FIFO的队列,将需要广播的Proposal依次放入到队列中</li>
<li>Follower接收到Proposal后,首先将其以事务日志的方式写入到本地磁盘中,写入成功后给Leader反馈一个ACK响应</li>
<li>Leader接收到半数以上Follower的ACK响应后,即认为消息发送成功,可以发送Commit消息</li>
<li>Leader向所有Follower广播Commit消息,同时自身也会完成事务提交.Follower接收到Commit消息后也会完成事务的提交</li>
</ol>
<p><strong>崩溃恢复过程:</strong></p>
<p>恢复模式有一点复杂,它会从集群中选举出一个节点作为 leader,这个节点需要具有最新的数据.而且这个 leader 需要被过半节点认同.我们</p>
<p>回想下 zookeeper 的写操作需要过半的节点完成才能认为成功,而选举也需要过半的节点都同意,那么两个集合之间必定有交叉,就可以保证</p>
<p>选举出来的是有最新数据的节点</p>
<p>加载过程: zookeeper 的节点会在本地磁盘持久化数据,启动时会加载这些本地数据,这些数据都是根据事务 id 顺序存储的,这样就可以根据</p>
<p>最大的事务 id 来判断数据的新旧</p>
<p>选举过程: 各个节点相同通信,选举出一个共同的 leader 节点.这个 leader 节点的选票必须过半,并且有着最新的数据</p>
<p>同步过程：当成为 follower 节点后,需要向 leader 节点同步数据,因为 follower 节点的数据可能落后于leader</p>
<p>处理请求：当同步过程完成后，集群就可以对外提供读写服务了</p>
<p>Zab协议规定了 <strong>如果⼀个事务Proposal在⼀台机器上被处理成功，那么应该在所有的机器上都被处理成功,哪怕机器出现故障崩溃.</strong> 针对这些情况ZAB协议需要保证以下条件</p>
<ol>
<li>已经在Leader服务器上提交的事务最终被所有服务器都提交</li>
</ol>
<p>假设⼀个事务在 Leader 服务器上被提交了,并且已经得到过半 Folower 服务器的Ack反馈,但是在它将Commit消息发送给所有Follower机器之前，Leader服务器挂了</p>
<ol start="2">
<li>丢弃只在Leader服务器上被提出（未提交）的事务</li>
</ol>
<p>假设初始的 Leader 服务器 Server1 在提出了⼀个事务Proposal3 之后就崩溃退出了,从⽽导致集群中的其他服务器都没有收到这个事务Proposal3.于是.当 Server1 恢复过来再次加入到集群中的时候.Zab 协议需要确保丢弃Proposal3这个事务</p>
<p><strong>综上所述，ZAB的选举出来的Leader必须满足以下条件：</strong></p>
<p>能够确保提交已经被 Leader 提交的事务 Proposal,同时丢弃已经被跳过的事务 Proposal.即：</p>
<ol>
<li><strong>新选举出来的 Leader 不能包含未提交的 Proposal.</strong></li>
<li><strong>新选举的 Leader 节点中含有最大的 zxid</strong> </li>
</ol>
<h5 id="FastLeaderElection"><a href="#FastLeaderElection" class="headerlink" title="FastLeaderElection"></a>FastLeaderElection</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastLeaderElection</span> <span class="keyword">implements</span> <span class="title">Election</span> </span>&#123;</span><br><span class="line">    AtomicLong logicalclock = <span class="keyword">new</span> AtomicLong();  <span class="comment">// 选举轮数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自身节点的投票信息</span></span><br><span class="line">    <span class="keyword">long</span> proposedLeader;  <span class="comment">// 哪个节点为leader</span></span><br><span class="line">    <span class="keyword">long</span> proposedZxid;    <span class="comment">// 选举的leader节点的最大事务id</span></span><br><span class="line">    <span class="keyword">long</span> proposedEpoch;   <span class="comment">// 选举的leader节点的最大epoch</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vote <span class="title">lookForLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 存储着来自同选举轮数，每个节点对应的投票，投票里包含了选举哪个节点作为leader</span></span><br><span class="line">        Map&lt;Long, Vote&gt; recvset = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</span><br><span class="line">        <span class="comment">// 存储着来自leader或者follower的投票</span></span><br><span class="line">        Map&lt;Long, Vote&gt; outofelection = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</span><br><span class="line">        <span class="comment">// 每次选举都会增加选举轮数</span></span><br><span class="line">        logicalclock.incrementAndGet();</span><br><span class="line">        <span class="comment">// 设置自身的投票信息</span></span><br><span class="line">        updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">        <span class="comment">// 发送投票给其余的节点</span></span><br><span class="line">        sendNotifications();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环，一直到选出leader为止</span></span><br><span class="line">        <span class="keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp; (!stop)) &#123;</span><br><span class="line">            <span class="comment">// 从队列里获取其余节点的投票信息</span></span><br><span class="line">            Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="comment">// 根据发送投票的节点的状态，做不同的处理</span></span><br><span class="line">            <span class="keyword">switch</span> (n.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> LOOKING:</span><br><span class="line">                 <span class="comment">// 发送节点的状态为LOOKING</span></span><br><span class="line">                 <span class="comment">// 先比较选举轮数，再比较epoch和事务id</span></span><br><span class="line">                 <span class="keyword">if</span> (n.electionEpoch &gt; logicalclock.get()) &#123;</span><br><span class="line">                     <span class="comment">// 如果自己的选举轮数落后，更新自己的选举轮数</span></span><br><span class="line">                     logicalclock.set(n.electionEpoch);</span><br><span class="line">                     <span class="comment">// 还需要清空旧的投票信息，因为这些都已经过时了</span></span><br><span class="line">                     recvset.clear();</span><br><span class="line">                     <span class="comment">// 比较谁更适合当选leader，如果是别的节点，那么就更新自己的投票信息</span></span><br><span class="line">                     <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(),                 getInitLastLoggedZxid(), getPeerEpoch())) &#123;</span><br><span class="line">                         updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// 需要重新发送投票，因为之前的已经过时了</span></span><br><span class="line">                     sendNotifications();</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n.electionEpoch &lt; logicalclock.get()) &#123;</span><br><span class="line">                     <span class="comment">// 如果发送投票的节点，选举轮数落后，那么就不用理睬</span></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) &#123;</span><br><span class="line">                     <span class="comment">// 如果别的节点更适合当选leader，那么就更新自己的投票信息，并且重新发送</span></span><br><span class="line">                     updateProposal(n.leader, n.zxid, n.peerEpoch);</span><br><span class="line">                     sendNotifications();</span><br><span class="line">                 &#125;</span><br><span class="line">                 </span><br><span class="line">                 <span class="comment">// 记录投票信息</span></span><br><span class="line">                 recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line">                </span><br><span class="line">                 <span class="comment">// 如果有超过半数的投票一致，那么有可能新的leader被选举出来了</span></span><br><span class="line">                <span class="keyword">if</span> (voteSet.hasAllQuorums()) &#123;</span><br><span class="line">                    <span class="comment">// 检测队列里的剩余投票请求，并且直到等待finalizeWait时间，仍然没有新的请求</span></span><br><span class="line">                    <span class="comment">// 如果有别的节点更适合当选leader，那么就跳到循环开始，来处理投票信息</span></span><br><span class="line">                    <span class="keyword">while</span> ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) &#123;</span><br><span class="line">                            recvqueue.put(n);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果仍然没有新请求，那么就认为leader选定出来了</span></span><br><span class="line">                    <span class="comment">// 根据比较节点id，判断是follower角色还是leader角色</span></span><br><span class="line">                    <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 这里会更新该节点的状态为follower或者leader</span></span><br><span class="line">                        setPeerState(proposedLeader, voteSet);</span><br><span class="line">                        <span class="comment">// 返回最终的选票</span></span><br><span class="line">                        Vote endVote = <span class="keyword">new</span> Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);</span><br><span class="line">                        <span class="keyword">return</span> endVote;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">            <span class="keyword">case</span> LEADING:</span><br><span class="line">                <span class="keyword">if</span>(n.electionEpoch == logicalclock.get())&#123;</span><br><span class="line">                    <span class="comment">// 在同一选举轮数中，已经有leader产生并且开始运行了</span></span><br><span class="line">                    recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</span><br><span class="line">                    <span class="keyword">if</span> (voteSet.hasAllQuorums() &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;</span><br><span class="line">                        <span class="comment">// 这里会更新该节点的状态为follower或者leader</span></span><br><span class="line">                        setPeerState(n.leader, voteSet);</span><br><span class="line">                        Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);</span><br><span class="line">                        <span class="keyword">return</span> endVote;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里不用区分选举轮数，因为follower和leader角色已经稳定运行了</span></span><br><span class="line">                outofelection.put(n.sid, <span class="keyword">new</span> Vote(n.version, n.leader,</span><br><span class="line">                                n.zxid, n.electionEpoch, n.peerEpoch, n.state));</span><br><span class="line">                <span class="comment">// 如果多数节点的投票相同，那么检查该leader节点是否处于leader状态</span></span><br><span class="line">                <span class="keyword">if</span> (voteSet.hasAllQuorums() &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;</span><br><span class="line">                    <span class="comment">// 设置选举轮数</span></span><br><span class="line">                    logicalclock.set(n.electionEpoch);</span><br><span class="line">                    <span class="comment">// 这里会更新该节点的状态为follower或者leader</span></span><br><span class="line">                    setPeerState(n.leader, voteSet);</span><br><span class="line">                    <span class="comment">// 返回最终的选票</span></span><br><span class="line">                	Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);</span><br><span class="line">                	<span class="keyword">return</span> endVote;</span><br><span class="line">                &#125;</span><br><span class="line">           		<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>//问题:</p>
<p>1.leader事务什么时候提交,等所有的follower事务提交完成还是发送commit之后还是等一半follower提交事务之后再提交leader的事务</p>
<p>2.leader提交事务之后会通知客户端吗</p>
<p>3.如果leader发送commit给follower那时,follower挂了怎么办?</p>
]]></content>
      <categories>
        <category>The Hadoop Ecosystem</category>
      </categories>
      <tags>
        <tag>Work Systematically</tag>
      </tags>
  </entry>
</search>
